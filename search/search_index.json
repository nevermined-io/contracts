{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Solidity API","text":""},{"location":"#testdisputemanager","title":"TestDisputeManager","text":""},{"location":"#accept","title":"accept","text":"<pre><code>mapping(bytes32 =&gt; bool) accept\n</code></pre>"},{"location":"#accepted","title":"accepted","text":"<pre><code>function accepted(address provider, address buyer, bytes32 orig, bytes32 crypted) public view returns (bool)\n</code></pre>"},{"location":"#setaccepted","title":"setAccepted","text":"<pre><code>function setAccepted(bytes32 orig, bytes32 crypted, address provider, address buyer) public\n</code></pre>"},{"location":"#plonkverifier","title":"PlonkVerifier","text":""},{"location":"#n","title":"n","text":"<pre><code>uint32 n\n</code></pre>"},{"location":"#npublic","title":"nPublic","text":"<pre><code>uint16 nPublic\n</code></pre>"},{"location":"#nlagrange","title":"nLagrange","text":"<pre><code>uint16 nLagrange\n</code></pre>"},{"location":"#qmx","title":"Qmx","text":"<pre><code>uint256 Qmx\n</code></pre>"},{"location":"#qmy","title":"Qmy","text":"<pre><code>uint256 Qmy\n</code></pre>"},{"location":"#qlx","title":"Qlx","text":"<pre><code>uint256 Qlx\n</code></pre>"},{"location":"#qly","title":"Qly","text":"<pre><code>uint256 Qly\n</code></pre>"},{"location":"#qrx","title":"Qrx","text":"<pre><code>uint256 Qrx\n</code></pre>"},{"location":"#qry","title":"Qry","text":"<pre><code>uint256 Qry\n</code></pre>"},{"location":"#qox","title":"Qox","text":"<pre><code>uint256 Qox\n</code></pre>"},{"location":"#qoy","title":"Qoy","text":"<pre><code>uint256 Qoy\n</code></pre>"},{"location":"#qcx","title":"Qcx","text":"<pre><code>uint256 Qcx\n</code></pre>"},{"location":"#qcy","title":"Qcy","text":"<pre><code>uint256 Qcy\n</code></pre>"},{"location":"#s1x","title":"S1x","text":"<pre><code>uint256 S1x\n</code></pre>"},{"location":"#s1y","title":"S1y","text":"<pre><code>uint256 S1y\n</code></pre>"},{"location":"#s2x","title":"S2x","text":"<pre><code>uint256 S2x\n</code></pre>"},{"location":"#s2y","title":"S2y","text":"<pre><code>uint256 S2y\n</code></pre>"},{"location":"#s3x","title":"S3x","text":"<pre><code>uint256 S3x\n</code></pre>"},{"location":"#s3y","title":"S3y","text":"<pre><code>uint256 S3y\n</code></pre>"},{"location":"#k1","title":"k1","text":"<pre><code>uint256 k1\n</code></pre>"},{"location":"#k2","title":"k2","text":"<pre><code>uint256 k2\n</code></pre>"},{"location":"#x2x1","title":"X2x1","text":"<pre><code>uint256 X2x1\n</code></pre>"},{"location":"#x2x2","title":"X2x2","text":"<pre><code>uint256 X2x2\n</code></pre>"},{"location":"#x2y1","title":"X2y1","text":"<pre><code>uint256 X2y1\n</code></pre>"},{"location":"#x2y2","title":"X2y2","text":"<pre><code>uint256 X2y2\n</code></pre>"},{"location":"#q","title":"q","text":"<pre><code>uint256 q\n</code></pre>"},{"location":"#qf","title":"qf","text":"<pre><code>uint256 qf\n</code></pre>"},{"location":"#w1","title":"w1","text":"<pre><code>uint256 w1\n</code></pre>"},{"location":"#g1x","title":"G1x","text":"<pre><code>uint256 G1x\n</code></pre>"},{"location":"#g1y","title":"G1y","text":"<pre><code>uint256 G1y\n</code></pre>"},{"location":"#g2x1","title":"G2x1","text":"<pre><code>uint256 G2x1\n</code></pre>"},{"location":"#g2x2","title":"G2x2","text":"<pre><code>uint256 G2x2\n</code></pre>"},{"location":"#g2y1","title":"G2y1","text":"<pre><code>uint256 G2y1\n</code></pre>"},{"location":"#g2y2","title":"G2y2","text":"<pre><code>uint256 G2y2\n</code></pre>"},{"location":"#pa","title":"pA","text":"<pre><code>uint16 pA\n</code></pre>"},{"location":"#pb","title":"pB","text":"<pre><code>uint16 pB\n</code></pre>"},{"location":"#pc","title":"pC","text":"<pre><code>uint16 pC\n</code></pre>"},{"location":"#pz","title":"pZ","text":"<pre><code>uint16 pZ\n</code></pre>"},{"location":"#pt1","title":"pT1","text":"<pre><code>uint16 pT1\n</code></pre>"},{"location":"#pt2","title":"pT2","text":"<pre><code>uint16 pT2\n</code></pre>"},{"location":"#pt3","title":"pT3","text":"<pre><code>uint16 pT3\n</code></pre>"},{"location":"#pwxi","title":"pWxi","text":"<pre><code>uint16 pWxi\n</code></pre>"},{"location":"#pwxiw","title":"pWxiw","text":"<pre><code>uint16 pWxiw\n</code></pre>"},{"location":"#peval_a","title":"pEval_a","text":"<pre><code>uint16 pEval_a\n</code></pre>"},{"location":"#peval_b","title":"pEval_b","text":"<pre><code>uint16 pEval_b\n</code></pre>"},{"location":"#peval_c","title":"pEval_c","text":"<pre><code>uint16 pEval_c\n</code></pre>"},{"location":"#peval_s1","title":"pEval_s1","text":"<pre><code>uint16 pEval_s1\n</code></pre>"},{"location":"#peval_s2","title":"pEval_s2","text":"<pre><code>uint16 pEval_s2\n</code></pre>"},{"location":"#peval_zw","title":"pEval_zw","text":"<pre><code>uint16 pEval_zw\n</code></pre>"},{"location":"#peval_r","title":"pEval_r","text":"<pre><code>uint16 pEval_r\n</code></pre>"},{"location":"#palpha","title":"pAlpha","text":"<pre><code>uint16 pAlpha\n</code></pre>"},{"location":"#pbeta","title":"pBeta","text":"<pre><code>uint16 pBeta\n</code></pre>"},{"location":"#pgamma","title":"pGamma","text":"<pre><code>uint16 pGamma\n</code></pre>"},{"location":"#pxi","title":"pXi","text":"<pre><code>uint16 pXi\n</code></pre>"},{"location":"#pxin","title":"pXin","text":"<pre><code>uint16 pXin\n</code></pre>"},{"location":"#pbetaxi","title":"pBetaXi","text":"<pre><code>uint16 pBetaXi\n</code></pre>"},{"location":"#pv1","title":"pV1","text":"<pre><code>uint16 pV1\n</code></pre>"},{"location":"#pv2","title":"pV2","text":"<pre><code>uint16 pV2\n</code></pre>"},{"location":"#pv3","title":"pV3","text":"<pre><code>uint16 pV3\n</code></pre>"},{"location":"#pv4","title":"pV4","text":"<pre><code>uint16 pV4\n</code></pre>"},{"location":"#pv5","title":"pV5","text":"<pre><code>uint16 pV5\n</code></pre>"},{"location":"#pv6","title":"pV6","text":"<pre><code>uint16 pV6\n</code></pre>"},{"location":"#pu","title":"pU","text":"<pre><code>uint16 pU\n</code></pre>"},{"location":"#ppl","title":"pPl","text":"<pre><code>uint16 pPl\n</code></pre>"},{"location":"#peval_t","title":"pEval_t","text":"<pre><code>uint16 pEval_t\n</code></pre>"},{"location":"#pa1","title":"pA1","text":"<pre><code>uint16 pA1\n</code></pre>"},{"location":"#pb1","title":"pB1","text":"<pre><code>uint16 pB1\n</code></pre>"},{"location":"#pzh","title":"pZh","text":"<pre><code>uint16 pZh\n</code></pre>"},{"location":"#pzhinv","title":"pZhInv","text":"<pre><code>uint16 pZhInv\n</code></pre>"},{"location":"#peval_l1","title":"pEval_l1","text":"<pre><code>uint16 pEval_l1\n</code></pre>"},{"location":"#peval_l2","title":"pEval_l2","text":"<pre><code>uint16 pEval_l2\n</code></pre>"},{"location":"#peval_l3","title":"pEval_l3","text":"<pre><code>uint16 pEval_l3\n</code></pre>"},{"location":"#peval_l4","title":"pEval_l4","text":"<pre><code>uint16 pEval_l4\n</code></pre>"},{"location":"#peval_l5","title":"pEval_l5","text":"<pre><code>uint16 pEval_l5\n</code></pre>"},{"location":"#peval_l6","title":"pEval_l6","text":"<pre><code>uint16 pEval_l6\n</code></pre>"},{"location":"#peval_l7","title":"pEval_l7","text":"<pre><code>uint16 pEval_l7\n</code></pre>"},{"location":"#lastmem","title":"lastMem","text":"<pre><code>uint16 lastMem\n</code></pre>"},{"location":"#verifyproof","title":"verifyProof","text":"<pre><code>function verifyProof(bytes proof, uint256[] pubSignals) public view returns (bool)\n</code></pre>"},{"location":"#common","title":"Common","text":""},{"location":"#getcurrentblocknumber","title":"getCurrentBlockNumber","text":"<pre><code>function getCurrentBlockNumber() external view returns (uint256)\n</code></pre> <p>getCurrentBlockNumber get block number</p> Name Type Description [0] uint256 the current block number"},{"location":"#iscontract","title":"isContract","text":"<pre><code>function isContract(address addr) public view returns (bool)\n</code></pre> <p>isContract detect whether the address is           is a contract address or externally owned account</p> Name Type Description [0] bool true if it is a contract address"},{"location":"#provenancesignatureiscorrect","title":"provenanceSignatureIsCorrect","text":"<pre><code>function provenanceSignatureIsCorrect(address _agentId, bytes32 _hash, bytes _signature) public pure returns (bool)\n</code></pre> Name Type Description _agentId address The address of the agent _hash bytes32 bytes32 message, the hash is the signed message. What is recovered is the signer address. _signature bytes Signatures provided by the agent Name Type Description [0] bool true if the signature correspond to the agent address"},{"location":"#calculatetotalamount","title":"calculateTotalAmount","text":"<pre><code>function calculateTotalAmount(uint256[] _amounts) public pure returns (uint256)\n</code></pre> <p>Sum the total amount given an uint array</p> Name Type Description [0] uint256 the total amount"},{"location":"#addresstobytes32","title":"addressToBytes32","text":"<pre><code>function addressToBytes32(address _addr) public pure returns (bytes32)\n</code></pre>"},{"location":"#bytes32toaddress","title":"bytes32ToAddress","text":"<pre><code>function bytes32ToAddress(bytes32 _b32) public pure returns (address)\n</code></pre>"},{"location":"#dispenser","title":"Dispenser","text":""},{"location":"#tokenrequests","title":"tokenRequests","text":"<pre><code>mapping(address =&gt; uint256) tokenRequests\n</code></pre>"},{"location":"#totalmintamount","title":"totalMintAmount","text":"<pre><code>uint256 totalMintAmount\n</code></pre>"},{"location":"#maxamount","title":"maxAmount","text":"<pre><code>uint256 maxAmount\n</code></pre>"},{"location":"#maxmintamount","title":"maxMintAmount","text":"<pre><code>uint256 maxMintAmount\n</code></pre>"},{"location":"#minperiod","title":"minPeriod","text":"<pre><code>uint256 minPeriod\n</code></pre>"},{"location":"#scale","title":"scale","text":"<pre><code>uint256 scale\n</code></pre>"},{"location":"#token","title":"token","text":"<pre><code>contract NeverminedToken token\n</code></pre>"},{"location":"#requestfrequencyexceeded","title":"RequestFrequencyExceeded","text":"<pre><code>event RequestFrequencyExceeded(address requester, uint256 minPeriod)\n</code></pre>"},{"location":"#requestlimitexceeded","title":"RequestLimitExceeded","text":"<pre><code>event RequestLimitExceeded(address requester, uint256 amount, uint256 maxAmount)\n</code></pre>"},{"location":"#isvalidaddress","title":"isValidAddress","text":"<pre><code>modifier isValidAddress(address _address)\n</code></pre>"},{"location":"#initialize","title":"initialize","text":"<pre><code>function initialize(address _tokenAddress, address _owner) external\n</code></pre> <p>Dispenser Initializer</p> Name Type Description _tokenAddress address The deployed contract address of an ERC20 _owner address The owner of the Dispenser Runs only on initial contract creation."},{"location":"#requesttokens","title":"requestTokens","text":"<pre><code>function requestTokens(uint256 amount) external returns (bool tokensTransferred)\n</code></pre> <p>user can request some tokens for testing</p> Name Type Description amount uint256 the amount of tokens to be requested Name Type Description tokensTransferred bool Boolean indication of tokens are requested"},{"location":"#setminperiod","title":"setMinPeriod","text":"<pre><code>function setMinPeriod(uint256 period) external\n</code></pre> <p>the Owner can set the min period for token requests</p> Name Type Description period uint256 the min amount of time before next request"},{"location":"#setmaxamount","title":"setMaxAmount","text":"<pre><code>function setMaxAmount(uint256 amount) external\n</code></pre> <p>the Owner can set the max amount for token requests</p> Name Type Description amount uint256 the max amount of tokens that can be requested"},{"location":"#setmaxmintamount","title":"setMaxMintAmount","text":"<pre><code>function setMaxMintAmount(uint256 amount) external\n</code></pre> <p>the Owner can set the max amount for token requests</p> Name Type Description amount uint256 the max amount of tokens that can be requested"},{"location":"#hashlists","title":"HashLists","text":"<p>Hash lists contract is a sample list contract in which uses       HashListLibrary.sol in order to store, retrieve, remove, and       update bytes32 values in hash lists.      This is a reference implementation for IList interface. It is       used for whitelisting condition. Any entity can have its own       implementation of the interface in which could be used for the      same condition.</p>"},{"location":"#lists","title":"lists","text":"<pre><code>mapping(bytes32 =&gt; struct HashListLibrary.List) lists\n</code></pre>"},{"location":"#initialize_1","title":"initialize","text":"<pre><code>function initialize(address _owner) public\n</code></pre> <p>HashLists Initializer</p> Name Type Description _owner address The owner of the hash list Runs only upon contract creation."},{"location":"#hash","title":"hash","text":"<pre><code>function hash(address account) public pure returns (bytes32)\n</code></pre> <p>hash ethereum accounts</p> Name Type Description account address Ethereum address Name Type Description [0] bytes32 bytes32 hash of the account"},{"location":"#add","title":"add","text":"<pre><code>function add(bytes32[] values) external returns (bool)\n</code></pre> <p>put an array of elements without indexing      this meant to save gas in case of large arrays</p> Name Type Description values bytes32[] is an array of elements value Name Type Description [0] bool true if values are added successfully"},{"location":"#add_1","title":"add","text":"<pre><code>function add(bytes32 value) external returns (bool)\n</code></pre> <p>add indexes an element then adds it to a list</p> Name Type Description value bytes32 is a bytes32 value Name Type Description [0] bool true if value is added successfully"},{"location":"#update","title":"update","text":"<pre><code>function update(bytes32 oldValue, bytes32 newValue) external returns (bool)\n</code></pre> <p>update the value with a new value and maintain indices</p> Name Type Description oldValue bytes32 is an element value in a list newValue bytes32 new value Name Type Description [0] bool true if value is updated successfully"},{"location":"#index","title":"index","text":"<pre><code>function index(uint256 from, uint256 to) external returns (bool)\n</code></pre> <p>index is used to map each element value to its index on the list</p> Name Type Description from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Name Type Description [0] bool true if the sub list is indexed"},{"location":"#has","title":"has","text":"<pre><code>function has(bytes32 id, bytes32 value) external view returns (bool)\n</code></pre> <p>has checks whether a value is exist</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Name Type Description [0] bool true if the value exists"},{"location":"#has_1","title":"has","text":"<pre><code>function has(bytes32 value) external view returns (bool)\n</code></pre> <p>has checks whether a value is exist</p> Name Type Description value bytes32 is element value in list Name Type Description [0] bool true if the value exists"},{"location":"#remove","title":"remove","text":"<pre><code>function remove(bytes32 value) external returns (bool)\n</code></pre> <p>remove value from a list, updates indices, and list size</p> Name Type Description value bytes32 is an element value in a list Name Type Description [0] bool true if value is removed successfully"},{"location":"#get","title":"get","text":"<pre><code>function get(bytes32 id, uint256 _index) external view returns (bytes32)\n</code></pre> <p>has value by index</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) _index uint256 is where is value is stored in the list Name Type Description [0] bytes32 the value if exists"},{"location":"#size","title":"size","text":"<pre><code>function size(bytes32 id) external view returns (uint256)\n</code></pre> <p>size gets the list size</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] uint256 total length of the list"},{"location":"#all","title":"all","text":"<pre><code>function all(bytes32 id) external view returns (bytes32[])\n</code></pre> <p>all returns all list elements</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] bytes32[] all list elements"},{"location":"#indexof","title":"indexOf","text":"<pre><code>function indexOf(bytes32 id, bytes32 value) external view returns (uint256)\n</code></pre> <p>indexOf gets the index of a value in a list</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Name Type Description [0] uint256 value index in list"},{"location":"#ownedby","title":"ownedBy","text":"<pre><code>function ownedBy(bytes32 id) external view returns (address)\n</code></pre> <p>ownedBy gets the list owner</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] address list owner"},{"location":"#isindexed","title":"isIndexed","text":"<pre><code>function isIndexed(bytes32 id) external view returns (bool)\n</code></pre> <p>isIndexed checks if the list is indexed</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] bool true if the list is indexed"},{"location":"#neverminedtoken","title":"NeverminedToken","text":"<p>Implementation of a Test Token.      Test Token is an ERC20 token only for testing purposes</p>"},{"location":"#initialize_2","title":"initialize","text":"<pre><code>function initialize(address _owner, address payable _initialMinter) public\n</code></pre> <p>NeverminedToken Initializer      Runs only on initial contract creation.</p> Name Type Description _owner address refers to the owner of the contract _initialMinter address payable is the first token minter added"},{"location":"#_beforetokentransfer","title":"_beforeTokenTransfer","text":"<pre><code>function _beforeTokenTransfer(address from, address to, uint256 amount) internal\n</code></pre> <p>_See {ERC20-_beforeTokenTransfer}.</p> <p>Requirements:</p> <ul> <li>minted tokens must not cause the total supply to go over the cap._</li> </ul>"},{"location":"#mint","title":"mint","text":"<pre><code>function mint(address account, uint256 amount) external returns (bool)\n</code></pre> <p>_Creates <code>amount</code> tokens and assigns them to <code>account</code>, increasing the total supply.</p> <p>Emits a {Transfer} event with <code>from</code> set to the zero address.</p> <p>Requirements:</p> <ul> <li><code>to</code> cannot be the zero address._</li> </ul>"},{"location":"#agreementstorelibrary","title":"AgreementStoreLibrary","text":"<p>Implementation of the Agreement Store Library.      The agreement store library holds the business logic      in which manages the life cycle of SEA agreement, each       agreement is linked to the DID of an asset, template, and      condition IDs.</p>"},{"location":"#agreement","title":"Agreement","text":"<pre><code>struct Agreement {\n  bytes32 did;\n  address templateId;\n  bytes32[] conditionIds;\n  address lastUpdatedBy;\n  uint256 blockNumberUpdated;\n}\n</code></pre>"},{"location":"#agreementlist","title":"AgreementList","text":"<pre><code>struct AgreementList {\n  mapping(bytes32 &amp;#x3D;&amp;gt; struct AgreementStoreLibrary.Agreement) agreements;\n  mapping(bytes32 &amp;#x3D;&amp;gt; bytes32[]) didToAgreementIds;\n  mapping(address &amp;#x3D;&amp;gt; bytes32[]) templateIdToAgreementIds;\n  bytes32[] agreementIds;\n}\n</code></pre>"},{"location":"#create","title":"create","text":"<pre><code>function create(struct AgreementStoreLibrary.AgreementList _self, bytes32 _id, bytes32, address _templateId, bytes32[]) internal\n</code></pre> <p>create new agreement      checks whether the agreement Id exists, creates new agreement       instance, including the template, conditions and DID.</p> Name Type Description _self struct AgreementStoreLibrary.AgreementList is AgreementList storage pointer _id bytes32 agreement identifier bytes32 _templateId address template identifier bytes32[]"},{"location":"#template","title":"Template","text":""},{"location":"#getconditiontypes","title":"getConditionTypes","text":"<pre><code>function getConditionTypes() external view returns (address[])\n</code></pre>"},{"location":"#agreementstoremanager","title":"AgreementStoreManager","text":"<p>_Implementation of the Agreement Store.</p> <pre><code> The agreement store generates conditions for an agreement template.\n Agreement templates must to be approved in the Template Store\n Each agreement is linked to the DID of an asset._\n</code></pre>"},{"location":"#proxy_role","title":"PROXY_ROLE","text":"<pre><code>bytes32 PROXY_ROLE\n</code></pre>"},{"location":"#grantproxyrole","title":"grantProxyRole","text":"<pre><code>function grantProxyRole(address _address) public\n</code></pre>"},{"location":"#revokeproxyrole","title":"revokeProxyRole","text":"<pre><code>function revokeProxyRole(address _address) public\n</code></pre>"},{"location":"#agreementlist_1","title":"agreementList","text":"<pre><code>struct AgreementStoreLibrary.AgreementList agreementList\n</code></pre> <p>state storage for the agreements</p>"},{"location":"#conditionstoremanager","title":"conditionStoreManager","text":"<pre><code>contract ConditionStoreManager conditionStoreManager\n</code></pre>"},{"location":"#templatestoremanager","title":"templateStoreManager","text":"<pre><code>contract TemplateStoreManager templateStoreManager\n</code></pre>"},{"location":"#didregistry","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#initialize_3","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _templateStoreManagerAddress, address _didRegistryAddress) public\n</code></pre> <p>initialize AgreementStoreManager Initializer      Initializes Ownable. Only on contract creation.</p> Name Type Description _owner address refers to the owner of the contract _conditionStoreManagerAddress address is the address of the connected condition store _templateStoreManagerAddress address is the address of the connected template store _didRegistryAddress address is the address of the connected DID Registry"},{"location":"#fullconditionid","title":"fullConditionId","text":"<pre><code>function fullConditionId(bytes32 _agreementId, address _condType, bytes32 _valueHash) public pure returns (bytes32)\n</code></pre>"},{"location":"#agreementid","title":"agreementId","text":"<pre><code>function agreementId(bytes32 _agreementId, address _creator) public pure returns (bytes32)\n</code></pre>"},{"location":"#createagreement","title":"createAgreement","text":"<pre><code>function createAgreement(bytes32 _id, bytes32 _did, address[] _conditionTypes, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts) public\n</code></pre> <p>Create a new agreement.      The agreement will create conditions of conditionType with conditionId.      Only \"approved\" templates can access this function.</p> Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition"},{"location":"#createagreementargs","title":"CreateAgreementArgs","text":"<pre><code>struct CreateAgreementArgs {\n  bytes32 _id;\n  bytes32 _did;\n  address[] _conditionTypes;\n  bytes32[] _conditionIds;\n  uint256[] _timeLocks;\n  uint256[] _timeOuts;\n  address _creator;\n  uint256 _idx;\n  address payable _rewardAddress;\n  address _tokenAddress;\n  uint256[] _amounts;\n  address[] _receivers;\n}\n</code></pre>"},{"location":"#createagreementandpay","title":"createAgreementAndPay","text":"<pre><code>function createAgreementAndPay(struct AgreementStoreManager.CreateAgreementArgs args) public payable\n</code></pre>"},{"location":"#createagreementandfulfill","title":"createAgreementAndFulfill","text":"<pre><code>function createAgreementAndFulfill(bytes32 _id, bytes32 _did, address[] _conditionTypes, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address[] _account, uint256[] _idx, bytes[] params) public payable\n</code></pre>"},{"location":"#getagreementtemplate","title":"getAgreementTemplate","text":"<pre><code>function getAgreementTemplate(bytes32 _id) external view returns (address)\n</code></pre>"},{"location":"#getdidregistryaddress","title":"getDIDRegistryAddress","text":"<pre><code>function getDIDRegistryAddress() public view virtual returns (address)\n</code></pre> <p>getDIDRegistryAddress utility function  used by other contracts or any EOA.</p> Name Type Description [0] address the DIDRegistry address"},{"location":"#accesscondition","title":"AccessCondition","text":"<p>_Implementation of the Access Condition</p> <pre><code> Access Secret Store Condition is special condition\n where a client or Parity secret store can encrypt/decrypt documents \n based on the on-chain granted permissions. For a given DID \n document, and agreement ID, the owner/provider of the DID \n will fulfill the condition. Consequently secret store \n will check whether the permission is granted for the consumer\n in order to encrypt/decrypt the document._\n</code></pre>"},{"location":"#condition_type","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#documentpermission","title":"DocumentPermission","text":"<pre><code>struct DocumentPermission {\n  bytes32 agreementIdDeprecated;\n  mapping(address &amp;#x3D;&amp;gt; bool) permission;\n}\n</code></pre>"},{"location":"#documentpermissions","title":"documentPermissions","text":"<pre><code>mapping(bytes32 =&gt; struct AccessCondition.DocumentPermission) documentPermissions\n</code></pre>"},{"location":"#agreementstoremanager_1","title":"agreementStoreManager","text":"<pre><code>contract AgreementStoreManager agreementStoreManager\n</code></pre>"},{"location":"#didregistry_1","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#fulfilled","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _documentId, address _grantee, bytes32 _conditionId)\n</code></pre>"},{"location":"#onlydidownerorprovider","title":"onlyDIDOwnerOrProvider","text":"<pre><code>modifier onlyDIDOwnerOrProvider(bytes32 _documentId)\n</code></pre>"},{"location":"#initialize_4","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _agreementStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address"},{"location":"#reinitialize","title":"reinitialize","text":"<pre><code>function reinitialize() external\n</code></pre> <p>Should be called when the contract has been upgraded.</p>"},{"location":"#hashvalues","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _documentId, address _grantee) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _documentId, address _grantee) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill access secret store condition</p> <p>only DID owner or DID provider can call this       method. Fulfill method sets the permissions        for the granted consumer's address to true then       fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#grantpermission","title":"grantPermission","text":"<pre><code>function grantPermission(address _grantee, bytes32 _documentId) public\n</code></pre> <p>grantPermission is called only by DID owner or provider</p> Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys"},{"location":"#renouncepermission","title":"renouncePermission","text":"<pre><code>function renouncePermission(address _grantee, bytes32 _documentId) public\n</code></pre> <p>renouncePermission is called only by DID owner or provider</p> Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys"},{"location":"#checkpermissions","title":"checkPermissions","text":"<pre><code>function checkPermissions(address _grantee, bytes32 _documentId) external view returns (bool permissionGranted)\n</code></pre> <p>checkPermissions is called by Parity secret store</p> Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys Name Type Description permissionGranted bool true if the access was granted"},{"location":"#idisputemanager","title":"IDisputeManager","text":""},{"location":"#verifyproof_1","title":"verifyProof","text":"<pre><code>function verifyProof(bytes proof, uint256[] pubSignals) external view returns (bool)\n</code></pre>"},{"location":"#accessproofcondition","title":"AccessProofCondition","text":"<p>Implementation of the Access Condition with transfer proof. The idea is that the hash of the decryption key is known before hand, and the key matching this hash is passed from data provider to the buyer using this smart contract. Using ZK proof the key is kept hidden from outsiders. For the protocol to work, both the provider and buyer need to have public keys in the babyjub curve. To initiate the deal, buyer will pass the key hash and the public keys of participants. The provider needs to pass the cipher text encrypted using MIMC (symmetric encryption). The secret key for MIMC is computed using ECDH (requires one public key and one secret key for the curve). The hash function that is used is Poseidon.</p>"},{"location":"#condition_type_1","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#agreementstoremanager_2","title":"agreementStoreManager","text":"<pre><code>contract AgreementStoreManager agreementStoreManager\n</code></pre>"},{"location":"#disputemanager","title":"disputeManager","text":"<pre><code>contract IDisputeManager disputeManager\n</code></pre>"},{"location":"#fulfilled_1","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, uint256 _origHash, uint256[2] _buyer, uint256[2] _provider, uint256[2] _cipher, bytes _proof, bytes32 _conditionId)\n</code></pre>"},{"location":"#initialize_5","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _agreementStoreManagerAddress, address _disputeManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address _disputeManagerAddress address dispute manager address"},{"location":"#changedisputemanager","title":"changeDisputeManager","text":"<pre><code>function changeDisputeManager(address _disputeManagerAddress) external\n</code></pre>"},{"location":"#hashvalues_1","title":"hashValues","text":"<pre><code>function hashValues(uint256 _origHash, uint256[2] _buyer, uint256[2] _provider) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _origHash uint256 is the hash of the key _buyer uint256[2] buyer public key _provider uint256[2] provider public key Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_1","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, uint256 _origHash, uint256[2] _buyer, uint256[2] _provider, uint256[2] _cipher, bytes _proof) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill key transfer</p> <p>The key with hash _origHash is transferred to the _buyer from _provider.</p> Name Type Description _agreementId bytes32 associated agreement _origHash uint256 is the hash of data to access _buyer uint256[2] buyer public key _provider uint256[2] provider public key _cipher uint256[2] encrypted version of the key _proof bytes SNARK proof that the cipher text can be decrypted by buyer to give the key with hash _origHash Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#computeexecutioncondition","title":"ComputeExecutionCondition","text":"<p>Implementation of the Compute Execution Condition      This condition is meant to be a signal in which triggers      the execution of a compute service. The compute service is fully described      in the associated DID document. The provider of the compute service will      send this signal to its workers by fulfilling the condition where      they are listening to the fulfilled event.</p>"},{"location":"#condition_type_2","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#computeexecutionstatus","title":"computeExecutionStatus","text":"<pre><code>mapping(bytes32 =&gt; mapping(address =&gt; bool)) computeExecutionStatus\n</code></pre>"},{"location":"#agreementstoremanager_3","title":"agreementStoreManager","text":"<pre><code>contract AgreementStoreManager agreementStoreManager\n</code></pre>"},{"location":"#fulfilled_2","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, address _computeConsumer, bytes32 _conditionId)\n</code></pre>"},{"location":"#onlydidownerorprovider_1","title":"onlyDIDOwnerOrProvider","text":"<pre><code>modifier onlyDIDOwnerOrProvider(bytes32 _did)\n</code></pre>"},{"location":"#initialize_6","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _agreementStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address"},{"location":"#hashvalues_2","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _computeConsumer) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_2","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _computeConsumer) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill compute execution condition</p> <p>only the compute provider can fulfill this condition. By fulfilling this  condition the compute provider will trigger the execution of  the offered job/compute. The compute service is described in a DID document.</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#wascomputetriggered","title":"wasComputeTriggered","text":"<pre><code>function wasComputeTriggered(bytes32 _did, address _computeConsumer) public view returns (bool)\n</code></pre> <p>wasComputeTriggered checks whether the compute is triggered or not.</p> Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the compute consumer's address Name Type Description [0] bool true if the compute is triggered"},{"location":"#condition","title":"Condition","text":"<p>_Implementation of the Condition</p> <pre><code> Each condition has a validation function that returns either FULFILLED, \n ABORTED or UNFULFILLED. When a condition is successfully solved, we call \n it FULFILLED. If a condition cannot be FULFILLED anymore due to a timeout \n or other types of counter-proofs, the condition is ABORTED. UNFULFILLED \n values imply that a condition has not been provably FULFILLED or ABORTED. \n All initialized conditions start out as UNFULFILLED._\n</code></pre>"},{"location":"#conditionstoremanager_1","title":"conditionStoreManager","text":"<pre><code>contract ConditionStoreManager conditionStoreManager\n</code></pre>"},{"location":"#generateid","title":"generateId","text":"<pre><code>function generateId(bytes32 _agreementId, bytes32 _valueHash) public view returns (bytes32)\n</code></pre> <p>generateId condition Id from the following        parameters</p> Name Type Description _agreementId bytes32 SEA agreement ID _valueHash bytes32 hash of all the condition input values"},{"location":"#fulfill_3","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _id, enum ConditionStoreLibrary.ConditionState _newState) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill set the condition state to Fulfill | Abort</p> Name Type Description _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState new condition state (Fulfill/Abort) Name Type Description [0] enum ConditionStoreLibrary.ConditionState the updated condition state"},{"location":"#abortbytimeout","title":"abortByTimeOut","text":"<pre><code>function abortByTimeOut(bytes32 _id) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>abortByTimeOut set condition state to Aborted          if the condition is timed out</p> Name Type Description _id bytes32 condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState the updated condition state"},{"location":"#conditionstorelibrary","title":"ConditionStoreLibrary","text":"<p>_Implementation of the Condition Store Library.</p> <pre><code> Condition is a key component in the service execution agreement. \n This library holds the logic for creating and updating condition \n Any Condition has only four state transitions starts with Uninitialized,\n Unfulfilled, Fulfilled, and Aborted. Condition state transition goes only \n forward from Unintialized -&gt; Unfulfilled -&gt; {Fulfilled || Aborted}_\n</code></pre>"},{"location":"#conditionstate","title":"ConditionState","text":"<pre><code>enum ConditionState {\n  Uninitialized,\n  Unfulfilled,\n  Fulfilled,\n  Aborted\n}\n</code></pre>"},{"location":"#condition_1","title":"Condition","text":"<pre><code>struct Condition {\n  address typeRef;\n  enum ConditionStoreLibrary.ConditionState state;\n  address createdBy;\n  address lastUpdatedBy;\n  uint256 blockNumberUpdated;\n}\n</code></pre>"},{"location":"#conditionlist","title":"ConditionList","text":"<pre><code>struct ConditionList {\n  mapping(bytes32 &amp;#x3D;&amp;gt; struct ConditionStoreLibrary.Condition) conditions;\n  mapping(bytes32 &amp;#x3D;&amp;gt; mapping(bytes32 &amp;#x3D;&amp;gt; bytes32)) map;\n  bytes32[] conditionIds;\n}\n</code></pre>"},{"location":"#create_1","title":"create","text":"<pre><code>function create(struct ConditionStoreLibrary.ConditionList _self, bytes32 _id, address _typeRef) internal\n</code></pre> <p>create new condition</p> <p>check whether the condition exists, assigns        condition type, condition state, last updated by,        and update at (which is the current block number)</p> Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 valid condition identifier _typeRef address condition contract address"},{"location":"#updatestate","title":"updateState","text":"<pre><code>function updateState(struct ConditionStoreLibrary.ConditionList _self, bytes32 _id, enum ConditionStoreLibrary.ConditionState _newState) internal\n</code></pre> <p>updateState update the condition state</p> <p>check whether the condition state transition is right,       assign the new state, update last updated by and       updated at.</p> Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState the new state of the condition"},{"location":"#updatekeyvalue","title":"updateKeyValue","text":"<pre><code>function updateKeyValue(struct ConditionStoreLibrary.ConditionList _self, bytes32 _id, bytes32 _key, bytes32 _value) internal\n</code></pre>"},{"location":"#conditionstoremanager_2","title":"ConditionStoreManager","text":"<p>_Implementation of the Condition Store Manager.</p> <pre><code> Condition store manager is responsible for enforcing the \n the business logic behind creating/updating the condition state\n based on the assigned role to each party. Only specific type of\n contracts are allowed to call this contract, therefore there are \n two types of roles, create role that in which is able to create conditions.\n The second role is the update role, which is can update the condition state.\n Also, it support delegating the roles to other contract(s)/account(s)._\n</code></pre>"},{"location":"#proxy_role_1","title":"PROXY_ROLE","text":"<pre><code>bytes32 PROXY_ROLE\n</code></pre>"},{"location":"#roletype","title":"RoleType","text":"<pre><code>enum RoleType {\n  Create,\n  Update\n}\n</code></pre>"},{"location":"#createrole","title":"createRole","text":"<pre><code>address createRole\n</code></pre>"},{"location":"#conditionlist_1","title":"conditionList","text":"<pre><code>struct ConditionStoreLibrary.ConditionList conditionList\n</code></pre>"},{"location":"#epochlist","title":"epochList","text":"<pre><code>struct EpochLibrary.EpochList epochList\n</code></pre>"},{"location":"#nvmconfigaddress","title":"nvmConfigAddress","text":"<pre><code>address nvmConfigAddress\n</code></pre>"},{"location":"#conditioncreated","title":"ConditionCreated","text":"<pre><code>event ConditionCreated(bytes32 _id, address _typeRef, address _who)\n</code></pre>"},{"location":"#conditionupdated","title":"ConditionUpdated","text":"<pre><code>event ConditionUpdated(bytes32 _id, address _typeRef, enum ConditionStoreLibrary.ConditionState _state, address _who)\n</code></pre>"},{"location":"#onlycreaterole","title":"onlyCreateRole","text":"<pre><code>modifier onlyCreateRole()\n</code></pre>"},{"location":"#onlyupdaterole","title":"onlyUpdateRole","text":"<pre><code>modifier onlyUpdateRole(bytes32 _id)\n</code></pre>"},{"location":"#onlyvalidtype","title":"onlyValidType","text":"<pre><code>modifier onlyValidType(address typeRef)\n</code></pre>"},{"location":"#initialize_7","title":"initialize","text":"<pre><code>function initialize(address _creator, address _owner, address _nvmConfigAddress) public\n</code></pre> <p>initialize ConditionStoreManager Initializer      Initialize Ownable. Only on contract creation,</p> Name Type Description _creator address refers to the creator of the contract _owner address refers to the owner of the contract _nvmConfigAddress address refers to the contract address of <code>NeverminedConfig</code>"},{"location":"#getcreaterole","title":"getCreateRole","text":"<pre><code>function getCreateRole() external view returns (address)\n</code></pre> <p>getCreateRole get the address of contract      which has the create role</p> Name Type Description [0] address create condition role address"},{"location":"#getnvmconfigaddress","title":"getNvmConfigAddress","text":"<pre><code>function getNvmConfigAddress() external view returns (address)\n</code></pre> <p>getNvmConfigAddress get the address of the NeverminedConfig contract</p> Name Type Description [0] address NeverminedConfig contract address"},{"location":"#setnvmconfigaddress","title":"setNvmConfigAddress","text":"<pre><code>function setNvmConfigAddress(address _addr) external\n</code></pre>"},{"location":"#delegatecreaterole","title":"delegateCreateRole","text":"<pre><code>function delegateCreateRole(address delegatee) external\n</code></pre> <p>delegateCreateRole only owner can delegate the       create condition role to a different address</p> Name Type Description delegatee address delegatee address"},{"location":"#delegateupdaterole","title":"delegateUpdateRole","text":"<pre><code>function delegateUpdateRole(bytes32 _id, address delegatee) external\n</code></pre> <p>delegateUpdateRole only owner can delegate       the update role to a different address for       specific condition Id which has the create role</p> Name Type Description _id bytes32 delegatee address delegatee address"},{"location":"#grantproxyrole_1","title":"grantProxyRole","text":"<pre><code>function grantProxyRole(address _address) public\n</code></pre>"},{"location":"#revokeproxyrole_1","title":"revokeProxyRole","text":"<pre><code>function revokeProxyRole(address _address) public\n</code></pre>"},{"location":"#createcondition","title":"createCondition","text":"<pre><code>function createCondition(bytes32 _id, address _typeRef) external\n</code></pre> <p>createCondition only called by create role address       the condition should use a valid condition contract       address, valid time lock and timeout. Moreover, it       enforce the condition state transition from       Uninitialized to Unfulfilled.</p> Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address"},{"location":"#createcondition2","title":"createCondition2","text":"<pre><code>function createCondition2(bytes32 _id, address _typeRef) external\n</code></pre>"},{"location":"#createcondition_1","title":"createCondition","text":"<pre><code>function createCondition(bytes32 _id, address _typeRef, uint256 _timeLock, uint256 _timeOut) public\n</code></pre> <p>createCondition only called by create role address       the condition should use a valid condition contract       address, valid time lock and timeout. Moreover, it       enforce the condition state transition from       Uninitialized to Unfulfilled.</p> Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _timeLock uint256 start of the time window _timeOut uint256 end of the time window"},{"location":"#updateconditionstate","title":"updateConditionState","text":"<pre><code>function updateConditionState(bytes32 _id, enum ConditionStoreLibrary.ConditionState _newState) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>updateConditionState only called by update role address.       It enforce the condition state transition to either       Fulfill or Aborted state</p> Name Type Description _id bytes32 unique condition identifier _newState enum ConditionStoreLibrary.ConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState the current condition state"},{"location":"#updateconditionmapping","title":"updateConditionMapping","text":"<pre><code>function updateConditionMapping(bytes32 _id, bytes32 _key, bytes32 _value) external\n</code></pre>"},{"location":"#updateconditionmappingproxy","title":"updateConditionMappingProxy","text":"<pre><code>function updateConditionMappingProxy(bytes32 _id, bytes32 _key, bytes32 _value) external\n</code></pre>"},{"location":"#getcondition","title":"getCondition","text":"<pre><code>function getCondition(bytes32 _id) external view returns (address typeRef, enum ConditionStoreLibrary.ConditionState state, uint256 timeLock, uint256 timeOut, uint256 blockNumber)\n</code></pre> <p>getCondition</p> Name Type Description typeRef address the type reference state enum ConditionStoreLibrary.ConditionState condition state timeLock uint256 the time lock timeOut uint256 time out blockNumber uint256 block number"},{"location":"#getconditionstate","title":"getConditionState","text":"<pre><code>function getConditionState(bytes32 _id) external view virtual returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>getConditionState</p> Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#getconditiontyperef","title":"getConditionTypeRef","text":"<pre><code>function getConditionTypeRef(bytes32 _id) external view virtual returns (address)\n</code></pre> <p>getConditionTypeRef</p> Name Type Description [0] address condition typeRef"},{"location":"#getmappingvalue","title":"getMappingValue","text":"<pre><code>function getMappingValue(bytes32 _id, bytes32 _key) external view virtual returns (bytes32)\n</code></pre> <p>getConditionState</p> Name Type Description [0] bytes32 condition state"},{"location":"#isconditiontimelocked","title":"isConditionTimeLocked","text":"<pre><code>function isConditionTimeLocked(bytes32 _id) public view returns (bool)\n</code></pre> <p>isConditionTimeLocked</p> Name Type Description [0] bool whether the condition is timedLock ended"},{"location":"#isconditiontimedout","title":"isConditionTimedOut","text":"<pre><code>function isConditionTimedOut(bytes32 _id) public view returns (bool)\n</code></pre> <p>isConditionTimedOut</p> Name Type Description [0] bool whether the condition is timed out"},{"location":"#hashlockcondition","title":"HashLockCondition","text":"<p>Implementation of the Hash Lock Condition</p>"},{"location":"#condition_type_3","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#initialize_8","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"#hashvalues_3","title":"hashValues","text":"<pre><code>function hashValues(uint256 _preimage) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _preimage uint256 refers uint value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#hashvalues_4","title":"hashValues","text":"<pre><code>function hashValues(string _preimage) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _preimage string refers string value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#hashvalues_5","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _preimage) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _preimage bytes32 refers bytes32 value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_4","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, uint256 _preimage) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the condition by calling check the        the hash and the pre-image uint value</p> Name Type Description _agreementId bytes32 SEA agreement identifier _preimage uint256 Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#fulfill_5","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, string _preimage) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the condition by calling check the        the hash and the pre-image string value</p> Name Type Description _agreementId bytes32 SEA agreement identifier _preimage string Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#fulfill_6","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _preimage) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the condition by calling check the        the hash and the pre-image bytes32 value</p> Name Type Description _agreementId bytes32 SEA agreement identifier _preimage bytes32 Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#_fulfill","title":"_fulfill","text":"<pre><code>function _fulfill(bytes32 _generatedId) private returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>_fulfill calls super fulfil method</p> Name Type Description _generatedId bytes32 SEA agreement identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#icondition","title":"ICondition","text":""},{"location":"#fulfillproxy","title":"fulfillProxy","text":"<pre><code>function fulfillProxy(address _account, bytes32 _agreementId, bytes params) external payable\n</code></pre>"},{"location":"#ilockpayment","title":"ILockPayment","text":""},{"location":"#fulfilled_3","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, bytes32 _conditionId, address _rewardAddress, address _tokenAddress, address[] _receivers, uint256[] _amounts)\n</code></pre>"},{"location":"#hashvalues_6","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) external pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment.         If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_7","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address payable _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) external payable returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill requires valid token transfer in order            to lock the amount of tokens based on the SEA</p> Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#lockpaymentcondition","title":"LockPaymentCondition","text":"<p>Implementation of the Lock Payment Condition This condition allows to lock payment for multiple receivers taking into account the royalties to be paid to the original creators in a secondary market.</p>"},{"location":"#didregistry_2","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#nvmconfig","title":"nvmConfig","text":"<pre><code>contract INVMConfig nvmConfig\n</code></pre>"},{"location":"#condition_type_4","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#key_asset_receiver","title":"KEY_ASSET_RECEIVER","text":"<pre><code>bytes32 KEY_ASSET_RECEIVER\n</code></pre>"},{"location":"#proxy_role_2","title":"PROXY_ROLE","text":"<pre><code>bytes32 PROXY_ROLE\n</code></pre>"},{"location":"#allowed_external_contract_role","title":"ALLOWED_EXTERNAL_CONTRACT_ROLE","text":"<pre><code>bytes32 ALLOWED_EXTERNAL_CONTRACT_ROLE\n</code></pre>"},{"location":"#grantproxyrole_2","title":"grantProxyRole","text":"<pre><code>function grantProxyRole(address _address) public\n</code></pre>"},{"location":"#revokeproxyrole_2","title":"revokeProxyRole","text":"<pre><code>function revokeProxyRole(address _address) public\n</code></pre>"},{"location":"#grantexternalcontractrole","title":"grantExternalContractRole","text":"<pre><code>function grantExternalContractRole(address _address) public\n</code></pre>"},{"location":"#revokeexternalcontractrole","title":"revokeExternalContractRole","text":"<pre><code>function revokeExternalContractRole(address _address) public\n</code></pre>"},{"location":"#initialize_9","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _didRegistryAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address"},{"location":"#reinitialize_1","title":"reinitialize","text":"<pre><code>function reinitialize() external\n</code></pre> <p>Should be called when the contract has been upgraded.</p>"},{"location":"#hashvalues_7","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment.         If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_8","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address payable _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) external payable returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill requires valid token transfer in order            to lock the amount of tokens based on the SEA</p> Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#fulfillexternal","title":"fulfillExternal","text":"<pre><code>function fulfillExternal(bytes32 _agreementId, bytes32 _did, address payable _rewardAddress, address _externalContract, bytes32 _remoteId, uint256[] _amounts, address[] _receivers) external payable returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill lock condition using the funds locked in an external contract           (auction, bonding curve, lottery, etc)</p> Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _externalContract address the address of the contract with the lock funds are locked _remoteId bytes32 the id used to identify into the external contract _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#encodeparams","title":"encodeParams","text":"<pre><code>function encodeParams(bytes32 _did, address payable _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) external pure returns (bytes)\n</code></pre>"},{"location":"#fulfillinternal","title":"fulfillInternal","text":"<pre><code>function fulfillInternal(address _account, bytes32 _agreementId, bytes32 _did, address payable _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"#fulfillproxy_1","title":"fulfillProxy","text":"<pre><code>function fulfillProxy(address _account, bytes32 _agreementId, bytes params) external payable\n</code></pre>"},{"location":"#_transfererc20proxy","title":"_transferERC20Proxy","text":"<pre><code>function _transferERC20Proxy(address _senderAddress, address _rewardAddress, address _tokenAddress, uint256 _amount) internal\n</code></pre> <p>_transferERC20Proxy transfer ERC20 tokens</p> <p>Will throw if transfer fails</p> Name Type Description _senderAddress address the address to send the tokens from _rewardAddress address the address to receive the tokens _tokenAddress address the ERC20 contract address to use during the payment _amount uint256 token amount to be locked/released"},{"location":"#_transfereth","title":"_transferETH","text":"<pre><code>function _transferETH(address payable _rewardAddress, uint256 _amount) internal\n</code></pre> <p>_transferETH transfer ETH</p> Name Type Description _rewardAddress address payable the address to receive the ETH _amount uint256 ETH amount to be locked/released"},{"location":"#allowedexternalcontract","title":"allowedExternalContract","text":"<pre><code>modifier allowedExternalContract(address _externalContractAddress)\n</code></pre>"},{"location":"#aremarketplacefeesincluded","title":"areMarketplaceFeesIncluded","text":"<pre><code>function areMarketplaceFeesIncluded(uint256[] _amounts, address[] _receivers) internal view returns (bool)\n</code></pre>"},{"location":"#distributenftcollateralcondition","title":"DistributeNFTCollateralCondition","text":"<p>Implementation of a condition allowing to transfer a NFT      to an account or another depending on the final state of a lock condition</p>"},{"location":"#condition_type_5","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#aavecreditvault","title":"aaveCreditVault","text":"<pre><code>contract AaveCreditVault aaveCreditVault\n</code></pre>"},{"location":"#_lockconditionaddress","title":"_lockConditionAddress","text":"<pre><code>address _lockConditionAddress\n</code></pre>"},{"location":"#fulfilled_4","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, address _receiver, bytes32 _conditionId, address _contract)\n</code></pre>"},{"location":"#initialize_10","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _lockNFTConditionAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _lockNFTConditionAddress address Lock NFT Condition address"},{"location":"#hashvalues_8","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _vaultAddress, address _nftContractAddress) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _vaultAddress address The contract address of the vault _nftContractAddress address NFT contract to use Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_9","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _vaultAddress, address _nftContractAddress) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _vaultAddress address The contract address of the vault _nftContractAddress address NFT contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#inftaccess","title":"INFTAccess","text":""},{"location":"#fulfilled_5","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _documentId, address _grantee, bytes32 _conditionId)\n</code></pre>"},{"location":"#hashvalues_9","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _documentId, address _grantee, address _contractAddress) external pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_10","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _documentId, address _grantee, address _contractAddress) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill NFT Access conditions</p> <p>only DID owner or DID provider can call this       method. Fulfill method sets the permissions        for the granted consumer's address to true then       fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#inftholder","title":"INFTHolder","text":""},{"location":"#fulfilled_6","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, address _address, bytes32 _conditionId, uint256 _amount)\n</code></pre>"},{"location":"#hashvalues_10","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _holderAddress, uint256 _amount, address _contractAddress) external pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_11","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _holderAddress, uint256 _amount, address _contractAddress) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill requires a validation that holder has enough       NFTs for a specific DID</p> Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#inftlock","title":"INFTLock","text":""},{"location":"#fulfilled_7","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, address _lockAddress, bytes32 _conditionId, uint256 _amount, address _receiver, address _nftContractAddress)\n</code></pre>"},{"location":"#hashvalues_11","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _lockAddress, uint256 _amount, address _nftContractAddress) external pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the NFTs locked _nftContractAddress address Is the address of the NFT (ERC-721, ERC-1155) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#hashvaluesmarked","title":"hashValuesMarked","text":"<pre><code>function hashValuesMarked(bytes32 _did, address _lockAddress, uint256 _amount, address _receiver, address _nftContractAddress) external pure returns (bytes32)\n</code></pre>"},{"location":"#fulfill_12","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount, address _nftContractAddress) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#fulfillmarked","title":"fulfillMarked","text":"<pre><code>function fulfillMarked(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount, address _receiver, address _nftContractAddress) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"#itransfernft","title":"ITransferNFT","text":""},{"location":"#fulfilled_8","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, address _receiver, uint256 _amount, bytes32 _conditionId, address _contract)\n</code></pre>"},{"location":"#hashvalues_12","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockCondition, address _contract, bool _transfer) external pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _contract address _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_13","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _contract, bool _transfer) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#getnftdefaultaddress","title":"getNFTDefaultAddress","text":"<pre><code>function getNFTDefaultAddress() external view returns (address)\n</code></pre> <p>returns if the default NFT contract address</p> <p>The default NFT contract address was given to the Transfer Condition during the contract initialization</p> Name Type Description [0] address the NFT contract address used by default in the transfer condition"},{"location":"#nft721holdercondition","title":"NFT721HolderCondition","text":"<p>Implementation of the Nft Holder Condition</p>"},{"location":"#condition_type_6","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#initialize_11","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"#hashvalues_13","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _holderAddress, uint256 _amount, address _contractAddress) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_14","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _holderAddress, uint256 _amount, address _contractAddress) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill requires a validation that holder has enough       NFTs for a specific DID</p> Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#nft721lockcondition","title":"NFT721LockCondition","text":"<p>Implementation of the NFT Lock Condition for ERC-721 based NFTs</p>"},{"location":"#condition_type_7","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#initialize_12","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the  contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"#hashvalues_14","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _lockAddress, uint256 _amount, address _nftContractAddress) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#hashvaluesmarked_1","title":"hashValuesMarked","text":"<pre><code>function hashValuesMarked(bytes32 _did, address _lockAddress, uint256 _amount, address _receiver, address _nftContractAddress) public pure returns (bytes32)\n</code></pre>"},{"location":"#fulfillmarked_1","title":"fulfillMarked","text":"<pre><code>function fulfillMarked(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount, address _receiver, address _nftContractAddress) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method lock a NFT into the <code>_lockAddress</code>.</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens (1) _receiver address _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#fulfill_15","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount, address _nftContractAddress) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#onerc721received","title":"onERC721Received","text":"<pre><code>function onERC721Received(address, address, uint256, bytes) public virtual returns (bytes4)\n</code></pre> <p>Always returns <code>IERC721Receiver.onERC721Received.selector</code>.</p>"},{"location":"#nftaccesscondition","title":"NFTAccessCondition","text":"<p>_Implementation of the Access Condition specific for NFTs</p> <pre><code> NFT Access Condition is special condition used to give access \n to a specific NFT related to a DID._\n</code></pre>"},{"location":"#condition_type_8","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#documentpermission_1","title":"DocumentPermission","text":"<pre><code>struct DocumentPermission {\n  bytes32 agreementIdDeprecated;\n  mapping(address &amp;#x3D;&amp;gt; bool) permission;\n}\n</code></pre>"},{"location":"#nftpermissions","title":"nftPermissions","text":"<pre><code>mapping(bytes32 =&gt; struct NFTAccessCondition.DocumentPermission) nftPermissions\n</code></pre>"},{"location":"#didregistry_3","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#onlydidownerorprovider_2","title":"onlyDIDOwnerOrProvider","text":"<pre><code>modifier onlyDIDOwnerOrProvider(bytes32 _documentId)\n</code></pre>"},{"location":"#initialize_13","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _didRegistryAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID registry address"},{"location":"#hashvalues_15","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _documentId, address _grantee) public view returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#hashvalues_16","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _documentId, address _grantee, address _contractAddress) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_16","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _documentId, address _grantee) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill NFT Access condition</p> <p>only DID owner or DID provider can call this       method. Fulfill method sets the permissions        for the granted consumer's address to true then       fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#fulfill_17","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _documentId, address _grantee, address _contractAddress) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill NFT Access condition</p> <p>only DID owner or DID provider can call this       method. Fulfill method sets the permissions        for the granted consumer's address to true then       fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address is the contract address of the NFT implementation (ERC-1155 or ERC-721) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#grantpermission_1","title":"grantPermission","text":"<pre><code>function grantPermission(address _grantee, bytes32 _documentId) public\n</code></pre> <p>grantPermission is called only by DID owner or provider</p> Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys"},{"location":"#checkpermissions_1","title":"checkPermissions","text":"<pre><code>function checkPermissions(address _grantee, bytes32 _documentId) external view returns (bool permissionGranted)\n</code></pre> <p>checkPermissions is called to validate the permissions of user related to the NFT attached to an asset</p> Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID Name Type Description permissionGranted bool true if the access was granted"},{"location":"#nftholdercondition","title":"NFTHolderCondition","text":"<p>Implementation of the Nft Holder Condition</p>"},{"location":"#erc1155","title":"erc1155","text":"<pre><code>contract ERC1155BurnableUpgradeable erc1155\n</code></pre>"},{"location":"#condition_type_9","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#initialize_14","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _ercAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _ercAddress address Nevermined ERC-1155 address"},{"location":"#hashvalues_17","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _holderAddress, uint256 _amount) public view returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#hashvalues_18","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _holderAddress, uint256 _amount, address _contractAddress) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_18","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _holderAddress, uint256 _amount) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill requires a validation that holder has enough       NFTs for a specific DID</p> Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#fulfill_19","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _holderAddress, uint256 _amount, address _contractAddress) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill requires a validation that holder has enough       NFTs for a specific DID</p> Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#nftlockcondition","title":"NFTLockCondition","text":"<p>Implementation of the NFT Lock Condition</p>"},{"location":"#erc1155_1","title":"erc1155","text":"<pre><code>contract IERC1155Upgradeable erc1155\n</code></pre>"},{"location":"#condition_type_10","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#erc1155_accepted","title":"ERC1155_ACCEPTED","text":"<pre><code>bytes4 ERC1155_ACCEPTED\n</code></pre>"},{"location":"#erc1155_batch_accepted","title":"ERC1155_BATCH_ACCEPTED","text":"<pre><code>bytes4 ERC1155_BATCH_ACCEPTED\n</code></pre>"},{"location":"#initialize_15","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _ercAddress) external\n</code></pre> <p>initialize init the  contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _ercAddress address Nevermined ERC-1155 address"},{"location":"#hashvalues_19","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _lockAddress, uint256 _amount) public view returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#hashvalues_20","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _lockAddress, uint256 _amount, address _nftContractAddress) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-1155) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#hashvaluesmarked_2","title":"hashValuesMarked","text":"<pre><code>function hashValuesMarked(bytes32 _did, address _lockAddress, uint256 _amount, address _receiver, address _nftContractAddress) public pure returns (bytes32)\n</code></pre>"},{"location":"#fulfill_20","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#fulfill_21","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount, address _nft) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"#fulfillmarked_2","title":"fulfillMarked","text":"<pre><code>function fulfillMarked(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount, address _receiver, address _nftContractAddress) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _receiver address _nftContractAddress address Is the address of the NFT (ERC-1155) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#onerc1155received","title":"onERC1155Received","text":"<pre><code>function onERC1155Received(address, address, uint256, uint256, bytes) external pure returns (bytes4)\n</code></pre>"},{"location":"#onerc1155batchreceived","title":"onERC1155BatchReceived","text":"<pre><code>function onERC1155BatchReceived(address, address, uint256[], uint256[], bytes) external pure returns (bytes4)\n</code></pre>"},{"location":"#supportsinterface","title":"supportsInterface","text":"<pre><code>function supportsInterface(bytes4 interfaceId) external pure returns (bool)\n</code></pre> <p>_Returns true if this contract implements the interface defined by <code>interfaceId</code>. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created.</p> <p>This function call must use less than 30 000 gas._</p>"},{"location":"#transfernft721condition","title":"TransferNFT721Condition","text":"<p>Implementation of condition allowing to transfer an NFT      between the original owner and a receiver</p>"},{"location":"#condition_type_11","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#market_role","title":"MARKET_ROLE","text":"<pre><code>bytes32 MARKET_ROLE\n</code></pre>"},{"location":"#erc721","title":"erc721","text":"<pre><code>contract NFT721Upgradeable erc721\n</code></pre>"},{"location":"#_lockconditionaddress_1","title":"_lockConditionAddress","text":"<pre><code>address _lockConditionAddress\n</code></pre>"},{"location":"#proxy_role_3","title":"PROXY_ROLE","text":"<pre><code>bytes32 PROXY_ROLE\n</code></pre>"},{"location":"#didregistry_4","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#grantproxyrole_3","title":"grantProxyRole","text":"<pre><code>function grantProxyRole(address _address) public\n</code></pre>"},{"location":"#revokeproxyrole_3","title":"revokeProxyRole","text":"<pre><code>function revokeProxyRole(address _address) public\n</code></pre>"},{"location":"#initialize_16","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _didRegistryAddress, address _ercAddress, address _lockNFTConditionAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _ercAddress address Nevermined ERC-721 address _lockNFTConditionAddress address"},{"location":"#getnftdefaultaddress_1","title":"getNFTDefaultAddress","text":"<pre><code>function getNFTDefaultAddress() external view returns (address)\n</code></pre> <p>returns if the default NFT contract address</p> <p>The default NFT contract address was given to the Transfer Condition during the contract initialization</p> Name Type Description [0] address the NFT contract address used by default in the transfer condition"},{"location":"#hashvalues_21","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockCondition, address _contract, bool _transfer) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _contract address NFT contract to use _transfer bool Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#encodeparams_1","title":"encodeParams","text":"<pre><code>function encodeParams(bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _nftContractAddress, bool _transfer) external pure returns (bytes)\n</code></pre> <p>Encodes/serialize all the parameters received</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the NFT contract to use _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] bytes the encoded parameters"},{"location":"#fulfill_22","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _contract, bool _transfer) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#fulfillproxy_2","title":"fulfillProxy","text":"<pre><code>function fulfillProxy(address _account, bytes32 _agreementId, bytes _params) external payable\n</code></pre> <p>fulfill the transfer NFT condition by a proxy</p> <p>Fulfill method transfer a certain amount of NFTs</p> Name Type Description _account address NFT Holder _agreementId bytes32 agreement identifier _params bytes encoded parameters"},{"location":"#fulfillinternal_1","title":"fulfillInternal","text":"<pre><code>function fulfillInternal(address _account, bytes32 _agreementId, bytes32 _did, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _contract, bool _transfer) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"#fulfillfordelegate","title":"fulfillForDelegate","text":"<pre><code>function fulfillForDelegate(bytes32 _agreementId, bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, bool _transfer) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address in the DIDRegistry contract.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#transfernftcondition","title":"TransferNFTCondition","text":"<p>Implementation of condition allowing to transfer an NFT      between the original owner and a receiver</p>"},{"location":"#condition_type_12","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#market_role_1","title":"MARKET_ROLE","text":"<pre><code>bytes32 MARKET_ROLE\n</code></pre>"},{"location":"#erc1155_2","title":"erc1155","text":"<pre><code>contract NFTUpgradeable erc1155\n</code></pre>"},{"location":"#didregistry_5","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#proxy_role_4","title":"PROXY_ROLE","text":"<pre><code>bytes32 PROXY_ROLE\n</code></pre>"},{"location":"#grantproxyrole_4","title":"grantProxyRole","text":"<pre><code>function grantProxyRole(address _address) public\n</code></pre>"},{"location":"#revokeproxyrole_4","title":"revokeProxyRole","text":"<pre><code>function revokeProxyRole(address _address) public\n</code></pre>"},{"location":"#initialize_17","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _didRegistryAddress, address _ercAddress, address _nftContractAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _ercAddress address Nevermined ERC-1155 address _nftContractAddress address Market address"},{"location":"#grantmarketrole","title":"grantMarketRole","text":"<pre><code>function grantMarketRole(address _nftContractAddress) public\n</code></pre>"},{"location":"#revokemarketrole","title":"revokeMarketRole","text":"<pre><code>function revokeMarketRole(address _nftContractAddress) public\n</code></pre>"},{"location":"#getnftdefaultaddress_2","title":"getNFTDefaultAddress","text":"<pre><code>function getNFTDefaultAddress() external view returns (address)\n</code></pre> <p>returns if the default NFT contract address</p> <p>The default NFT contract address was given to the Transfer Condition during the contract initialization</p> Name Type Description [0] address the NFT contract address used by default in the transfer condition"},{"location":"#hashvalues_22","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockCondition) public view returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#hashvalues_23","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockCondition, address _nftContractAddress, bool _transfer) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _nftContractAddress address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_23","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"#encodeparams_2","title":"encodeParams","text":"<pre><code>function encodeParams(bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _nftContractAddress, bool _transfer) external pure returns (bytes)\n</code></pre> <p>Encodes/serialize all the parameters received</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the NFT contract to use _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] bytes the encoded parameters"},{"location":"#fulfillproxy_3","title":"fulfillProxy","text":"<pre><code>function fulfillProxy(address _account, bytes32 _agreementId, bytes _params) external payable\n</code></pre> <p>fulfill the transfer NFT condition by a proxy</p> <p>Fulfill method transfer a certain amount of NFTs</p> Name Type Description _account address NFT Holder _agreementId bytes32 agreement identifier _params bytes encoded parameters"},{"location":"#fulfill_24","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _nftContractAddress, bool _transfer) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#fulfillinternal_2","title":"fulfillInternal","text":"<pre><code>function fulfillInternal(address _account, bytes32 _agreementId, bytes32 _did, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _nftContractAddress, bool _transfer) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"#fulfillfordelegate_1","title":"fulfillForDelegate","text":"<pre><code>function fulfillForDelegate(bytes32 _agreementId, bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, bool _transfer) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address in the DIDRegistry contract.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#signcondition","title":"SignCondition","text":"<p>Implementation of the Sign Condition</p>"},{"location":"#condition_type_13","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#initialize_18","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"#hashvalues_24","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _message, address _publicKey) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _message bytes32 the message to be signed _publicKey address the public key of the signing address Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_25","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _message, address _publicKey, bytes _signature) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill validate the signed message and fulfill the condition</p> Name Type Description _agreementId bytes32 SEA agreement identifier _message bytes32 the message to be signed _publicKey address the public key of the signing address _signature bytes signature of the signed message using the public key Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#thresholdcondition","title":"ThresholdCondition","text":"<p>_Implementation of the Threshold Condition</p> <pre><code> Threshold condition acts as a filter for a set of input condition(s) in which sends \n a signal whether to complete the flow execution or abort it. This type of conditions \n works as intermediary conditions where they wire SEA conditions in order to support  \n more complex scenarios._\n</code></pre>"},{"location":"#condition_type_14","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#initialize_19","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"#hashvalues_25","title":"hashValues","text":"<pre><code>function hashValues(bytes32[] inputConditions, uint256 threshold) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_26","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32[] _inputConditions, uint256 threshold) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill threshold condition</p> <p>the fulfill method check whether input conditions are       fulfilled or not.</p> Name Type Description _agreementId bytes32 agreement identifier _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#canfulfill","title":"canFulfill","text":"<pre><code>function canFulfill(bytes32[] _inputConditions, uint256 threshold) private view returns (bool _fulfill)\n</code></pre> <p>canFulfill check if condition can be fulfilled</p> Name Type Description _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description _fulfill bool true if can fulfill"},{"location":"#transferdidownershipcondition","title":"TransferDIDOwnershipCondition","text":"<p>Implementation of condition allowing to transfer the ownership      between the original owner and a receiver</p>"},{"location":"#condition_type_15","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#didregistry_6","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#fulfilled_9","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, address _receiver, bytes32 _conditionId)\n</code></pre>"},{"location":"#initialize_20","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _didRegistryAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address"},{"location":"#hashvalues_26","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _receiver) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_27","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _receiver) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer DID ownership condition</p> <p>only DID owner or DID provider can call this       method. Fulfill method transfer full ownership permissions        to to _receiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#whitelistingcondition","title":"WhitelistingCondition","text":"<p>Implementation of the Whitelisting Condition</p>"},{"location":"#condition_type_16","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#initialize_21","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"#hashvalues_27","title":"hashValues","text":"<pre><code>function hashValues(address _listAddress, bytes32 _item) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _listAddress address list contract address _item bytes32 item in the list Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_28","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, address _listAddress, bytes32 _item) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill check whether address is whitelisted in order to fulfill the condition. This method will be  called by any one in this whitelist.</p> Name Type Description _agreementId bytes32 SEA agreement identifier _listAddress address list contract address _item bytes32 item in the list Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#aaveborrowcondition","title":"AaveBorrowCondition","text":"<p>Implementation of the Aave Borrow Credit Condition</p>"},{"location":"#aavecreditvault_1","title":"aaveCreditVault","text":"<pre><code>contract AaveCreditVault aaveCreditVault\n</code></pre>"},{"location":"#condition_type_17","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#fulfilled_10","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, bytes32 _conditionId)\n</code></pre>"},{"location":"#initialize_22","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"#hashvalues_28","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _vaultAddress, address _assetToBorrow, uint256 _amount, uint256 _interestRateMode) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToBorrow address the address of the asset to borrow (i.e DAI) _amount uint256 the amount of the ERC-20 the assets to borrow (i.e 50 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_29","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _vaultAddress, address _assetToBorrow, uint256 _amount, uint256 _interestRateMode) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>It allows the borrower to borrow the asset deposited by the lender</p> Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToBorrow address the address of the asset to borrow (i.e DAI) _amount uint256 the amount of the ERC-20 the assets to borrow (i.e 50 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)"},{"location":"#aavecollateraldepositcondition","title":"AaveCollateralDepositCondition","text":"<p>Implementation of the Aave Collateral Deposit Condition This condition allows a Lender to deposit the collateral that  into account the royalties to be paid to the original creators in a secondary market.</p>"},{"location":"#aavecreditvault_2","title":"aaveCreditVault","text":"<pre><code>contract AaveCreditVault aaveCreditVault\n</code></pre>"},{"location":"#condition_type_18","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#fulfilled_11","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, bytes32 _conditionId)\n</code></pre>"},{"location":"#initialize_23","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"#hashvalues_29","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _vaultAddress, address _collateralAsset, uint256 _collateralAmount, address _delegatedAsset, uint256 _delegatedAmount, uint256 _interestRateMode) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the ERC-20 that will be used as collateral (i.e WETH) _collateralAmount uint256 the amount of the ERC-20 that will be used as collateral (i.e 10 WETH) _delegatedAsset address the address of the ERC-20 that will be delegated to the borrower (i.e DAI) _delegatedAmount uint256 the amount of the ERC-20 that will be delegated to the borrower (i.e 500 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_30","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _vaultAddress, address _collateralAsset, uint256 _collateralAmount, address _delegatedAsset, uint256 _delegatedAmount, uint256 _interestRateMode) external payable returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>It fulfills the condition if the collateral can be deposited into the vault</p> Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the ERC-20 that will be used as collateral (i.e WETH) _collateralAmount uint256 the amount of the ERC-20 that will be used as collateral (i.e 10 WETH) _delegatedAsset address the address of the ERC-20 that will be delegated to the borrower (i.e DAI) _delegatedAmount uint256 the amount of the ERC-20 that will be delegated to the borrower (i.e 500 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)"},{"location":"#aavecollateralwithdrawcondition","title":"AaveCollateralWithdrawCondition","text":"<p>Implementation of the Collateral Withdraw Condition This condition allows to credit delegator withdraw the collateral and fees after the agreement expiration</p>"},{"location":"#aavecreditvault_3","title":"aaveCreditVault","text":"<pre><code>contract AaveCreditVault aaveCreditVault\n</code></pre>"},{"location":"#condition_type_19","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#fulfilled_12","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, bytes32 _conditionId)\n</code></pre>"},{"location":"#initialize_24","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"#hashvalues_30","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _vaultAddress, address _collateralAsset) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the asset used as collateral (i.e DAI) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_31","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _vaultAddress, address _collateralAsset) external payable returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>It allows the borrower to repay the loan</p> Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the asset used as collateral (i.e DAI) Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)"},{"location":"#aavecreditvault_4","title":"AaveCreditVault","text":""},{"location":"#lendingpool","title":"lendingPool","text":"<pre><code>contract ILendingPool lendingPool\n</code></pre>"},{"location":"#dataprovider","title":"dataProvider","text":"<pre><code>contract IProtocolDataProvider dataProvider\n</code></pre>"},{"location":"#weth","title":"weth","text":"<pre><code>contract IWETHGateway weth\n</code></pre>"},{"location":"#addressprovider","title":"addressProvider","text":"<pre><code>contract ILendingPoolAddressesProvider addressProvider\n</code></pre>"},{"location":"#priceoracle","title":"priceOracle","text":"<pre><code>contract IPriceOracleGetter priceOracle\n</code></pre>"},{"location":"#borrowedasset","title":"borrowedAsset","text":"<pre><code>address borrowedAsset\n</code></pre>"},{"location":"#borrowedamount","title":"borrowedAmount","text":"<pre><code>uint256 borrowedAmount\n</code></pre>"},{"location":"#nvmfee","title":"nvmFee","text":"<pre><code>uint256 nvmFee\n</code></pre>"},{"location":"#agreementfee","title":"agreementFee","text":"<pre><code>uint256 agreementFee\n</code></pre>"},{"location":"#fee_base","title":"FEE_BASE","text":"<pre><code>uint256 FEE_BASE\n</code></pre>"},{"location":"#treasuryaddress","title":"treasuryAddress","text":"<pre><code>address treasuryAddress\n</code></pre>"},{"location":"#borrower","title":"borrower","text":"<pre><code>address borrower\n</code></pre>"},{"location":"#lender","title":"lender","text":"<pre><code>address lender\n</code></pre>"},{"location":"#repayconditionid","title":"repayConditionId","text":"<pre><code>bytes32 repayConditionId\n</code></pre>"},{"location":"#nftid","title":"nftId","text":"<pre><code>uint256 nftId\n</code></pre>"},{"location":"#nftaddress","title":"nftAddress","text":"<pre><code>address nftAddress\n</code></pre>"},{"location":"#borrower_role","title":"BORROWER_ROLE","text":"<pre><code>bytes32 BORROWER_ROLE\n</code></pre>"},{"location":"#lender_role","title":"LENDER_ROLE","text":"<pre><code>bytes32 LENDER_ROLE\n</code></pre>"},{"location":"#condition_role","title":"CONDITION_ROLE","text":"<pre><code>bytes32 CONDITION_ROLE\n</code></pre>"},{"location":"#initialize_25","title":"initialize","text":"<pre><code>function initialize(address _lendingPool, address _dataProvider, address _weth, uint256 _nvmFee, uint256 _agreementFee, address _treasuryAddress, address _borrower, address _lender, address[] _conditions) public\n</code></pre> <p>Vault constructor, creates a unique vault for each agreement</p> Name Type Description _lendingPool address Aave lending pool address _dataProvider address Aave data provider address _weth address WETH address _nvmFee uint256 Nevermined fee that will apply to this agreeement _agreementFee uint256 Agreement fee that lender will receive on agreement maturity _treasuryAddress address Address of nevermined contract to store fees _borrower address _lender address _conditions address[]"},{"location":"#islender","title":"isLender","text":"<pre><code>function isLender(address _address) public view returns (bool)\n</code></pre>"},{"location":"#isborrower","title":"isBorrower","text":"<pre><code>function isBorrower(address _address) public view returns (bool)\n</code></pre>"},{"location":"#deposit","title":"deposit","text":"<pre><code>function deposit(address _collateralAsset, uint256 _amount) public payable\n</code></pre> <p>Deposit function. Receives the funds from the delegator and deposits the funds in the Aave contracts</p> Name Type Description _collateralAsset address collateral asset that will be deposit on Aave _amount uint256 Amount of collateral to deposit"},{"location":"#approveborrower","title":"approveBorrower","text":"<pre><code>function approveBorrower(address _borrower, uint256 _amount, address _asset, uint256 _interestRateMode) public\n</code></pre> <p>Appproves delegatee to borrow funds from Aave on behalf of delegator</p> Name Type Description _borrower address delegatee that will borrow the funds _amount uint256 Amount of funds to delegate _asset address Asset to delegate the borrow _interestRateMode uint256 interest rate type stable 1, variable 2"},{"location":"#delegatedamount","title":"delegatedAmount","text":"<pre><code>function delegatedAmount(address _borrower, address _asset, uint256 _interestRateMode) public view returns (uint256)\n</code></pre> <p>Return the actual delegated amount for the borrower in the specific asset</p> Name Type Description _borrower address The borrower of the funds (i.e. delgatee) _asset address The asset they are allowed to borrow _interestRateMode uint256 interest rate type stable 1, variable 2"},{"location":"#borrow","title":"borrow","text":"<pre><code>function borrow(address _assetToBorrow, uint256 _amount, address _delgatee, uint256 _interestRateMode) public\n</code></pre> <p>Borrower can call this function to borrow the delegated funds</p> Name Type Description _assetToBorrow address The asset they are allowed to borrow _amount uint256 Amount to borrow _delgatee address Address where the funds will be transfered _interestRateMode uint256 interest rate type stable 1, variable 2"},{"location":"#repay","title":"repay","text":"<pre><code>function repay(address _asset, uint256 _interestRateMode, bytes32 _repayConditionId) public\n</code></pre> <p>Repay an uncollaterised loan</p> Name Type Description _asset address The asset to be repaid _interestRateMode uint256 interest rate type stable 1, variable 2 _repayConditionId bytes32 identifier of the condition id working as lock for other vault methods"},{"location":"#setrepayconditionid","title":"setRepayConditionId","text":"<pre><code>function setRepayConditionId(bytes32 _repayConditionId) public\n</code></pre>"},{"location":"#getborrowedamount","title":"getBorrowedAmount","text":"<pre><code>function getBorrowedAmount() public view returns (uint256)\n</code></pre> <p>Returns the borrowed amount from the delegatee on this agreement</p>"},{"location":"#getassetprice","title":"getAssetPrice","text":"<pre><code>function getAssetPrice(address _asset) public view returns (uint256)\n</code></pre> <p>Returns the priceof the asset in the Aave oracles</p> Name Type Description _asset address The asset to get the actual price"},{"location":"#getcreditassetdebt","title":"getCreditAssetDebt","text":"<pre><code>function getCreditAssetDebt() public view returns (uint256)\n</code></pre> <p>Returns the total debt of the credit in the Aave protocol expressed in token units</p>"},{"location":"#getactualcreditdebt","title":"getActualCreditDebt","text":"<pre><code>function getActualCreditDebt() public view returns (uint256)\n</code></pre> <p>Returns the total debt of the credit in the Aave protocol expressed in ETH units</p>"},{"location":"#gettotalactualdebt","title":"getTotalActualDebt","text":"<pre><code>function getTotalActualDebt() public view returns (uint256)\n</code></pre> <p>Returns the total actual debt of the agreement credit + fees in token units</p>"},{"location":"#withdrawcollateral","title":"withdrawCollateral","text":"<pre><code>function withdrawCollateral(address _asset, address _delegator) public\n</code></pre> <p>Withdraw all of a collateral as the underlying asset, if no outstanding loans delegated</p> Name Type Description _asset address The underlying asset to withdraw _delegator address Delegator address that deposited the collateral"},{"location":"#transfernft","title":"transferNFT","text":"<pre><code>function transferNFT(uint256 _tokenId, address _receiver) public\n</code></pre> <p>Transfer a NFT (ERC-721) locked into the vault to a receiver address</p> Name Type Description _tokenId uint256 the token id _receiver address the receiver adddress"},{"location":"#_transfererc20","title":"_transferERC20","text":"<pre><code>function _transferERC20(address _collateralAsset, uint256 _amount) internal\n</code></pre> <p>Transfers the ERC20 token deposited to the Aave contracts</p> Name Type Description _collateralAsset address collateral asset that will be deposit on Aave _amount uint256 Amount of collateral to deposit"},{"location":"#onerc721received_1","title":"onERC721Received","text":"<pre><code>function onERC721Received(address, address, uint256 _tokenId, bytes) public virtual returns (bytes4)\n</code></pre> <p>Handle the receipt of an NFT</p> <p>_The ERC721 smart contract calls this function on the recipient after a {IERC721-safeTransferFrom}. This function MUST return the function selector, otherwise the caller will revert the transaction. </p> <p>Note: the ERC721 contract address is always the message sender. (param not used): operator The address which called <code>safeTransferFrom</code> function (param not used): from The address which previously owned the token_</p> Name Type Description address address _tokenId uint256 The NFT identifier which is being transferred (param not used): data Additional data with no specified format bytes Name Type Description [0] bytes4 bytes4 <code>bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))</code>"},{"location":"#aaverepaycondition","title":"AaveRepayCondition","text":"<p>Implementation of the Aave Repay Condition This condition allows to a borrower to repay a credit as part of a credit template</p>"},{"location":"#aavecreditvault_5","title":"aaveCreditVault","text":"<pre><code>contract AaveCreditVault aaveCreditVault\n</code></pre>"},{"location":"#condition_type_20","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#fulfilled_13","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, bytes32 _conditionId)\n</code></pre>"},{"location":"#initialize_26","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"#hashvalues_31","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _vaultAddress, address _assetToRepay, uint256 _amountToRepay, uint256 _interestRateMode) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToRepay address the address of the asset to repay (i.e DAI) _amountToRepay uint256 Amount to repay _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_32","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _vaultAddress, address _assetToRepay, uint256 _amountToRepay, uint256 _interestRateMode) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>It allows the borrower to repay the loan</p> Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToRepay address the address of the asset to repay (i.e DAI) _amountToRepay uint256 Amount to repay _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)"},{"location":"#escrowpaymentcondition","title":"EscrowPaymentCondition","text":"<p>_Implementation of the Escrow Payment Condition</p> <pre><code> The Escrow payment is reward condition in which only \n can release reward if lock and release conditions\n are fulfilled._\n</code></pre>"},{"location":"#condition_type_21","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#used_payment_id","title":"USED_PAYMENT_ID","text":"<pre><code>bytes32 USED_PAYMENT_ID\n</code></pre>"},{"location":"#fulfilled_14","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, address _tokenAddress, address[] _receivers, bytes32 _conditionId, uint256[] _amounts)\n</code></pre>"},{"location":"#received","title":"Received","text":"<pre><code>event Received(address _from, uint256 _value)\n</code></pre>"},{"location":"#receive","title":"receive","text":"<pre><code>receive() external payable\n</code></pre>"},{"location":"#initialize_27","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"#hashvaluesmulti","title":"hashValuesMulti","text":"<pre><code>function hashValuesMulti(bytes32 _did, uint256[] _amounts, address[] _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#encodeparams_3","title":"encodeParams","text":"<pre><code>function encodeParams(bytes32 _did, uint256[] _amounts, address[] _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) public pure returns (bytes)\n</code></pre>"},{"location":"#hashvalues_32","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, uint256[] _amounts, address[] _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32 _releaseCondition) public pure returns (bytes32)\n</code></pre>"},{"location":"#hashvalueslockpayment","title":"hashValuesLockPayment","text":"<pre><code>function hashValuesLockPayment(bytes32 _did, address _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) public pure returns (bytes32)\n</code></pre> <p>hashValuesLockPayment generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment.         If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfillmulti","title":"fulfillMulti","text":"<pre><code>function fulfillMulti(bytes32 _agreementId, bytes32 _did, uint256[] _amounts, address[] _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill escrow reward condition</p> <p>fulfill method checks whether the lock and       release conditions are fulfilled in order to       release/refund the reward to receiver/sender       respectively.</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#args","title":"Args","text":"<pre><code>struct Args {\n  bytes32 _agreementId;\n  bytes32 _did;\n  uint256[] _amounts;\n  address[] _receivers;\n  address _returnAddress;\n  address _lockPaymentAddress;\n  address _tokenAddress;\n  bytes32 _lockCondition;\n  bytes32[] _releaseConditions;\n}\n</code></pre>"},{"location":"#fulfillkludge","title":"fulfillKludge","text":"<pre><code>function fulfillKludge(struct EscrowPaymentCondition.Args a) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"#fulfill_33","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, uint256[] _amounts, address[] _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32 _releaseCondition) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"#_transferandfulfillerc20","title":"_transferAndFulfillERC20","text":"<pre><code>function _transferAndFulfillERC20(bytes32 _id, address _tokenAddress, address[] _receivers, uint256[] _amounts) private returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>_transferAndFulfill transfer ERC20 tokens and        fulfill the condition</p> Name Type Description _id bytes32 condition identifier _tokenAddress address the ERC20 contract address to use during the payment _receivers address[] receiver's address _amounts uint256[] token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#_transferandfulfilleth","title":"_transferAndFulfillETH","text":"<pre><code>function _transferAndFulfillETH(bytes32 _id, address[] _receivers, uint256[] _amounts) private returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>_transferAndFulfill transfer ETH and        fulfill the condition</p> Name Type Description _id bytes32 condition identifier _receivers address[] receiver's address _amounts uint256[] token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#inftescrow","title":"INFTEscrow","text":"<p>Common interface for ERC-721 and ERC-1155</p>"},{"location":"#fulfilled_15","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, address _tokenAddress, bytes32 _did, address _receivers, bytes32 _conditionId, uint256 _amounts)\n</code></pre>"},{"location":"#nft721escrowpaymentcondition","title":"NFT721EscrowPaymentCondition","text":"<p>_Implementation of the Escrow Payment Condition</p> <pre><code> The Escrow payment is reward condition in which only \n can release reward if lock and release conditions\n are fulfilled._\n</code></pre>"},{"location":"#condition_type_22","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#received_1","title":"Received","text":"<pre><code>event Received(address _from, uint256 _value)\n</code></pre>"},{"location":"#receive_1","title":"receive","text":"<pre><code>receive() external payable\n</code></pre>"},{"location":"#initialize_28","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"#hashvalues_33","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, uint256 _amounts, address _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 asset decentralized identifier _amounts uint256 token amounts to be locked/released _receivers address receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#hashvalueslockpayment_1","title":"hashValuesLockPayment","text":"<pre><code>function hashValuesLockPayment(bytes32 _did, address _lockAddress, address _nftContractAddress, uint256 _amount, address _receiver) public pure returns (bytes32)\n</code></pre> <p>hashValuesLockPayment generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the asset decentralized identifier _lockAddress address the contract address where the reward is locked _nftContractAddress address the ERC20 contract address to use during the lock payment.         If the address is 0x0 means we won't use a ERC20 but ETH for payment _amount uint256 token amounts to be locked/released _receiver address receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_34","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, uint256 _amount, address _receiver, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill escrow reward condition</p> <p>fulfill method checks whether the lock and       release conditions are fulfilled in order to       release/refund the reward to receiver/sender       respectively.</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amount uint256 token amounts to be locked/released _receiver address receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#args_1","title":"Args","text":"<pre><code>struct Args {\n  bytes32 _agreementId;\n  bytes32 _did;\n  uint256 _amount;\n  address _receiver;\n  address _returnAddress;\n  address _lockPaymentAddress;\n  address _tokenAddress;\n  bytes32 _lockCondition;\n  bytes32[] _releaseConditions;\n}\n</code></pre>"},{"location":"#fulfillkludge_1","title":"fulfillKludge","text":"<pre><code>function fulfillKludge(struct NFT721EscrowPaymentCondition.Args a) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"#_transferandfulfillnft","title":"_transferAndFulfillNFT","text":"<pre><code>function _transferAndFulfillNFT(bytes32 _agreementId, bytes32 _id, bytes32 _did, address _tokenAddress, address _receiver, uint256 _amount) private returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>_transferAndFulfill transfer ERC20 tokens and        fulfill the condition</p> Name Type Description _agreementId bytes32 _id bytes32 condition identifier _did bytes32 _tokenAddress address the ERC20 contract address to use during the payment _receiver address receiver's address _amount uint256 token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#onerc721received_2","title":"onERC721Received","text":"<pre><code>function onERC721Received(address, address, uint256, bytes) public virtual returns (bytes4)\n</code></pre>"},{"location":"#nftescrowpaymentcondition","title":"NFTEscrowPaymentCondition","text":"<p>_Implementation of the Escrow Payment Condition</p> <pre><code> The Escrow payment is reward condition in which only \n can release reward if lock and release conditions\n are fulfilled._\n</code></pre>"},{"location":"#condition_type_23","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"#lock_condition_type","title":"LOCK_CONDITION_TYPE","text":"<pre><code>bytes32 LOCK_CONDITION_TYPE\n</code></pre>"},{"location":"#received_2","title":"Received","text":"<pre><code>event Received(address _from, uint256 _value)\n</code></pre>"},{"location":"#receive_2","title":"receive","text":"<pre><code>receive() external payable\n</code></pre>"},{"location":"#initialize_29","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"#hashvalues_34","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, uint256 _amounts, address _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 asset decentralized identifier _amounts uint256 token amounts to be locked/released _receivers address receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#hashvalueslockpayment_2","title":"hashValuesLockPayment","text":"<pre><code>function hashValuesLockPayment(bytes32 _did, address _lockAddress, address _nftContractAddress, uint256 _amount, address _receiver) public pure returns (bytes32)\n</code></pre> <p>hashValuesLockPayment generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the asset decentralized identifier _lockAddress address the contract address where the reward is locked _nftContractAddress address the ERC20 contract address to use during the lock payment.         If the address is 0x0 means we won't use a ERC20 but ETH for payment _amount uint256 token amounts to be locked/released _receiver address receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"#fulfill_35","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, uint256 _amount, address _receiver, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill escrow reward condition</p> <p>fulfill method checks whether the lock and       release conditions are fulfilled in order to       release/refund the reward to receiver/sender       respectively.</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amount uint256 token amounts to be locked/released _receiver address receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#args_2","title":"Args","text":"<pre><code>struct Args {\n  bytes32 _agreementId;\n  bytes32 _did;\n  uint256 _amount;\n  address _receiver;\n  address _returnAddress;\n  address _lockPaymentAddress;\n  address _tokenAddress;\n  bytes32 _lockCondition;\n  bytes32[] _releaseConditions;\n}\n</code></pre>"},{"location":"#fulfillkludge_2","title":"fulfillKludge","text":"<pre><code>function fulfillKludge(struct NFTEscrowPaymentCondition.Args a) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"#_transferandfulfillnft_1","title":"_transferAndFulfillNFT","text":"<pre><code>function _transferAndFulfillNFT(bytes32 _agreementId, bytes32 _id, bytes32 _did, address _tokenAddress, address _receiver, uint256 _amount) private returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>_transferAndFulfill transfer ERC20 tokens and        fulfill the condition</p> Name Type Description _agreementId bytes32 _id bytes32 condition identifier _did bytes32 _tokenAddress address the ERC20 contract address to use during the payment _receiver address receiver's address _amount uint256 token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"#erc1155_accepted_1","title":"ERC1155_ACCEPTED","text":"<pre><code>bytes4 ERC1155_ACCEPTED\n</code></pre>"},{"location":"#erc1155_batch_accepted_1","title":"ERC1155_BATCH_ACCEPTED","text":"<pre><code>bytes4 ERC1155_BATCH_ACCEPTED\n</code></pre>"},{"location":"#onerc1155received_1","title":"onERC1155Received","text":"<pre><code>function onERC1155Received(address, address, uint256, uint256, bytes) external pure returns (bytes4)\n</code></pre>"},{"location":"#onerc1155batchreceived_1","title":"onERC1155BatchReceived","text":"<pre><code>function onERC1155BatchReceived(address, address, uint256[], uint256[], bytes) external pure returns (bytes4)\n</code></pre>"},{"location":"#supportsinterface_1","title":"supportsInterface","text":"<pre><code>function supportsInterface(bytes4 interfaceId) external pure returns (bool)\n</code></pre> <p>_Returns true if this contract implements the interface defined by <code>interfaceId</code>. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created.</p> <p>This function call must use less than 30 000 gas._</p>"},{"location":"#reward","title":"Reward","text":"<p>_Implementation of the Reward.</p> <pre><code> Generic reward condition_\n</code></pre>"},{"location":"#invmconfig","title":"INVMConfig","text":""},{"location":"#governor_role","title":"GOVERNOR_ROLE","text":"<pre><code>bytes32 GOVERNOR_ROLE\n</code></pre>"},{"location":"#neverminedconfigchange","title":"NeverminedConfigChange","text":"<pre><code>event NeverminedConfigChange(address _whoChanged, bytes32 _parameter)\n</code></pre> <p>Event that is emitted when a parameter is changed</p> Name Type Description _whoChanged address the address of the governor changing the parameter _parameter bytes32 the hash of the name of the parameter changed"},{"location":"#initialize_30","title":"initialize","text":"<pre><code>function initialize(address _owner, address _governor) external virtual\n</code></pre> <p>Used to initialize the contract during delegator constructor</p> Name Type Description _owner address The owner of the contract _governor address The address to be granted with the <code>GOVERNOR_ROLE</code>"},{"location":"#setmarketplacefees","title":"setMarketplaceFees","text":"<pre><code>function setMarketplaceFees(uint256 _marketplaceFee, address _feeReceiver) external virtual\n</code></pre> <p>The governor can update the Nevermined Marketplace fees</p> Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee"},{"location":"#isgovernor","title":"isGovernor","text":"<pre><code>function isGovernor(address _address) external view virtual returns (bool)\n</code></pre> <p>Indicates if an address is a having the GOVERNOR role</p> Name Type Description _address address The address to validate Name Type Description [0] bool true if is a governor"},{"location":"#getmarketplacefee","title":"getMarketplaceFee","text":"<pre><code>function getMarketplaceFee() external view virtual returns (uint256)\n</code></pre> <p>Returns the marketplace fee</p> Name Type Description [0] uint256 the marketplace fee"},{"location":"#getfeereceiver","title":"getFeeReceiver","text":"<pre><code>function getFeeReceiver() external view virtual returns (address)\n</code></pre> <p>Returns the receiver address of the marketplace fee</p> Name Type Description [0] address the receiver address"},{"location":"#neverminedconfig","title":"NeverminedConfig","text":""},{"location":"#marketplacefee","title":"marketplaceFee","text":"<pre><code>uint256 marketplaceFee\n</code></pre>"},{"location":"#feereceiver","title":"feeReceiver","text":"<pre><code>address feeReceiver\n</code></pre>"},{"location":"#initialize_31","title":"initialize","text":"<pre><code>function initialize(address _owner, address _governor) public\n</code></pre> <p>Used to initialize the contract during delegator constructor</p> Name Type Description _owner address The owner of the contract _governor address The address to be granted with the <code>GOVERNOR_ROLE</code>"},{"location":"#setmarketplacefees_1","title":"setMarketplaceFees","text":"<pre><code>function setMarketplaceFees(uint256 _marketplaceFee, address _feeReceiver) external virtual\n</code></pre> <p>The governor can update the Nevermined Marketplace fees</p> Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee"},{"location":"#setgovernor","title":"setGovernor","text":"<pre><code>function setGovernor(address _address) external\n</code></pre>"},{"location":"#isgovernor_1","title":"isGovernor","text":"<pre><code>function isGovernor(address _address) external view returns (bool)\n</code></pre> <p>Indicates if an address is a having the GOVERNOR role</p> Name Type Description _address address The address to validate Name Type Description [0] bool true if is a governor"},{"location":"#getmarketplacefee_1","title":"getMarketplaceFee","text":"<pre><code>function getMarketplaceFee() external view returns (uint256)\n</code></pre> <p>Returns the marketplace fee</p> Name Type Description [0] uint256 the marketplace fee"},{"location":"#getfeereceiver_1","title":"getFeeReceiver","text":"<pre><code>function getFeeReceiver() external view returns (address)\n</code></pre> <p>Returns the receiver address of the marketplace fee</p> Name Type Description [0] address the receiver address"},{"location":"#onlygovernor","title":"onlyGovernor","text":"<pre><code>modifier onlyGovernor(address _address)\n</code></pre>"},{"location":"#ierc20","title":"IERC20","text":""},{"location":"#totalsupply","title":"totalSupply","text":"<pre><code>function totalSupply() external view returns (uint256)\n</code></pre> <p>Returns the amount of tokens in existence.</p>"},{"location":"#balanceof","title":"balanceOf","text":"<pre><code>function balanceOf(address account) external view returns (uint256)\n</code></pre> <p>Returns the amount of tokens owned by <code>account</code>.</p>"},{"location":"#transfer","title":"transfer","text":"<pre><code>function transfer(address recipient, uint256 amount) external returns (bool)\n</code></pre> <p>_Moves <code>amount</code> tokens from the caller's account to <code>recipient</code>.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>Emits a {Transfer} event._</p>"},{"location":"#allowance","title":"allowance","text":"<pre><code>function allowance(address owner, address spender) external view returns (uint256)\n</code></pre> <p>_Returns the remaining number of tokens that <code>spender</code> will be allowed to spend on behalf of <code>owner</code> through {transferFrom}. This is zero by default.</p> <p>This value changes when {approve} or {transferFrom} are called._</p>"},{"location":"#approve","title":"approve","text":"<pre><code>function approve(address spender, uint256 amount) external returns (bool)\n</code></pre> <p>_Sets <code>amount</code> as the allowance of <code>spender</code> over the caller's tokens.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</p> <p>Emits an {Approval} event._</p>"},{"location":"#transferfrom","title":"transferFrom","text":"<pre><code>function transferFrom(address sender, address recipient, uint256 amount) external returns (bool)\n</code></pre> <p>_Moves <code>amount</code> tokens from <code>sender</code> to <code>recipient</code> using the allowance mechanism. <code>amount</code> is then deducted from the caller's allowance.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>Emits a {Transfer} event._</p>"},{"location":"#transfer_1","title":"Transfer","text":"<pre><code>event Transfer(address from, address to, uint256 value)\n</code></pre> <p>_Emitted when <code>value</code> tokens are moved from one account (<code>from</code>) to another (<code>to</code>).</p> <p>Note that <code>value</code> may be zero._</p>"},{"location":"#approval","title":"Approval","text":"<pre><code>event Approval(address owner, address spender, uint256 value)\n</code></pre> <p>Emitted when the allowance of a <code>spender</code> for an <code>owner</code> is set by a call to {approve}. <code>value</code> is the new allowance.</p>"},{"location":"#ipriceoraclegetter","title":"IPriceOracleGetter","text":"<p>Interface for the Aave price oracle.</p>"},{"location":"#getassetprice_1","title":"getAssetPrice","text":"<pre><code>function getAssetPrice(address asset) external view returns (uint256)\n</code></pre> <p>returns the asset price in ETH</p> Name Type Description asset address the address of the asset Name Type Description [0] uint256 the ETH price of the asset"},{"location":"#iprotocoldataprovider","title":"IProtocolDataProvider","text":""},{"location":"#tokendata","title":"TokenData","text":"<pre><code>struct TokenData {\n  string symbol;\n  address tokenAddress;\n}\n</code></pre>"},{"location":"#addresses_provider","title":"ADDRESSES_PROVIDER","text":"<pre><code>function ADDRESSES_PROVIDER() external view returns (contract ILendingPoolAddressesProvider)\n</code></pre>"},{"location":"#getallreservestokens","title":"getAllReservesTokens","text":"<pre><code>function getAllReservesTokens() external view returns (struct IProtocolDataProvider.TokenData[])\n</code></pre>"},{"location":"#getallatokens","title":"getAllATokens","text":"<pre><code>function getAllATokens() external view returns (struct IProtocolDataProvider.TokenData[])\n</code></pre>"},{"location":"#getreserveconfigurationdata","title":"getReserveConfigurationData","text":"<pre><code>function getReserveConfigurationData(address asset) external view returns (uint256 decimals, uint256 ltv, uint256 liquidationThreshold, uint256 liquidationBonus, uint256 reserveFactor, bool usageAsCollateralEnabled, bool borrowingEnabled, bool stableBorrowRateEnabled, bool isActive, bool isFrozen)\n</code></pre>"},{"location":"#getreservedata","title":"getReserveData","text":"<pre><code>function getReserveData(address asset) external view returns (uint256 availableLiquidity, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\n</code></pre>"},{"location":"#getuserreservedata","title":"getUserReserveData","text":"<pre><code>function getUserReserveData(address asset, address user) external view returns (uint256 currentATokenBalance, uint256 currentStableDebt, uint256 currentVariableDebt, uint256 principalStableDebt, uint256 scaledVariableDebt, uint256 stableBorrowRate, uint256 liquidityRate, uint40 stableRateLastUpdated, bool usageAsCollateralEnabled)\n</code></pre>"},{"location":"#getreservetokensaddresses","title":"getReserveTokensAddresses","text":"<pre><code>function getReserveTokensAddresses(address asset) external view returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress)\n</code></pre>"},{"location":"#ilendingpooladdressesprovider","title":"ILendingPoolAddressesProvider","text":""},{"location":"#marketidset","title":"MarketIdSet","text":"<pre><code>event MarketIdSet(string newMarketId)\n</code></pre>"},{"location":"#lendingpoolupdated","title":"LendingPoolUpdated","text":"<pre><code>event LendingPoolUpdated(address newAddress)\n</code></pre>"},{"location":"#configurationadminupdated","title":"ConfigurationAdminUpdated","text":"<pre><code>event ConfigurationAdminUpdated(address newAddress)\n</code></pre>"},{"location":"#emergencyadminupdated","title":"EmergencyAdminUpdated","text":"<pre><code>event EmergencyAdminUpdated(address newAddress)\n</code></pre>"},{"location":"#lendingpoolconfiguratorupdated","title":"LendingPoolConfiguratorUpdated","text":"<pre><code>event LendingPoolConfiguratorUpdated(address newAddress)\n</code></pre>"},{"location":"#lendingpoolcollateralmanagerupdated","title":"LendingPoolCollateralManagerUpdated","text":"<pre><code>event LendingPoolCollateralManagerUpdated(address newAddress)\n</code></pre>"},{"location":"#priceoracleupdated","title":"PriceOracleUpdated","text":"<pre><code>event PriceOracleUpdated(address newAddress)\n</code></pre>"},{"location":"#lendingrateoracleupdated","title":"LendingRateOracleUpdated","text":"<pre><code>event LendingRateOracleUpdated(address newAddress)\n</code></pre>"},{"location":"#proxycreated","title":"ProxyCreated","text":"<pre><code>event ProxyCreated(bytes32 id, address newAddress)\n</code></pre>"},{"location":"#addressset","title":"AddressSet","text":"<pre><code>event AddressSet(bytes32 id, address newAddress, bool hasProxy)\n</code></pre>"},{"location":"#getmarketid","title":"getMarketId","text":"<pre><code>function getMarketId() external view returns (string)\n</code></pre>"},{"location":"#setmarketid","title":"setMarketId","text":"<pre><code>function setMarketId(string marketId) external\n</code></pre>"},{"location":"#setaddress","title":"setAddress","text":"<pre><code>function setAddress(bytes32 id, address newAddress) external\n</code></pre>"},{"location":"#setaddressasproxy","title":"setAddressAsProxy","text":"<pre><code>function setAddressAsProxy(bytes32 id, address impl) external\n</code></pre>"},{"location":"#getaddress","title":"getAddress","text":"<pre><code>function getAddress(bytes32 id) external view returns (address)\n</code></pre>"},{"location":"#getlendingpool","title":"getLendingPool","text":"<pre><code>function getLendingPool() external view returns (address)\n</code></pre>"},{"location":"#setlendingpoolimpl","title":"setLendingPoolImpl","text":"<pre><code>function setLendingPoolImpl(address pool) external\n</code></pre>"},{"location":"#getlendingpoolconfigurator","title":"getLendingPoolConfigurator","text":"<pre><code>function getLendingPoolConfigurator() external view returns (address)\n</code></pre>"},{"location":"#setlendingpoolconfiguratorimpl","title":"setLendingPoolConfiguratorImpl","text":"<pre><code>function setLendingPoolConfiguratorImpl(address configurator) external\n</code></pre>"},{"location":"#getlendingpoolcollateralmanager","title":"getLendingPoolCollateralManager","text":"<pre><code>function getLendingPoolCollateralManager() external view returns (address)\n</code></pre>"},{"location":"#setlendingpoolcollateralmanager","title":"setLendingPoolCollateralManager","text":"<pre><code>function setLendingPoolCollateralManager(address manager) external\n</code></pre>"},{"location":"#getpooladmin","title":"getPoolAdmin","text":"<pre><code>function getPoolAdmin() external view returns (address)\n</code></pre>"},{"location":"#setpooladmin","title":"setPoolAdmin","text":"<pre><code>function setPoolAdmin(address admin) external\n</code></pre>"},{"location":"#getemergencyadmin","title":"getEmergencyAdmin","text":"<pre><code>function getEmergencyAdmin() external view returns (address)\n</code></pre>"},{"location":"#setemergencyadmin","title":"setEmergencyAdmin","text":"<pre><code>function setEmergencyAdmin(address admin) external\n</code></pre>"},{"location":"#getpriceoracle","title":"getPriceOracle","text":"<pre><code>function getPriceOracle() external view returns (address)\n</code></pre>"},{"location":"#setpriceoracle","title":"setPriceOracle","text":"<pre><code>function setPriceOracle(address priceOracle) external\n</code></pre>"},{"location":"#getlendingrateoracle","title":"getLendingRateOracle","text":"<pre><code>function getLendingRateOracle() external view returns (address)\n</code></pre>"},{"location":"#setlendingrateoracle","title":"setLendingRateOracle","text":"<pre><code>function setLendingRateOracle(address lendingRateOracle) external\n</code></pre>"},{"location":"#ilendingpool","title":"ILendingPool","text":""},{"location":"#deposit_1","title":"Deposit","text":"<pre><code>event Deposit(address reserve, address user, address onBehalfOf, uint256 amount, uint16 referral)\n</code></pre> <p>Emitted on deposit()</p> Name Type Description reserve address The address of the underlying asset of the reserve user address The address initiating the deposit onBehalfOf address The beneficiary of the deposit, receiving the aTokens amount uint256 The amount deposited referral uint16 The referral code used"},{"location":"#withdraw","title":"Withdraw","text":"<pre><code>event Withdraw(address reserve, address user, address to, uint256 amount)\n</code></pre> <p>Emitted on withdraw()</p> Name Type Description reserve address The address of the underlyng asset being withdrawn user address The address initiating the withdrawal, owner of aTokens to address Address that will receive the underlying amount uint256 The amount to be withdrawn"},{"location":"#borrow_1","title":"Borrow","text":"<pre><code>event Borrow(address reserve, address user, address onBehalfOf, uint256 amount, uint256 borrowRateMode, uint256 borrowRate, uint16 referral)\n</code></pre> <p>Emitted on borrow() and flashLoan() when debt needs to be opened</p> Name Type Description reserve address The address of the underlying asset being borrowed user address The address of the user initiating the borrow(), receiving the funds on borrow() or just initiator of the transaction on flashLoan() onBehalfOf address The address that will be getting the debt amount uint256 The amount borrowed out borrowRateMode uint256 The rate mode: 1 for Stable, 2 for Variable borrowRate uint256 The numeric rate at which the user has borrowed referral uint16 The referral code used"},{"location":"#repay_1","title":"Repay","text":"<pre><code>event Repay(address reserve, address user, address repayer, uint256 amount)\n</code></pre> <p>Emitted on repay()</p> Name Type Description reserve address The address of the underlying asset of the reserve user address The beneficiary of the repayment, getting his debt reduced repayer address The address of the user initiating the repay(), providing the funds amount uint256 The amount repaid"},{"location":"#swap","title":"Swap","text":"<pre><code>event Swap(address reserve, address user, uint256 rateMode)\n</code></pre> <p>Emitted on swapBorrowRateMode()</p> Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user swapping his rate mode rateMode uint256 The rate mode that the user wants to swap to"},{"location":"#reserveusedascollateralenabled","title":"ReserveUsedAsCollateralEnabled","text":"<pre><code>event ReserveUsedAsCollateralEnabled(address reserve, address user)\n</code></pre> <p>Emitted on setUserUseReserveAsCollateral()</p> Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user enabling the usage as collateral"},{"location":"#reserveusedascollateraldisabled","title":"ReserveUsedAsCollateralDisabled","text":"<pre><code>event ReserveUsedAsCollateralDisabled(address reserve, address user)\n</code></pre> <p>Emitted on setUserUseReserveAsCollateral()</p> Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user enabling the usage as collateral"},{"location":"#rebalancestableborrowrate","title":"RebalanceStableBorrowRate","text":"<pre><code>event RebalanceStableBorrowRate(address reserve, address user)\n</code></pre> <p>Emitted on rebalanceStableBorrowRate()</p> Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user for which the rebalance has been executed"},{"location":"#flashloan","title":"FlashLoan","text":"<pre><code>event FlashLoan(address target, address initiator, address asset, uint256 amount, uint256 premium, uint16 referralCode)\n</code></pre> <p>Emitted on flashLoan()</p> Name Type Description target address The address of the flash loan receiver contract initiator address The address initiating the flash loan asset address The address of the asset being flash borrowed amount uint256 The amount flash borrowed premium uint256 The fee flash borrowed referralCode uint16 The referral code used"},{"location":"#paused","title":"Paused","text":"<pre><code>event Paused()\n</code></pre> <p>Emitted when the pause is triggered.</p>"},{"location":"#unpaused","title":"Unpaused","text":"<pre><code>event Unpaused()\n</code></pre> <p>Emitted when the pause is lifted.</p>"},{"location":"#liquidationcall","title":"LiquidationCall","text":"<pre><code>event LiquidationCall(address collateralAsset, address debtAsset, address user, uint256 debtToCover, uint256 liquidatedCollateralAmount, address liquidator, bool receiveAToken)\n</code></pre> <p>Emitted when a borrower is liquidated. This event is emitted by the LendingPool via LendingPoolCollateral manager using a DELEGATECALL This allows to have the events in the generated ABI for LendingPool.</p> Name Type Description collateralAsset address The address of the underlying asset used as collateral, to receive as result of the liquidation debtAsset address The address of the underlying borrowed asset to be repaid with the liquidation user address The address of the borrower getting liquidated debtToCover uint256 The debt amount of borrowed <code>asset</code> the liquidator wants to cover liquidatedCollateralAmount uint256 The amount of collateral received by the liiquidator liquidator address The address of the liquidator receiveAToken bool <code>true</code> if the liquidators wants to receive the collateral aTokens, <code>false</code> if he wants to receive the underlying collateral asset directly"},{"location":"#reservedataupdated","title":"ReserveDataUpdated","text":"<pre><code>event ReserveDataUpdated(address reserve, uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex)\n</code></pre> <p>Emitted when the state of a reserve is updated. NOTE: This event is actually declared in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal, the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it gets added to the LendingPool ABI</p> Name Type Description reserve address The address of the underlying asset of the reserve liquidityRate uint256 The new liquidity rate stableBorrowRate uint256 The new stable borrow rate variableBorrowRate uint256 The new variable borrow rate liquidityIndex uint256 The new liquidity index variableBorrowIndex uint256 The new variable borrow index"},{"location":"#deposit_2","title":"deposit","text":"<pre><code>function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external\n</code></pre> <p>Deposits an <code>amount</code> of underlying asset into the reserve, receiving in return overlying aTokens. - E.g. User deposits 100 USDC and gets in return 100 aUSDC</p> Name Type Description asset address The address of the underlying asset to deposit amount uint256 The amount to be deposited onBehalfOf address The address that will receive the aTokens, same as msg.sender if the user   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens   is a different wallet referralCode uint16 Code used to register the integrator originating the operation, for potential rewards.   0 if the action is executed directly by the user, without any middle-man"},{"location":"#withdraw_1","title":"withdraw","text":"<pre><code>function withdraw(address asset, uint256 amount, address to) external returns (uint256)\n</code></pre> <p>Withdraws an <code>amount</code> of underlying asset from the reserve, burning the equivalent aTokens owned E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC</p> Name Type Description asset address The address of the underlying asset to withdraw amount uint256 The underlying amount to be withdrawn   - Send the value type(uint256).max in order to withdraw the whole aToken balance to address Address that will receive the underlying, same as msg.sender if the user   wants to receive it on his own wallet, or a different address if the beneficiary is a   different wallet Name Type Description [0] uint256 The final amount withdrawn"},{"location":"#borrow_2","title":"borrow","text":"<pre><code>function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf) external\n</code></pre> <p>Allows users to borrow a specific <code>amount</code> of the reserve underlying asset, provided that the borrower already deposited enough collateral, or he was given enough allowance by a credit delegator on the corresponding debt token (StableDebtToken or VariableDebtToken) - E.g. User borrows 100 USDC passing as <code>onBehalfOf</code> his own address, receiving the 100 USDC in his wallet   and 100 stable/variable debt tokens, depending on the <code>interestRateMode</code></p> Name Type Description asset address The address of the underlying asset to borrow amount uint256 The amount to be borrowed interestRateMode uint256 The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable referralCode uint16 Code used to register the integrator originating the operation, for potential rewards.   0 if the action is executed directly by the user, without any middle-man onBehalfOf address Address of the user who will receive the debt. Should be the address of the borrower itself calling the function if he wants to borrow against his own collateral, or the address of the credit delegator if he has been given credit delegation allowance"},{"location":"#repay_2","title":"repay","text":"<pre><code>function repay(address asset, uint256 amount, uint256 rateMode, address onBehalfOf) external returns (uint256)\n</code></pre> <p>Repays a borrowed <code>amount</code> on a specific reserve, burning the equivalent debt tokens owned - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the <code>onBehalfOf</code> address</p> Name Type Description asset address The address of the borrowed underlying asset previously borrowed amount uint256 The amount to repay - Send the value type(uint256).max in order to repay the whole debt for <code>asset</code> on the specific <code>debtMode</code> rateMode uint256 The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable onBehalfOf address Address of the user who will get his debt reduced/removed. Should be the address of the user calling the function if he wants to reduce/remove his own debt, or the address of any other other borrower whose debt should be removed Name Type Description [0] uint256 The final amount repaid"},{"location":"#swapborrowratemode","title":"swapBorrowRateMode","text":"<pre><code>function swapBorrowRateMode(address asset, uint256 rateMode) external\n</code></pre> <p>Allows a borrower to swap his debt between stable and variable mode, or viceversa</p> Name Type Description asset address The address of the underlying asset borrowed rateMode uint256 The rate mode that the user wants to swap to"},{"location":"#rebalancestableborrowrate_1","title":"rebalanceStableBorrowRate","text":"<pre><code>function rebalanceStableBorrowRate(address asset, address user) external\n</code></pre> <p>Rebalances the stable interest rate of a user to the current stable rate defined on the reserve. - Users can be rebalanced if the following conditions are satisfied:     1. Usage ratio is above 95%     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been        borrowed at a stable rate and depositors are not earning enough</p> Name Type Description asset address The address of the underlying asset borrowed user address The address of the user to be rebalanced"},{"location":"#setuserusereserveascollateral","title":"setUserUseReserveAsCollateral","text":"<pre><code>function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external\n</code></pre> <p>Allows depositors to enable/disable a specific deposited asset as collateral</p> Name Type Description asset address The address of the underlying asset deposited useAsCollateral bool <code>true</code> if the user wants to use the deposit as collateral, <code>false</code> otherwise"},{"location":"#liquidationcall_1","title":"liquidationCall","text":"<pre><code>function liquidationCall(address collateralAsset, address debtAsset, address user, uint256 debtToCover, bool receiveAToken) external\n</code></pre> <p>Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1 - The caller (liquidator) covers <code>debtToCover</code> amount of debt of the user getting liquidated, and receives   a proportionally amount of the <code>collateralAsset</code> plus a bonus to cover market risk</p> Name Type Description collateralAsset address The address of the underlying asset used as collateral, to receive as result of the liquidation debtAsset address The address of the underlying borrowed asset to be repaid with the liquidation user address The address of the borrower getting liquidated debtToCover uint256 The debt amount of borrowed <code>asset</code> the liquidator wants to cover receiveAToken bool <code>true</code> if the liquidators wants to receive the collateral aTokens, <code>false</code> if he wants to receive the underlying collateral asset directly"},{"location":"#flashloan_1","title":"flashLoan","text":"<pre><code>function flashLoan(address receiverAddress, address[] assets, uint256[] amounts, uint256[] modes, address onBehalfOf, bytes params, uint16 referralCode) external\n</code></pre> <p>Allows smartcontracts to access the liquidity of the pool within one transaction, as long as the amount taken plus a fee is returned. IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration. For further details please visit https://developers.aave.com</p> Name Type Description receiverAddress address The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface assets address[] The addresses of the assets being flash-borrowed amounts uint256[] The amounts amounts being flash-borrowed modes uint256[] Types of the debt to open if the flash loan is not returned:   0 -&gt; Don't open any debt, just revert if funds can't be transferred from the receiver   1 -&gt; Open debt at stable rate for the value of the amount flash-borrowed to the <code>onBehalfOf</code> address   2 -&gt; Open debt at variable rate for the value of the amount flash-borrowed to the <code>onBehalfOf</code> address onBehalfOf address The address  that will receive the debt in the case of using on <code>modes</code> 1 or 2 params bytes Variadic packed params to pass to the receiver as extra information referralCode uint16 Code used to register the integrator originating the operation, for potential rewards.   0 if the action is executed directly by the user, without any middle-man"},{"location":"#getuseraccountdata","title":"getUserAccountData","text":"<pre><code>function getUserAccountData(address user) external view returns (uint256 totalCollateralETH, uint256 totalDebtETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor)\n</code></pre> <p>Returns the user account data across all the reserves</p> Name Type Description user address The address of the user Name Type Description totalCollateralETH uint256 the total collateral in ETH of the user totalDebtETH uint256 the total debt in ETH of the user availableBorrowsETH uint256 the borrowing power left of the user currentLiquidationThreshold uint256 the liquidation threshold of the user ltv uint256 the loan to value of the user healthFactor uint256 the current health factor of the user"},{"location":"#initreserve","title":"initReserve","text":"<pre><code>function initReserve(address reserve, address aTokenAddress, address stableDebtAddress, address variableDebtAddress, address interestRateStrategyAddress) external\n</code></pre>"},{"location":"#setreserveinterestratestrategyaddress","title":"setReserveInterestRateStrategyAddress","text":"<pre><code>function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external\n</code></pre>"},{"location":"#setconfiguration","title":"setConfiguration","text":"<pre><code>function setConfiguration(address reserve, uint256 configuration) external\n</code></pre>"},{"location":"#getconfiguration","title":"getConfiguration","text":"<pre><code>function getConfiguration(address asset) external view returns (struct DataTypes.ReserveConfigurationMap)\n</code></pre> <p>Returns the configuration of the reserve</p> Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] struct DataTypes.ReserveConfigurationMap The configuration of the reserve"},{"location":"#getuserconfiguration","title":"getUserConfiguration","text":"<pre><code>function getUserConfiguration(address user) external view returns (struct DataTypes.UserConfigurationMap)\n</code></pre> <p>Returns the configuration of the user across all the reserves</p> Name Type Description user address The user address Name Type Description [0] struct DataTypes.UserConfigurationMap The configuration of the user"},{"location":"#getreservenormalizedincome","title":"getReserveNormalizedIncome","text":"<pre><code>function getReserveNormalizedIncome(address asset) external view returns (uint256)\n</code></pre> <p>Returns the normalized income normalized income of the reserve</p> Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] uint256 The reserve's normalized income"},{"location":"#getreservenormalizedvariabledebt","title":"getReserveNormalizedVariableDebt","text":"<pre><code>function getReserveNormalizedVariableDebt(address asset) external view returns (uint256)\n</code></pre> <p>Returns the normalized variable debt per unit of asset</p> Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] uint256 The reserve normalized variable debt"},{"location":"#getreservedata_1","title":"getReserveData","text":"<pre><code>function getReserveData(address asset) external view returns (struct DataTypes.ReserveData)\n</code></pre> <p>Returns the state and configuration of the reserve</p> Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] struct DataTypes.ReserveData The state of the reserve"},{"location":"#finalizetransfer","title":"finalizeTransfer","text":"<pre><code>function finalizeTransfer(address asset, address from, address to, uint256 amount, uint256 balanceFromAfter, uint256 balanceToBefore) external\n</code></pre>"},{"location":"#getreserveslist","title":"getReservesList","text":"<pre><code>function getReservesList() external view returns (address[])\n</code></pre>"},{"location":"#getaddressesprovider","title":"getAddressesProvider","text":"<pre><code>function getAddressesProvider() external view returns (contract ILendingPoolAddressesProvider)\n</code></pre>"},{"location":"#setpause","title":"setPause","text":"<pre><code>function setPause(bool val) external\n</code></pre>"},{"location":"#paused_1","title":"paused","text":"<pre><code>function paused() external view returns (bool)\n</code></pre>"},{"location":"#istabledebttoken","title":"IStableDebtToken","text":""},{"location":"#mint_1","title":"Mint","text":"<pre><code>event Mint(address user, address onBehalfOf, uint256 amount, uint256 currentBalance, uint256 balanceIncrease, uint256 newRate, uint256 avgStableRate, uint256 newTotalSupply)\n</code></pre> <p>Emitted when new stable debt is minted</p> Name Type Description user address The address of the user who triggered the minting onBehalfOf address The recipient of stable debt tokens amount uint256 The amount minted currentBalance uint256 The current balance of the user balanceIncrease uint256 The increase in balance since the last action of the user newRate uint256 The rate of the debt after the minting avgStableRate uint256 The new average stable rate after the minting newTotalSupply uint256 The new total supply of the stable debt token after the action"},{"location":"#burn","title":"Burn","text":"<pre><code>event Burn(address user, uint256 amount, uint256 currentBalance, uint256 balanceIncrease, uint256 avgStableRate, uint256 newTotalSupply)\n</code></pre> <p>Emitted when new stable debt is burned</p> Name Type Description user address The address of the user amount uint256 The amount being burned currentBalance uint256 The current balance of the user balanceIncrease uint256 The the increase in balance since the last action of the user avgStableRate uint256 The new average stable rate after the burning newTotalSupply uint256 The new total supply of the stable debt token after the action"},{"location":"#approvedelegation","title":"approveDelegation","text":"<pre><code>function approveDelegation(address delegatee, uint256 amount) external\n</code></pre> <p>delegates borrowing power to a user on the specific debt token</p> Name Type Description delegatee address the address receiving the delegated borrowing power amount uint256 the maximum amount being delegated. Delegation will still respect the liquidation constraints (even if delegated, a delegatee cannot force a delegator HF to go below 1)"},{"location":"#borrowallowance","title":"borrowAllowance","text":"<pre><code>function borrowAllowance(address fromUser, address toUser) external view returns (uint256)\n</code></pre> <p>returns the borrow allowance of the user</p> Name Type Description fromUser address The user to giving allowance toUser address The user to give allowance to Name Type Description [0] uint256 the current allowance of toUser"},{"location":"#mint_2","title":"mint","text":"<pre><code>function mint(address user, address onBehalfOf, uint256 amount, uint256 rate) external returns (bool)\n</code></pre> <p>Mints debt token to the <code>onBehalfOf</code> address. - The resulting rate is the weighted average between the rate of the new debt and the rate of the previous debt</p> Name Type Description user address The address receiving the borrowed underlying, being the delegatee in case of credit delegate, or same as <code>onBehalfOf</code> otherwise onBehalfOf address The address receiving the debt tokens amount uint256 The amount of debt tokens to mint rate uint256 The rate of the debt being minted"},{"location":"#burn_1","title":"burn","text":"<pre><code>function burn(address user, uint256 amount) external\n</code></pre> <p>Burns debt of <code>user</code> - The resulting rate is the weighted average between the rate of the new debt and the rate of the previous debt</p> Name Type Description user address The address of the user getting his debt burned amount uint256 The amount of debt tokens getting burned"},{"location":"#getaveragestablerate","title":"getAverageStableRate","text":"<pre><code>function getAverageStableRate() external view returns (uint256)\n</code></pre> <p>Returns the average rate of all the stable rate loans.</p> Name Type Description [0] uint256 The average stable rate"},{"location":"#getuserstablerate","title":"getUserStableRate","text":"<pre><code>function getUserStableRate(address user) external view returns (uint256)\n</code></pre> <p>Returns the stable rate of the user debt</p> Name Type Description [0] uint256 The stable rate of the user"},{"location":"#getuserlastupdated","title":"getUserLastUpdated","text":"<pre><code>function getUserLastUpdated(address user) external view returns (uint40)\n</code></pre> <p>Returns the timestamp of the last update of the user</p> Name Type Description [0] uint40 The timestamp"},{"location":"#getsupplydata","title":"getSupplyData","text":"<pre><code>function getSupplyData() external view returns (uint256, uint256, uint256, uint40)\n</code></pre> <p>Returns the principal, the total supply and the average stable rate</p>"},{"location":"#gettotalsupplylastupdated","title":"getTotalSupplyLastUpdated","text":"<pre><code>function getTotalSupplyLastUpdated() external view returns (uint40)\n</code></pre> <p>Returns the timestamp of the last update of the total supply</p> Name Type Description [0] uint40 The timestamp"},{"location":"#gettotalsupplyandavgrate","title":"getTotalSupplyAndAvgRate","text":"<pre><code>function getTotalSupplyAndAvgRate() external view returns (uint256, uint256)\n</code></pre> <p>Returns the total supply and the average stable rate</p>"},{"location":"#principalbalanceof","title":"principalBalanceOf","text":"<pre><code>function principalBalanceOf(address user) external view returns (uint256)\n</code></pre> <p>Returns the principal debt balance of the user</p> Name Type Description [0] uint256 The debt balance of the user since the last burn/mint action"},{"location":"#idynamicpricing","title":"IDynamicPricing","text":""},{"location":"#dynamicpricingstate","title":"DynamicPricingState","text":"<pre><code>enum DynamicPricingState {\n  NotStarted,\n  Finished,\n  InProgress,\n  Aborted\n}\n</code></pre>"},{"location":"#getpricingtype","title":"getPricingType","text":"<pre><code>function getPricingType() external view returns (bytes32)\n</code></pre>"},{"location":"#getprice","title":"getPrice","text":"<pre><code>function getPrice(bytes32 did) external view returns (uint256)\n</code></pre>"},{"location":"#gettokenaddress","title":"getTokenAddress","text":"<pre><code>function getTokenAddress(bytes32 did) external view returns (address)\n</code></pre>"},{"location":"#getstatus","title":"getStatus","text":"<pre><code>function getStatus(bytes32 did) external view returns (enum IDynamicPricing.DynamicPricingState, uint256, address)\n</code></pre>"},{"location":"#canbepurchased","title":"canBePurchased","text":"<pre><code>function canBePurchased(bytes32 did) external view returns (bool)\n</code></pre>"},{"location":"#withdraw_2","title":"withdraw","text":"<pre><code>function withdraw(bytes32 did, address withdrawAddress) external returns (bool)\n</code></pre>"},{"location":"#ilist","title":"IList","text":""},{"location":"#has_2","title":"has","text":"<pre><code>function has(bytes32 value) external view returns (bool)\n</code></pre>"},{"location":"#has_3","title":"has","text":"<pre><code>function has(bytes32 value, bytes32 id) external view returns (bool)\n</code></pre>"},{"location":"#iroyaltyscheme","title":"IRoyaltyScheme","text":""},{"location":"#check","title":"check","text":"<pre><code>function check(bytes32 _did, uint256[] _amounts, address[] _receivers, address _tokenAddress) external view returns (bool)\n</code></pre> <p>check that royalties are correct</p> Name Type Description _did bytes32 compute royalties for this DID _amounts uint256[] amounts in payment _receivers address[] receivers of payments _tokenAddress address payment token. zero address means native token (ether)"},{"location":"#isecretstore","title":"ISecretStore","text":""},{"location":"#checkpermissions_2","title":"checkPermissions","text":"<pre><code>function checkPermissions(address user, bytes32 documentKeyId) external view returns (bool permissionGranted)\n</code></pre> <p>checkPermissions is called by Parity secret store</p>"},{"location":"#isecretstorepermission","title":"ISecretStorePermission","text":""},{"location":"#grantpermission_2","title":"grantPermission","text":"<pre><code>function grantPermission(address user, bytes32 documentKeyId) external\n</code></pre> <p>grantPermission is called only by documentKeyId Owner or provider</p>"},{"location":"#renouncepermission_1","title":"renouncePermission","text":"<pre><code>function renouncePermission(address user, bytes32 documentKeyId) external\n</code></pre> <p>renouncePermission is called only by documentKeyId Owner or provider</p>"},{"location":"#iwethgateway","title":"IWETHGateway","text":""},{"location":"#depositeth","title":"depositETH","text":"<pre><code>function depositETH(address lendingPool, address onBehalfOf, uint16 referralCode) external payable\n</code></pre>"},{"location":"#withdraweth","title":"withdrawETH","text":"<pre><code>function withdrawETH(address lendingPool, uint256 amount, address to) external\n</code></pre>"},{"location":"#repayeth","title":"repayETH","text":"<pre><code>function repayETH(address lendingPool, uint256 amount, uint256 rateMode, address onBehalfOf) external payable\n</code></pre>"},{"location":"#borroweth","title":"borrowETH","text":"<pre><code>function borrowETH(address lendingPool, uint256 amount, uint256 interesRateMode, uint16 referralCode) external\n</code></pre>"},{"location":"#datatypes","title":"DataTypes","text":""},{"location":"#reservedata","title":"ReserveData","text":"<pre><code>struct ReserveData {\n  struct DataTypes.ReserveConfigurationMap configuration;\n  uint128 liquidityIndex;\n  uint128 variableBorrowIndex;\n  uint128 currentLiquidityRate;\n  uint128 currentVariableBorrowRate;\n  uint128 currentStableBorrowRate;\n  uint40 lastUpdateTimestamp;\n  address aTokenAddress;\n  address stableDebtTokenAddress;\n  address variableDebtTokenAddress;\n  address interestRateStrategyAddress;\n  uint8 id;\n}\n</code></pre>"},{"location":"#reserveconfigurationmap","title":"ReserveConfigurationMap","text":"<pre><code>struct ReserveConfigurationMap {\n  uint256 data;\n}\n</code></pre>"},{"location":"#userconfigurationmap","title":"UserConfigurationMap","text":"<pre><code>struct UserConfigurationMap {\n  uint256 data;\n}\n</code></pre>"},{"location":"#interestratemode","title":"InterestRateMode","text":"<pre><code>enum InterestRateMode {\n  NONE,\n  STABLE,\n  VARIABLE\n}\n</code></pre>"},{"location":"#safemath","title":"SafeMath","text":""},{"location":"#add_2","title":"add","text":"<pre><code>function add(uint256 a, uint256 b) internal pure returns (uint256)\n</code></pre> <p>_Returns the addition of two unsigned integers, reverting on overflow.</p> <p>Counterpart to Solidity's <code>+</code> operator.</p> <p>Requirements: - Addition cannot overflow._</p>"},{"location":"#sub","title":"sub","text":"<pre><code>function sub(uint256 a, uint256 b) internal pure returns (uint256)\n</code></pre> <p>_Returns the subtraction of two unsigned integers, reverting on overflow (when the result is negative).</p> <p>Counterpart to Solidity's <code>-</code> operator.</p> <p>Requirements: - Subtraction cannot overflow._</p>"},{"location":"#sub_1","title":"sub","text":"<pre><code>function sub(uint256 a, uint256 b, string errorMessage) internal pure returns (uint256)\n</code></pre> <p>_Returns the subtraction of two unsigned integers, reverting with custom message on overflow (when the result is negative).</p> <p>Counterpart to Solidity's <code>-</code> operator.</p> <p>Requirements: - Subtraction cannot overflow._</p>"},{"location":"#mul","title":"mul","text":"<pre><code>function mul(uint256 a, uint256 b) internal pure returns (uint256)\n</code></pre> <p>_Returns the multiplication of two unsigned integers, reverting on overflow.</p> <p>Counterpart to Solidity's <code>*</code> operator.</p> <p>Requirements: - Multiplication cannot overflow._</p>"},{"location":"#div","title":"div","text":"<pre><code>function div(uint256 a, uint256 b) internal pure returns (uint256)\n</code></pre> <p>_Returns the integer division of two unsigned integers. Reverts on division by zero. The result is rounded towards zero.</p> <p>Counterpart to Solidity's <code>/</code> operator. Note: this function uses a <code>revert</code> opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas).</p> <p>Requirements: - The divisor cannot be zero._</p>"},{"location":"#div_1","title":"div","text":"<pre><code>function div(uint256 a, uint256 b, string errorMessage) internal pure returns (uint256)\n</code></pre> <p>_Returns the integer division of two unsigned integers. Reverts with custom message on division by zero. The result is rounded towards zero.</p> <p>Counterpart to Solidity's <code>/</code> operator. Note: this function uses a <code>revert</code> opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas).</p> <p>Requirements: - The divisor cannot be zero._</p>"},{"location":"#mod","title":"mod","text":"<pre><code>function mod(uint256 a, uint256 b) internal pure returns (uint256)\n</code></pre> <p>_Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), Reverts when dividing by zero.</p> <p>Counterpart to Solidity's <code>%</code> operator. This function uses a <code>revert</code> opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas).</p> <p>Requirements: - The divisor cannot be zero._</p>"},{"location":"#mod_1","title":"mod","text":"<pre><code>function mod(uint256 a, uint256 b, string errorMessage) internal pure returns (uint256)\n</code></pre> <p>_Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), Reverts with custom message when dividing by zero.</p> <p>Counterpart to Solidity's <code>%</code> operator. This function uses a <code>revert</code> opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas).</p> <p>Requirements: - The divisor cannot be zero._</p>"},{"location":"#address","title":"Address","text":""},{"location":"#iscontract_1","title":"isContract","text":"<pre><code>function isContract(address account) internal view returns (bool)\n</code></pre> <p>_Returns true if <code>account</code> is a contract.</p>"},{"location":"#important","title":"[IMPORTANT]","text":"<p>It is unsafe to assume that an address for which this function returns false is an externally-owned account (EOA) and not a contract.</p> <p>Among others, <code>isContract</code> will return false for the following types of addresses:</p> <ul> <li>an externally-owned account</li> <li>a contract in construction</li> <li>an address where a contract will be created</li> <li>an address where a contract lived, but was destroyed ====_</li> </ul>"},{"location":"#sendvalue","title":"sendValue","text":"<pre><code>function sendValue(address payable recipient, uint256 amount) internal\n</code></pre> <p>_Replacement for Solidity's <code>transfer</code>: sends <code>amount</code> wei to <code>recipient</code>, forwarding all available gas and reverting on errors.</p> <p>https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost of certain opcodes, possibly making contracts go over the 2300 gas limit imposed by <code>transfer</code>, making them unable to receive funds via <code>transfer</code>. {sendValue} removes this limitation.</p> <p>https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].</p> <p>IMPORTANT: because control is transferred to <code>recipient</code>, care must be taken to not create reentrancy vulnerabilities. Consider using {ReentrancyGuard} or the https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern]._</p>"},{"location":"#safeerc20","title":"SafeERC20","text":"<p>Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a <code>using SafeERC20 for IERC20;</code> statement to your contract, which allows you to call the safe operations as <code>token.safeTransfer(...)</code>, etc.</p>"},{"location":"#safetransfer","title":"safeTransfer","text":"<pre><code>function safeTransfer(contract IERC20 token, address to, uint256 value) internal\n</code></pre>"},{"location":"#safetransferfrom","title":"safeTransferFrom","text":"<pre><code>function safeTransferFrom(contract IERC20 token, address from, address to, uint256 value) internal\n</code></pre>"},{"location":"#safeapprove","title":"safeApprove","text":"<pre><code>function safeApprove(contract IERC20 token, address spender, uint256 value) internal\n</code></pre>"},{"location":"#calloptionalreturn","title":"callOptionalReturn","text":"<pre><code>function callOptionalReturn(contract IERC20 token, bytes data) private\n</code></pre>"},{"location":"#clonefactory","title":"CloneFactory","text":""},{"location":"#createclone","title":"createClone","text":"<pre><code>function createClone(address target) internal returns (address result)\n</code></pre>"},{"location":"#isclone","title":"isClone","text":"<pre><code>function isClone(address target, address query) internal view returns (bool result)\n</code></pre>"},{"location":"#epochlibrary","title":"EpochLibrary","text":"<p>Implementation of Epoch Library.      For an arbitrary Epoch, this library manages the life      cycle of an Epoch. Usually this library is used for       handling the time window between conditions in an agreement.</p>"},{"location":"#epoch","title":"Epoch","text":"<pre><code>struct Epoch {\n  uint256 timeLock;\n  uint256 timeOut;\n  uint256 blockNumber;\n}\n</code></pre>"},{"location":"#epochlist_1","title":"EpochList","text":"<pre><code>struct EpochList {\n  mapping(bytes32 &amp;#x3D;&amp;gt; struct EpochLibrary.Epoch) epochs;\n  bytes32[] epochIds;\n}\n</code></pre>"},{"location":"#create_2","title":"create","text":"<pre><code>function create(struct EpochLibrary.EpochList _self, bytes32 _id, uint256 _timeLock, uint256 _timeOut) internal\n</code></pre> <p>create creates new Epoch</p> Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 _timeLock uint256 value in block count (can not fulfill before) _timeOut uint256 value in block count (can not fulfill after)"},{"location":"#istimedout","title":"isTimedOut","text":"<pre><code>function isTimedOut(struct EpochLibrary.EpochList _self, bytes32 _id) external view returns (bool)\n</code></pre> <p>isTimedOut means you cannot fulfill after</p> Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 Name Type Description [0] bool true if the current block number is gt timeOut"},{"location":"#istimelocked","title":"isTimeLocked","text":"<pre><code>function isTimeLocked(struct EpochLibrary.EpochList _self, bytes32 _id) external view returns (bool)\n</code></pre> <p>isTimeLocked means you cannot fulfill before</p> Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 Name Type Description [0] bool true if the current block number is gt timeLock"},{"location":"#getepochtimeout","title":"getEpochTimeOut","text":"<pre><code>function getEpochTimeOut(struct EpochLibrary.Epoch _self) public view returns (uint256)\n</code></pre> <p>getEpochTimeOut</p> Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer"},{"location":"#getepochtimelock","title":"getEpochTimeLock","text":"<pre><code>function getEpochTimeLock(struct EpochLibrary.Epoch _self) public view returns (uint256)\n</code></pre> <p>getEpochTimeLock</p> Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer"},{"location":"#hashlistlibrary","title":"HashListLibrary","text":"<p>Implementation of the basic functionality of list of hash values. This library allows other contracts to build and maintain lists and also preserves the privacy of the data by accepting only hashed  content (bytes32 based data type)</p>"},{"location":"#list","title":"List","text":"<pre><code>struct List {\n  address _owner;\n  bytes32[] values;\n  mapping(bytes32 &amp;#x3D;&amp;gt; uint256) indices;\n}\n</code></pre>"},{"location":"#onlylistowner","title":"onlyListOwner","text":"<pre><code>modifier onlyListOwner(struct HashListLibrary.List _self)\n</code></pre>"},{"location":"#add_3","title":"add","text":"<pre><code>function add(struct HashListLibrary.List _self, bytes32 value) public returns (bool)\n</code></pre> <p>add index an element then add it to a list</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is a bytes32 value Name Type Description [0] bool true if value is added successfully"},{"location":"#add_4","title":"add","text":"<pre><code>function add(struct HashListLibrary.List _self, bytes32[] values) public returns (bool)\n</code></pre> <p>put an array of elements without indexing      this meant to save gas in case of large arrays</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage values bytes32[] is an array of elements value Name Type Description [0] bool true if values are added successfully"},{"location":"#update_1","title":"update","text":"<pre><code>function update(struct HashListLibrary.List _self, bytes32 oldValue, bytes32 newValue) public returns (bool)\n</code></pre> <p>update the value with a new value and maintain indices</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage oldValue bytes32 is an element value in a list newValue bytes32 new value Name Type Description [0] bool true if value is updated successfully"},{"location":"#remove_1","title":"remove","text":"<pre><code>function remove(struct HashListLibrary.List _self, bytes32 value) public returns (bool)\n</code></pre> <p>remove value from a list, updates indices, and list size</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is an element value in a list Name Type Description [0] bool true if value is removed successfully"},{"location":"#get_1","title":"get","text":"<pre><code>function get(struct HashListLibrary.List _self, uint256 __index) public view returns (bytes32)\n</code></pre> <p>has value by index</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage __index uint256 is where is value is stored in the list Name Type Description [0] bytes32 the value if exists"},{"location":"#index_1","title":"index","text":"<pre><code>function index(struct HashListLibrary.List _self, uint256 from, uint256 to) public returns (bool)\n</code></pre> <p>index is used to map each element value to its index on the list</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Name Type Description [0] bool true if the sub list is indexed"},{"location":"#setowner","title":"setOwner","text":"<pre><code>function setOwner(struct HashListLibrary.List _self, address _owner) public\n</code></pre> <p>setOwner set list owner param _owner owner address</p>"},{"location":"#indexof_1","title":"indexOf","text":"<pre><code>function indexOf(struct HashListLibrary.List _self, bytes32 value) public view returns (uint256)\n</code></pre> <p>indexOf gets the index of a value in a list</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Name Type Description [0] uint256 value index in list"},{"location":"#isindexed_1","title":"isIndexed","text":"<pre><code>function isIndexed(struct HashListLibrary.List _self) public view returns (bool)\n</code></pre> <p>isIndexed checks if the list is indexed</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] bool true if the list is indexed"},{"location":"#all_1","title":"all","text":"<pre><code>function all(struct HashListLibrary.List _self) public view returns (bytes32[])\n</code></pre> <p>all returns all list elements</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] bytes32[] all list elements"},{"location":"#has_4","title":"has","text":"<pre><code>function has(struct HashListLibrary.List _self, bytes32 value) public view returns (bool)\n</code></pre> <p>size returns the list size</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Name Type Description [0] bool true if the value exists"},{"location":"#size_1","title":"size","text":"<pre><code>function size(struct HashListLibrary.List _self) public view returns (uint256)\n</code></pre> <p>size gets the list size</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] uint256 total length of the list"},{"location":"#ownedby_1","title":"ownedBy","text":"<pre><code>function ownedBy(struct HashListLibrary.List _self) public view returns (address)\n</code></pre> <p>ownedBy gets the list owner</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] address list owner"},{"location":"#_index","title":"_index","text":"<pre><code>function _index(struct HashListLibrary.List _self, uint256 from, uint256 to) private returns (bool)\n</code></pre> <p>__index assign index to the list elements_</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 is the starting index id to uint256 is the ending index id"},{"location":"#abstractauction","title":"AbstractAuction","text":""},{"location":"#auction_manager_role","title":"AUCTION_MANAGER_ROLE","text":"<pre><code>bytes32 AUCTION_MANAGER_ROLE\n</code></pre>"},{"location":"#nvm_agreement_role","title":"NVM_AGREEMENT_ROLE","text":"<pre><code>bytes32 NVM_AGREEMENT_ROLE\n</code></pre>"},{"location":"#auction","title":"Auction","text":"<pre><code>struct Auction {\n  bytes32 did;\n  enum IDynamicPricing.DynamicPricingState state;\n  address creator;\n  uint256 blockNumberCreated;\n  uint256 floor;\n  uint256 starts;\n  uint256 ends;\n  uint256 price;\n  address tokenAddress;\n  address whoCanClaim;\n  string hash;\n}\n</code></pre>"},{"location":"#auctions","title":"auctions","text":"<pre><code>mapping(bytes32 =&gt; struct AbstractAuction.Auction) auctions\n</code></pre>"},{"location":"#auctionbids","title":"auctionBids","text":"<pre><code>mapping(bytes32 =&gt; mapping(address =&gt; uint256)) auctionBids\n</code></pre>"},{"location":"#auctioncreated","title":"AuctionCreated","text":"<pre><code>event AuctionCreated(bytes32 auctionId, bytes32 did, address creator, uint256 blockNumberCreated, uint256 floor, uint256 starts, uint256 ends, address tokenAddress)\n</code></pre>"},{"location":"#auctionchangedstate","title":"AuctionChangedState","text":"<pre><code>event AuctionChangedState(bytes32 auctionId, address who, enum IDynamicPricing.DynamicPricingState previousState, enum IDynamicPricing.DynamicPricingState newState)\n</code></pre>"},{"location":"#auctionbidreceived","title":"AuctionBidReceived","text":"<pre><code>event AuctionBidReceived(bytes32 auctionId, address bidder, address tokenAddress, uint256 amount)\n</code></pre>"},{"location":"#auctionwithdrawal","title":"AuctionWithdrawal","text":"<pre><code>event AuctionWithdrawal(bytes32 auctionId, address receiver, address tokenAddress, uint256 amount)\n</code></pre>"},{"location":"#receive_3","title":"receive","text":"<pre><code>receive() external payable\n</code></pre>"},{"location":"#abortauction","title":"abortAuction","text":"<pre><code>function abortAuction(bytes32 _auctionId) external virtual\n</code></pre>"},{"location":"#withdraw_3","title":"withdraw","text":"<pre><code>function withdraw(bytes32 _auctionId, address _withdrawAddress) external virtual returns (bool)\n</code></pre>"},{"location":"#getpricingtype_1","title":"getPricingType","text":"<pre><code>function getPricingType() external pure virtual returns (bytes32)\n</code></pre>"},{"location":"#getprice_1","title":"getPrice","text":"<pre><code>function getPrice(bytes32 _auctionId) external view returns (uint256)\n</code></pre>"},{"location":"#gettokenaddress_1","title":"getTokenAddress","text":"<pre><code>function getTokenAddress(bytes32 _auctionId) external view returns (address)\n</code></pre>"},{"location":"#getstatus_1","title":"getStatus","text":"<pre><code>function getStatus(bytes32 _auctionId) external view returns (enum IDynamicPricing.DynamicPricingState state, uint256 price, address whoCanClaim)\n</code></pre>"},{"location":"#canbepurchased_1","title":"canBePurchased","text":"<pre><code>function canBePurchased(bytes32 _auctionId) external view virtual returns (bool)\n</code></pre>"},{"location":"#addnvmagreementrole","title":"addNVMAgreementRole","text":"<pre><code>function addNVMAgreementRole(address account) public\n</code></pre>"},{"location":"#onlycreator","title":"onlyCreator","text":"<pre><code>modifier onlyCreator(bytes32 _auctionId)\n</code></pre>"},{"location":"#onlycreatororadmin","title":"onlyCreatorOrAdmin","text":"<pre><code>modifier onlyCreatorOrAdmin(bytes32 _auctionId)\n</code></pre>"},{"location":"#onlynotcreator","title":"onlyNotCreator","text":"<pre><code>modifier onlyNotCreator(bytes32 _auctionId)\n</code></pre>"},{"location":"#onlyafterstart","title":"onlyAfterStart","text":"<pre><code>modifier onlyAfterStart(bytes32 _auctionId)\n</code></pre>"},{"location":"#onlybeforestarts","title":"onlyBeforeStarts","text":"<pre><code>modifier onlyBeforeStarts(bytes32 _auctionId)\n</code></pre>"},{"location":"#onlybeforeend","title":"onlyBeforeEnd","text":"<pre><code>modifier onlyBeforeEnd(bytes32 _auctionId)\n</code></pre>"},{"location":"#onlynotabortedorfinished","title":"onlyNotAbortedOrFinished","text":"<pre><code>modifier onlyNotAbortedOrFinished(bytes32 _auctionId)\n</code></pre>"},{"location":"#onlyabortedorfinished","title":"onlyAbortedOrFinished","text":"<pre><code>modifier onlyAbortedOrFinished(bytes32 _auctionId)\n</code></pre>"},{"location":"#onlynotaborted","title":"onlyNotAborted","text":"<pre><code>modifier onlyNotAborted(bytes32 _auctionId)\n</code></pre>"},{"location":"#onlyfinishedoraborted","title":"onlyFinishedOrAborted","text":"<pre><code>modifier onlyFinishedOrAborted(bytes32 _auctionId)\n</code></pre>"},{"location":"#dutchauction","title":"DutchAuction","text":""},{"location":"#initialize_32","title":"initialize","text":"<pre><code>function initialize(address _owner) external\n</code></pre> <p>initialize init the contract with the following parameters</p> Name Type Description _owner address contract's owner account address"},{"location":"#create_3","title":"create","text":"<pre><code>function create(bytes32 _auctionId, bytes32 _did, uint256 _startPrice, uint256 _starts, uint256 _ends, address _tokenAddress, string _hash) external virtual\n</code></pre> <p>It creates a new Auction given some setup parameters</p> Name Type Description _auctionId bytes32 unique auction identifier _did bytes32 reference to the asset part of the auction _startPrice uint256 start price (and max) for the auction _starts uint256 block number when the auction starts _ends uint256 block number of when the auction ends _tokenAddress address token address to use for the auction. If address(0) means native token _hash string ipfs hash referring to the auction metadata"},{"location":"#placenativetokenbid","title":"placeNativeTokenBid","text":"<pre><code>function placeNativeTokenBid(bytes32 _auctionId) external payable virtual\n</code></pre>"},{"location":"#placeerc20bid","title":"placeERC20Bid","text":"<pre><code>function placeERC20Bid(bytes32 _auctionId, uint256 _bidAmount) external virtual\n</code></pre>"},{"location":"#withdraw_4","title":"withdraw","text":"<pre><code>function withdraw(bytes32 _auctionId, address _withdrawAddress) external virtual returns (bool)\n</code></pre>"},{"location":"#getpricingtype_2","title":"getPricingType","text":"<pre><code>function getPricingType() external pure returns (bytes32)\n</code></pre>"},{"location":"#englishauction","title":"EnglishAuction","text":""},{"location":"#initialize_33","title":"initialize","text":"<pre><code>function initialize(address _owner) external\n</code></pre> <p>initialize init the contract with the following parameters</p> Name Type Description _owner address contract's owner account address"},{"location":"#create_4","title":"create","text":"<pre><code>function create(bytes32 _auctionId, bytes32 _did, uint256 _floor, uint256 _starts, uint256 _ends, address _tokenAddress, string _hash) external virtual\n</code></pre> <p>It creates a new Auction given some setup parameters</p> Name Type Description _auctionId bytes32 unique auction identifier _did bytes32 reference to the asset part of the auction _floor uint256 floor price _starts uint256 block number when the auction starts _ends uint256 block number of when the auction ends _tokenAddress address token address to use for the auction. If address(0) means native token _hash string ipfs hash referring to the auction metadata"},{"location":"#placenativetokenbid_1","title":"placeNativeTokenBid","text":"<pre><code>function placeNativeTokenBid(bytes32 _auctionId) external payable virtual\n</code></pre>"},{"location":"#placeerc20bid_1","title":"placeERC20Bid","text":"<pre><code>function placeERC20Bid(bytes32 _auctionId, uint256 _bidAmount) external virtual\n</code></pre>"},{"location":"#getpricingtype_3","title":"getPricingType","text":"<pre><code>function getPricingType() external pure returns (bytes32)\n</code></pre>"},{"location":"#didfactory","title":"DIDFactory","text":"<p>Implementation of the DID Registry.</p>"},{"location":"#didregisterlist","title":"didRegisterList","text":"<pre><code>struct DIDRegistryLibrary.DIDRegisterList didRegisterList\n</code></pre> <p>state storage for the DID registry</p>"},{"location":"#didpermissions","title":"didPermissions","text":"<pre><code>mapping(bytes32 =&gt; mapping(address =&gt; bool)) didPermissions\n</code></pre>"},{"location":"#manager","title":"manager","text":"<pre><code>address manager\n</code></pre>"},{"location":"#onlydidowner","title":"onlyDIDOwner","text":"<pre><code>modifier onlyDIDOwner(bytes32 _did)\n</code></pre>"},{"location":"#onlymanager","title":"onlyManager","text":"<pre><code>modifier onlyManager()\n</code></pre>"},{"location":"#onlyownerproviderordelegated","title":"onlyOwnerProviderOrDelegated","text":"<pre><code>modifier onlyOwnerProviderOrDelegated(bytes32 _did)\n</code></pre>"},{"location":"#onlyvalidattributes","title":"onlyValidAttributes","text":"<pre><code>modifier onlyValidAttributes(string _attributes)\n</code></pre>"},{"location":"#nftisinitialized","title":"nftIsInitialized","text":"<pre><code>modifier nftIsInitialized(bytes32 _did)\n</code></pre>"},{"location":"#nft721isinitialized","title":"nft721IsInitialized","text":"<pre><code>modifier nft721IsInitialized(bytes32 _did)\n</code></pre>"},{"location":"#didattributeregistered","title":"DIDAttributeRegistered","text":"<pre><code>event DIDAttributeRegistered(bytes32 _did, address _owner, bytes32 _checksum, string _value, address _lastUpdatedBy, uint256 _blockNumberUpdated)\n</code></pre> <p>DID Events</p>"},{"location":"#didproviderremoved","title":"DIDProviderRemoved","text":"<pre><code>event DIDProviderRemoved(bytes32 _did, address _provider, bool state)\n</code></pre>"},{"location":"#didprovideradded","title":"DIDProviderAdded","text":"<pre><code>event DIDProviderAdded(bytes32 _did, address _provider)\n</code></pre>"},{"location":"#didownershiptransferred","title":"DIDOwnershipTransferred","text":"<pre><code>event DIDOwnershipTransferred(bytes32 _did, address _previousOwner, address _newOwner)\n</code></pre>"},{"location":"#didpermissiongranted","title":"DIDPermissionGranted","text":"<pre><code>event DIDPermissionGranted(bytes32 _did, address _owner, address _grantee)\n</code></pre>"},{"location":"#didpermissionrevoked","title":"DIDPermissionRevoked","text":"<pre><code>event DIDPermissionRevoked(bytes32 _did, address _owner, address _grantee)\n</code></pre>"},{"location":"#didprovenancedelegateremoved","title":"DIDProvenanceDelegateRemoved","text":"<pre><code>event DIDProvenanceDelegateRemoved(bytes32 _did, address _delegate, bool state)\n</code></pre>"},{"location":"#didprovenancedelegateadded","title":"DIDProvenanceDelegateAdded","text":"<pre><code>event DIDProvenanceDelegateAdded(bytes32 _did, address _delegate)\n</code></pre>"},{"location":"#setmanager","title":"setManager","text":"<pre><code>function setManager(address _addr) external\n</code></pre> <p>Sets the manager role. Should be the TransferCondition contract address</p>"},{"location":"#registerattribute","title":"registerAttribute","text":"<pre><code>function registerAttribute(bytes32 _didSeed, bytes32 _checksum, address[] _providers, string _url) public virtual\n</code></pre> <p>Register DID attributes.</p> <p>The first attribute of a DID registered sets the DID owner.      Subsequent updates record _checksum and update info.</p> Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] _url string refers to the attribute value, limited to 2048 bytes."},{"location":"#registerdid","title":"registerDID","text":"<pre><code>function registerDID(bytes32 _didSeed, bytes32 _checksum, address[] _providers, string _url, bytes32 _activityId, string _attributes) public virtual\n</code></pre> <p>Register DID attributes.</p> <p>The first attribute of a DID registered sets the DID owner.      Subsequent updates record _checksum and update info.</p> Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID).           The final DID will be calculated with the creator address using the <code>hashDID</code> function _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _activityId bytes32 refers to activity _attributes string refers to the provenance attributes"},{"location":"#hashdid","title":"hashDID","text":"<pre><code>function hashDID(bytes32 _didSeed, address _creator) public pure returns (bytes32)\n</code></pre> <p>It generates a DID using as seed a bytes32 and the address of the DID creator</p> Name Type Description _didSeed bytes32 refers to DID Seed used as base to generate the final DID _creator address address of the creator of the DID Name Type Description [0] bytes32 the new DID created"},{"location":"#areroyaltiesvalid","title":"areRoyaltiesValid","text":"<pre><code>function areRoyaltiesValid(bytes32 _did, uint256[] _amounts, address[] _receivers, address _tokenAddress) public view returns (bool)\n</code></pre> <p>areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly</p> Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards _tokenAddress address Name Type Description [0] bool true if the rewards distribution respect the original creator royalties"},{"location":"#wasgeneratedby","title":"wasGeneratedBy","text":"<pre><code>function wasGeneratedBy(bytes32 _provId, bytes32 _did, address _agentId, bytes32 _activityId, string _attributes) internal returns (bool)\n</code></pre>"},{"location":"#used","title":"used","text":"<pre><code>function used(bytes32 _provId, bytes32 _did, address _agentId, bytes32 _activityId, bytes _signatureUsing, string _attributes) public returns (bool success)\n</code></pre>"},{"location":"#wasderivedfrom","title":"wasDerivedFrom","text":"<pre><code>function wasDerivedFrom(bytes32 _provId, bytes32 _newEntityDid, bytes32 _usedEntityDid, address _agentId, bytes32 _activityId, string _attributes) public returns (bool success)\n</code></pre>"},{"location":"#wasassociatedwith","title":"wasAssociatedWith","text":"<pre><code>function wasAssociatedWith(bytes32 _provId, bytes32 _did, address _agentId, bytes32 _activityId, string _attributes) public returns (bool success)\n</code></pre>"},{"location":"#actedonbehalf","title":"actedOnBehalf","text":"<pre><code>function actedOnBehalf(bytes32 _provId, bytes32 _did, address _delegateAgentId, address _responsibleAgentId, bytes32 _activityId, bytes _signatureDelegate, string _attributes) public returns (bool success)\n</code></pre> <p>Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId &amp; _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId)</p> Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered"},{"location":"#adddidprovider","title":"addDIDProvider","text":"<pre><code>function addDIDProvider(bytes32 _did, address _provider) external\n</code></pre> <p>addDIDProvider add new DID provider.</p> <p>it adds new DID provider to the providers list. A provider      is any entity that can serve the registered asset</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address."},{"location":"#removedidprovider","title":"removeDIDProvider","text":"<pre><code>function removeDIDProvider(bytes32 _did, address _provider) external\n</code></pre> <p>removeDIDProvider delete an existing DID provider.</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address."},{"location":"#adddidprovenancedelegate","title":"addDIDProvenanceDelegate","text":"<pre><code>function addDIDProvenanceDelegate(bytes32 _did, address _delegate) public\n</code></pre> <p>addDIDProvenanceDelegate add new DID provenance delegate.</p> <p>it adds new DID provenance delegate to the delegates list.  A delegate is any entity that interact with the provenance entries of one DID</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegates's address."},{"location":"#removedidprovenancedelegate","title":"removeDIDProvenanceDelegate","text":"<pre><code>function removeDIDProvenanceDelegate(bytes32 _did, address _delegate) external\n</code></pre> <p>removeDIDProvenanceDelegate delete an existing DID delegate.</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address."},{"location":"#transferdidownership","title":"transferDIDOwnership","text":"<pre><code>function transferDIDOwnership(bytes32 _did, address _newOwner) external\n</code></pre> <p>transferDIDOwnership transfer DID ownership</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address"},{"location":"#transferdidownershipmanaged","title":"transferDIDOwnershipManaged","text":"<pre><code>function transferDIDOwnershipManaged(address _sender, bytes32 _did, address _newOwner) external\n</code></pre> <p>transferDIDOwnershipManaged transfer DID ownership</p> Name Type Description _sender address _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address"},{"location":"#_transferdidownership","title":"_transferDIDOwnership","text":"<pre><code>function _transferDIDOwnership(address _sender, bytes32 _did, address _newOwner) internal\n</code></pre>"},{"location":"#grantpermission_3","title":"grantPermission","text":"<pre><code>function grantPermission(bytes32 _did, address _grantee) external\n</code></pre> <p>grantPermission grants access permission to grantee</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address"},{"location":"#revokepermission","title":"revokePermission","text":"<pre><code>function revokePermission(bytes32 _did, address _grantee) external\n</code></pre> <p>revokePermission revokes access permission from grantee</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address"},{"location":"#getpermission","title":"getPermission","text":"<pre><code>function getPermission(bytes32 _did, address _grantee) external view returns (bool)\n</code></pre> <p>getPermission gets access permission of a grantee</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Name Type Description [0] bool true if grantee has access permission to a DID"},{"location":"#isdidprovider","title":"isDIDProvider","text":"<pre><code>function isDIDProvider(bytes32 _did, address _provider) public view returns (bool)\n</code></pre> <p>isDIDProvider check whether a given DID provider exists</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address."},{"location":"#isdidproviderorowner","title":"isDIDProviderOrOwner","text":"<pre><code>function isDIDProviderOrOwner(bytes32 _did, address _provider) public view returns (bool)\n</code></pre>"},{"location":"#getdidregister","title":"getDIDRegister","text":"<pre><code>function getDIDRegister(bytes32 _did) public view returns (address owner, bytes32 lastChecksum, string url, address lastUpdatedBy, uint256 blockNumberUpdated, address[] providers, uint256 nftSupply, uint256 mintCap, uint256 royalties)\n</code></pre> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description owner address the did owner lastChecksum bytes32 last checksum url string URL to the DID metadata lastUpdatedBy address who was the last updating the DID blockNumberUpdated uint256 In which block was the DID updated providers address[] the list of providers nftSupply uint256 the supply of nfts mintCap uint256 the maximum number of nfts that can be minted royalties uint256 the royalties amount"},{"location":"#getdidsupply","title":"getDIDSupply","text":"<pre><code>function getDIDSupply(bytes32 _did) public view returns (uint256 nftSupply, uint256 mintCap)\n</code></pre>"},{"location":"#getblocknumberupdated","title":"getBlockNumberUpdated","text":"<pre><code>function getBlockNumberUpdated(bytes32 _did) public view returns (uint256 blockNumberUpdated)\n</code></pre> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description blockNumberUpdated uint256 last modified (update) block number of a DID."},{"location":"#getdidowner","title":"getDIDOwner","text":"<pre><code>function getDIDOwner(bytes32 _did) public view returns (address didOwner)\n</code></pre> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description didOwner address the address of the DID owner."},{"location":"#getdidroyaltyrecipient","title":"getDIDRoyaltyRecipient","text":"<pre><code>function getDIDRoyaltyRecipient(bytes32 _did) public view returns (address)\n</code></pre>"},{"location":"#getdidroyaltyscheme","title":"getDIDRoyaltyScheme","text":"<pre><code>function getDIDRoyaltyScheme(bytes32 _did) public view returns (address)\n</code></pre>"},{"location":"#getdidcreator","title":"getDIDCreator","text":"<pre><code>function getDIDCreator(bytes32 _did) public view returns (address)\n</code></pre>"},{"location":"#_grantpermission","title":"_grantPermission","text":"<pre><code>function _grantPermission(bytes32 _did, address _grantee) internal\n</code></pre> <p>__grantPermission grants access permission to grantee_</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address"},{"location":"#_revokepermission","title":"_revokePermission","text":"<pre><code>function _revokePermission(bytes32 _did, address _grantee) internal\n</code></pre> <p>__revokePermission revokes access permission from grantee_</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address"},{"location":"#_getpermission","title":"_getPermission","text":"<pre><code>function _getPermission(bytes32 _did, address _grantee) internal view returns (bool)\n</code></pre> <p>__getPermission gets access permission of a grantee_</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Name Type Description [0] bool true if grantee has access permission to a DID"},{"location":"#getprovenanceentry","title":"getProvenanceEntry","text":"<pre><code>function getProvenanceEntry(bytes32 _provId) public view returns (bytes32 did, bytes32 relatedDid, address agentId, bytes32 activityId, address agentInvolvedId, uint8 method, address createdBy, uint256 blockNumberUpdated, bytes signature)\n</code></pre> <p>Fetch the complete provenance entry attributes</p> Name Type Description _provId bytes32 refers to the provenance identifier Name Type Description did bytes32 to what DID refers this entry relatedDid bytes32 DID related with the entry agentId address the agent identifier activityId bytes32 referring to the id of the activity agentInvolvedId address agent involved with the action method uint8 the w3c provenance method createdBy address who is creating this entry blockNumberUpdated uint256 in which block was updated signature bytes digital signature"},{"location":"#isdidowner","title":"isDIDOwner","text":"<pre><code>function isDIDOwner(address _address, bytes32 _did) public view returns (bool)\n</code></pre> <p>isDIDOwner check whether a given address is owner for a DID</p> Name Type Description _address address user address. _did bytes32 refers to decentralized identifier (a bytes32 length ID)."},{"location":"#isownerproviderordelegate","title":"isOwnerProviderOrDelegate","text":"<pre><code>function isOwnerProviderOrDelegate(bytes32 _did) public view returns (bool)\n</code></pre> <p>isOwnerProviderOrDelegate check whether msg.sender is owner, provider or delegate for a DID given</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description [0] bool boolean true if yes"},{"location":"#isprovenancedelegate","title":"isProvenanceDelegate","text":"<pre><code>function isProvenanceDelegate(bytes32 _did, address _delegate) public view returns (bool)\n</code></pre> <p>isProvenanceDelegate check whether a given DID delegate exists</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address. Name Type Description [0] bool boolean true if yes"},{"location":"#getprovenanceowner","title":"getProvenanceOwner","text":"<pre><code>function getProvenanceOwner(bytes32 _did) public view returns (address provenanceOwner)\n</code></pre> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description provenanceOwner address the address of the Provenance owner."},{"location":"#didregistry_7","title":"DIDRegistry","text":"<p>Implementation of a Mintable DID Registry.</p>"},{"location":"#erc1155_3","title":"erc1155","text":"<pre><code>contract NFTUpgradeable erc1155\n</code></pre>"},{"location":"#erc721_1","title":"erc721","text":"<pre><code>contract NFT721Upgradeable erc721\n</code></pre>"},{"location":"#royaltiescheckers","title":"royaltiesCheckers","text":"<pre><code>mapping(address =&gt; bool) royaltiesCheckers\n</code></pre>"},{"location":"#initialize_34","title":"initialize","text":"<pre><code>function initialize(address _owner, address _erc1155, address _erc721) public\n</code></pre> <p>DIDRegistry Initializer      Initialize Ownable. Only on contract creation.</p> Name Type Description _owner address refers to the owner of the contract. _erc1155 address _erc721 address"},{"location":"#registerroyaltieschecker","title":"registerRoyaltiesChecker","text":"<pre><code>function registerRoyaltiesChecker(address _addr) public\n</code></pre>"},{"location":"#didroyaltiesadded","title":"DIDRoyaltiesAdded","text":"<pre><code>event DIDRoyaltiesAdded(bytes32 did, address addr)\n</code></pre>"},{"location":"#didroyaltyrecipientchanged","title":"DIDRoyaltyRecipientChanged","text":"<pre><code>event DIDRoyaltyRecipientChanged(bytes32 did, address addr)\n</code></pre>"},{"location":"#setdidroyalties","title":"setDIDRoyalties","text":"<pre><code>function setDIDRoyalties(bytes32 _did, address _royalties) public\n</code></pre>"},{"location":"#setdidroyaltyrecipient","title":"setDIDRoyaltyRecipient","text":"<pre><code>function setDIDRoyaltyRecipient(bytes32 _did, address _recipient) public\n</code></pre>"},{"location":"#registermintabledid","title":"registerMintableDID","text":"<pre><code>function registerMintableDID(bytes32 _didSeed, bytes32 _checksum, address[] _providers, string _url, uint256 _cap, uint8 _royalties, bool _mint, bytes32 _activityId, string _nftMetadata) public\n</code></pre> <p>Register a Mintable DID using NFTs based in the ERC-1155 standard.</p> <p>The first attribute of a DID registered sets the DID owner.      Subsequent updates record _checksum and update info.</p> Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if true it mints the ERC-1155 NFTs attached to the asset _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata"},{"location":"#registermintabledid721","title":"registerMintableDID721","text":"<pre><code>function registerMintableDID721(bytes32 _didSeed, bytes32 _checksum, address[] _providers, string _url, uint8 _royalties, bool _mint, bytes32 _activityId, string _nftMetadata) public\n</code></pre> <p>Register a Mintable DID using NFTs based in the ERC-721 standard.</p> <p>The first attribute of a DID registered sets the DID owner.      Subsequent updates record _checksum and update info.</p> Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if true it mints the ERC-1155 NFTs attached to the asset _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata"},{"location":"#registermintabledid_1","title":"registerMintableDID","text":"<pre><code>function registerMintableDID(bytes32 _didSeed, bytes32 _checksum, address[] _providers, string _url, uint256 _cap, uint8 _royalties, bytes32 _activityId, string _nftMetadata) public\n</code></pre> <p>Register a Mintable DID.</p> <p>The first attribute of a DID registered sets the DID owner.      Subsequent updates record _checksum and update info.</p> Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata"},{"location":"#enableandmintdidnft","title":"enableAndMintDidNft","text":"<pre><code>function enableAndMintDidNft(bytes32 _did, uint256 _cap, uint8 _royalties, bool _mint, string _nftMetadata) public returns (bool success)\n</code></pre> <p>enableDidNft creates the initial setup of NFTs minting and royalties distribution for ERC-1155 NFTs. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the  valuation of NFTs of a DID already created.</p> <p>update the DID registry providers list by adding the mintCap and royalties configuration</p> Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if is true mint directly the amount capped tokens and lock in the _lockAddress _nftMetadata string refers to the url providing the NFT Metadata"},{"location":"#enableandmintdidnft721","title":"enableAndMintDidNft721","text":"<pre><code>function enableAndMintDidNft721(bytes32 _did, uint8 _royalties, bool _mint, string _nftMetadata) public returns (bool success)\n</code></pre> <p>enableAndMintDidNft721 creates the initial setup of NFTs minting and royalties distribution for ERC-721 NFTs. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the  valuation of NFTs of a DID already created.</p> <p>update the DID registry providers list by adding the mintCap and royalties configuration</p> Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if is true mint directly the amount capped tokens and lock in the _lockAddress _nftMetadata string refers to the url providing the NFT Metadata"},{"location":"#mint_3","title":"mint","text":"<pre><code>function mint(bytes32 _did, uint256 _amount, address _receiver) public\n</code></pre> <p>Mints a NFT associated to the DID</p> <p>Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both      Only the DID owner can mint NFTs associated to the DID</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to mint _receiver address the address that will receive the new nfts minted"},{"location":"#mint_4","title":"mint","text":"<pre><code>function mint(bytes32 _did, uint256 _amount) public\n</code></pre>"},{"location":"#mint721","title":"mint721","text":"<pre><code>function mint721(bytes32 _did, address _receiver) public\n</code></pre> <p>Mints a ERC-721 NFT associated to the DID</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _receiver address the address that will receive the new nfts minted"},{"location":"#mint721_1","title":"mint721","text":"<pre><code>function mint721(bytes32 _did) public\n</code></pre>"},{"location":"#burn_2","title":"burn","text":"<pre><code>function burn(bytes32 _did, uint256 _amount) public\n</code></pre> <p>Burns NFTs associated to the DID</p> <p>Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both      Only the DID owner can burn NFTs associated to the DID</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to burn"},{"location":"#burn721","title":"burn721","text":"<pre><code>function burn721(bytes32 _did) public\n</code></pre>"},{"location":"#didregistrylibrary","title":"DIDRegistryLibrary","text":"<p>All function calls are currently implemented without side effects</p>"},{"location":"#didregister","title":"DIDRegister","text":"<pre><code>struct DIDRegister {\n  address owner;\n  uint8 royalties;\n  bool nftInitialized;\n  bool nft721Initialized;\n  address creator;\n  bytes32 lastChecksum;\n  string url;\n  address lastUpdatedBy;\n  uint256 blockNumberUpdated;\n  address[] providers;\n  address[] delegates;\n  uint256 nftSupply;\n  uint256 mintCap;\n  address royaltyRecipient;\n  contract IRoyaltyScheme royaltyScheme;\n}\n</code></pre>"},{"location":"#didregisterlist_1","title":"DIDRegisterList","text":"<pre><code>struct DIDRegisterList {\n  mapping(bytes32 &amp;#x3D;&amp;gt; struct DIDRegistryLibrary.DIDRegister) didRegisters;\n  bytes32[] didRegisterIds;\n}\n</code></pre>"},{"location":"#update_2","title":"update","text":"<pre><code>function update(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, bytes32 _checksum, string _url) external\n</code></pre> <p>update the DID store</p> <p>access modifiers and storage pointer should be implemented in DIDRegistry</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url string includes the url resolving to the DID Document (DDO)"},{"location":"#initializenftconfig","title":"initializeNftConfig","text":"<pre><code>function initializeNftConfig(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, uint256 _cap, uint8 _royalties) internal\n</code></pre> <p>initializeNftConfig creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the  valuation of NFTs of a DID already created.</p> <p>update the DID registry providers list by adding the mintCap and royalties configuration</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market        The royalties in secondary market for the creator should be between 0% &gt;= x &lt; 100%"},{"location":"#initializenft721config","title":"initializeNft721Config","text":"<pre><code>function initializeNft721Config(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, uint8 _royalties) internal\n</code></pre>"},{"location":"#areroyaltiesvalid_1","title":"areRoyaltiesValid","text":"<pre><code>function areRoyaltiesValid(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, uint256[] _amounts, address[] _receivers, address _tokenAddress) internal view returns (bool)\n</code></pre> <p>areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards _tokenAddress address Name Type Description [0] bool true if the rewards distribution respect the original creator royalties"},{"location":"#addprovider","title":"addProvider","text":"<pre><code>function addProvider(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address provider) internal\n</code></pre> <p>addProvider add provider to DID registry</p> <p>update the DID registry providers list by adding a new provider</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address"},{"location":"#removeprovider","title":"removeProvider","text":"<pre><code>function removeProvider(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address _provider) internal returns (bool)\n</code></pre> <p>removeProvider remove provider from DID registry</p> <p>update the DID registry providers list by removing an existing provider</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address"},{"location":"#updatedidowner","title":"updateDIDOwner","text":"<pre><code>function updateDIDOwner(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address _newOwner) internal\n</code></pre> <p>updateDIDOwner transfer DID ownership to a new owner</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _newOwner address the new DID owner address"},{"location":"#isprovider","title":"isProvider","text":"<pre><code>function isProvider(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address _provider) public view returns (bool)\n</code></pre> <p>isProvider check whether DID provider exists</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address Name Type Description [0] bool true if the provider already exists"},{"location":"#getproviderindex","title":"getProviderIndex","text":"<pre><code>function getProviderIndex(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address provider) private view returns (int256)\n</code></pre> <p>getProviderIndex get the index of a provider</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address Name Type Description [0] int256 the index if the provider exists otherwise return -1"},{"location":"#adddelegate","title":"addDelegate","text":"<pre><code>function addDelegate(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address delegate) internal\n</code></pre> <p>addDelegate add delegate to DID registry</p> <p>update the DID registry delegates list by adding a new delegate</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address"},{"location":"#removedelegate","title":"removeDelegate","text":"<pre><code>function removeDelegate(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address _delegate) internal returns (bool)\n</code></pre> <p>removeDelegate remove delegate from DID registry</p> <p>update the DID registry delegates list by removing an existing delegate</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address"},{"location":"#isdelegate","title":"isDelegate","text":"<pre><code>function isDelegate(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address _delegate) public view returns (bool)\n</code></pre> <p>isDelegate check whether DID delegate exists</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address Name Type Description [0] bool true if the delegate already exists"},{"location":"#getdelegateindex","title":"getDelegateIndex","text":"<pre><code>function getDelegateIndex(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address delegate) private view returns (int256)\n</code></pre> <p>getDelegateIndex get the index of a delegate</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address Name Type Description [0] int256 the index if the delegate exists otherwise return -1"},{"location":"#provenanceregistry","title":"ProvenanceRegistry","text":"<p>All function calls are currently implemented without side effects</p>"},{"location":"#__provenanceregistry_init","title":"__ProvenanceRegistry_init","text":"<pre><code>function __ProvenanceRegistry_init() internal\n</code></pre>"},{"location":"#__provenanceregistry_init_unchained","title":"__ProvenanceRegistry_init_unchained","text":"<pre><code>function __ProvenanceRegistry_init_unchained() internal\n</code></pre>"},{"location":"#provenance","title":"Provenance","text":"<pre><code>struct Provenance {\n  bytes32 did;\n  bytes32 relatedDid;\n  address agentId;\n  bytes32 activityId;\n  address agentInvolvedId;\n  uint8 method;\n  address createdBy;\n  uint256 blockNumberUpdated;\n  bytes signature;\n}\n</code></pre>"},{"location":"#provenanceregistrylist","title":"ProvenanceRegistryList","text":"<pre><code>struct ProvenanceRegistryList {\n  mapping(bytes32 &amp;#x3D;&amp;gt; struct ProvenanceRegistry.Provenance) list;\n}\n</code></pre>"},{"location":"#provenanceregistry_1","title":"provenanceRegistry","text":"<pre><code>struct ProvenanceRegistry.ProvenanceRegistryList provenanceRegistry\n</code></pre>"},{"location":"#provenancemethod","title":"ProvenanceMethod","text":"<pre><code>enum ProvenanceMethod {\n  ENTITY,\n  ACTIVITY,\n  WAS_GENERATED_BY,\n  USED,\n  WAS_INFORMED_BY,\n  WAS_STARTED_BY,\n  WAS_ENDED_BY,\n  WAS_INVALIDATED_BY,\n  WAS_DERIVED_FROM,\n  AGENT,\n  WAS_ATTRIBUTED_TO,\n  WAS_ASSOCIATED_WITH,\n  ACTED_ON_BEHALF\n}\n</code></pre>"},{"location":"#provenanceattributeregistered","title":"ProvenanceAttributeRegistered","text":"<pre><code>event ProvenanceAttributeRegistered(bytes32 provId, bytes32 _did, address _agentId, bytes32 _activityId, bytes32 _relatedDid, address _agentInvolvedId, enum ProvenanceRegistry.ProvenanceMethod _method, string _attributes, uint256 _blockNumberUpdated)\n</code></pre> <p>Provenance Events</p>"},{"location":"#wasgeneratedby_1","title":"WasGeneratedBy","text":"<pre><code>event WasGeneratedBy(bytes32 _did, address _agentId, bytes32 _activityId, bytes32 provId, string _attributes, uint256 _blockNumberUpdated)\n</code></pre>"},{"location":"#used_1","title":"Used","text":"<pre><code>event Used(bytes32 _did, address _agentId, bytes32 _activityId, bytes32 provId, string _attributes, uint256 _blockNumberUpdated)\n</code></pre>"},{"location":"#wasderivedfrom_1","title":"WasDerivedFrom","text":"<pre><code>event WasDerivedFrom(bytes32 _newEntityDid, bytes32 _usedEntityDid, address _agentId, bytes32 _activityId, bytes32 provId, string _attributes, uint256 _blockNumberUpdated)\n</code></pre>"},{"location":"#wasassociatedwith_1","title":"WasAssociatedWith","text":"<pre><code>event WasAssociatedWith(bytes32 _entityDid, address _agentId, bytes32 _activityId, bytes32 provId, string _attributes, uint256 _blockNumberUpdated)\n</code></pre>"},{"location":"#actedonbehalf_1","title":"ActedOnBehalf","text":"<pre><code>event ActedOnBehalf(bytes32 _entityDid, address _delegateAgentId, address _responsibleAgentId, bytes32 _activityId, bytes32 provId, string _attributes, uint256 _blockNumberUpdated)\n</code></pre>"},{"location":"#createprovenanceentry","title":"createProvenanceEntry","text":"<pre><code>function createProvenanceEntry(bytes32 _provId, bytes32 _did, bytes32 _relatedDid, address _agentId, bytes32 _activityId, address _agentInvolvedId, enum ProvenanceRegistry.ProvenanceMethod _method, address _createdBy, bytes _signatureDelegate, string _attributes) internal returns (bool)\n</code></pre> <p>create an event in the Provenance store</p> <p>access modifiers and storage pointer should be implemented in ProvenanceRegistry</p> Name Type Description _provId bytes32 refers to provenance event identifier _did bytes32 refers to decentralized identifier (a byte32 length ID) _relatedDid bytes32 refers to decentralized identifier (a byte32 length ID) of a related entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _agentInvolvedId address refers to address of the agent involved with the provenance record _method enum ProvenanceRegistry.ProvenanceMethod refers to the W3C Provenance method _createdBy address refers to address of the agent triggering the activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string"},{"location":"#_wasgeneratedby","title":"_wasGeneratedBy","text":"<pre><code>function _wasGeneratedBy(bytes32 _provId, bytes32 _did, address _agentId, bytes32 _activityId, string _attributes) internal virtual returns (bool)\n</code></pre> <p>Implements the W3C PROV Generation action</p> Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description [0] bool the number of the new provenance size"},{"location":"#_used","title":"_used","text":"<pre><code>function _used(bytes32 _provId, bytes32 _did, address _agentId, bytes32 _activityId, bytes _signatureUsing, string _attributes) internal virtual returns (bool success)\n</code></pre> <p>Implements the W3C PROV Usage action</p> Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _signatureUsing bytes refers to the digital signature provided by the agent using the _did _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered"},{"location":"#_wasderivedfrom","title":"_wasDerivedFrom","text":"<pre><code>function _wasDerivedFrom(bytes32 _provId, bytes32 _newEntityDid, bytes32 _usedEntityDid, address _agentId, bytes32 _activityId, string _attributes) internal virtual returns (bool success)\n</code></pre> <p>Implements the W3C PROV Derivation action</p> Name Type Description _provId bytes32 unique identifier referring to the provenance entry _newEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _usedEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity used to derive the new did _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered"},{"location":"#_wasassociatedwith","title":"_wasAssociatedWith","text":"<pre><code>function _wasAssociatedWith(bytes32 _provId, bytes32 _did, address _agentId, bytes32 _activityId, string _attributes) internal virtual returns (bool success)\n</code></pre> <p>Implements the W3C PROV Association action</p> Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered"},{"location":"#_actedonbehalf","title":"_actedOnBehalf","text":"<pre><code>function _actedOnBehalf(bytes32 _provId, bytes32 _did, address _delegateAgentId, address _responsibleAgentId, bytes32 _activityId, bytes _signatureDelegate, string _attributes) internal virtual returns (bool success)\n</code></pre> <p>Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId &amp; _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId)</p> Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered"},{"location":"#curveroyalties","title":"CurveRoyalties","text":""},{"location":"#registry","title":"registry","text":"<pre><code>contract DIDRegistry registry\n</code></pre>"},{"location":"#denominator","title":"DENOMINATOR","text":"<pre><code>uint256 DENOMINATOR\n</code></pre>"},{"location":"#royalties","title":"royalties","text":"<pre><code>mapping(bytes32 =&gt; uint256) royalties\n</code></pre>"},{"location":"#initialize_35","title":"initialize","text":"<pre><code>function initialize(address _registry) public\n</code></pre>"},{"location":"#royaltycurve","title":"royaltyCurve","text":"<pre><code>function royaltyCurve(uint256 num, uint256 max, uint256 rate) public pure virtual returns (uint256)\n</code></pre>"},{"location":"#setroyalty","title":"setRoyalty","text":"<pre><code>function setRoyalty(bytes32 _did, uint256 _royalty) public\n</code></pre> <p>Set royalties for a DID</p> <p>Can only be called by creator of the DID</p> Name Type Description _did bytes32 DID for which the royalties are set _royalty uint256 Royalty, the actual royalty will be _royalty / 10000 percent"},{"location":"#check_1","title":"check","text":"<pre><code>function check(bytes32 _did, uint256[] _amounts, address[] _receivers, address _token) external view returns (bool)\n</code></pre>"},{"location":"#rewardsdistributor","title":"RewardsDistributor","text":""},{"location":"#used_2","title":"used","text":"<pre><code>mapping(bytes32 =&gt; bool) used\n</code></pre>"},{"location":"#receivers","title":"receivers","text":"<pre><code>mapping(bytes32 =&gt; address[]) receivers\n</code></pre>"},{"location":"#registry_1","title":"registry","text":"<pre><code>contract DIDRegistry registry\n</code></pre>"},{"location":"#conditionstoremanager_3","title":"conditionStoreManager","text":"<pre><code>contract ConditionStoreManager conditionStoreManager\n</code></pre>"},{"location":"#escrow","title":"escrow","text":"<pre><code>address escrow\n</code></pre>"},{"location":"#initialize_36","title":"initialize","text":"<pre><code>function initialize(address _registry, address _conditionStoreManager, address _escrow) public\n</code></pre>"},{"location":"#setreceivers","title":"setReceivers","text":"<pre><code>function setReceivers(bytes32 _did, address[] _addr) public\n</code></pre> <p>set receivers for did</p> Name Type Description _did bytes32 DID _addr address[] list of receivers"},{"location":"#claimreward","title":"claimReward","text":"<pre><code>function claimReward(bytes32 _agreementId, bytes32 _did, uint256[] _amounts, address[] _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) public\n</code></pre> <p>distribute rewards associated with an escrow condition</p> <p>as paramemeters, it just gets the same parameters as fulfill for escrow condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier"},{"location":"#standardroyalties","title":"StandardRoyalties","text":""},{"location":"#registry_2","title":"registry","text":"<pre><code>contract DIDRegistry registry\n</code></pre>"},{"location":"#denominator_1","title":"DENOMINATOR","text":"<pre><code>uint256 DENOMINATOR\n</code></pre>"},{"location":"#royalties_1","title":"royalties","text":"<pre><code>mapping(bytes32 =&gt; uint256) royalties\n</code></pre>"},{"location":"#initialize_37","title":"initialize","text":"<pre><code>function initialize(address _registry) public\n</code></pre>"},{"location":"#setroyalty_1","title":"setRoyalty","text":"<pre><code>function setRoyalty(bytes32 _did, uint256 _royalty) public\n</code></pre> <p>Set royalties for a DID</p> <p>Can only be called by creator of the DID</p> Name Type Description _did bytes32 DID for which the royalties are set _royalty uint256 Royalty, the actual royalty will be _royalty / 10000 percent"},{"location":"#check_2","title":"check","text":"<pre><code>function check(bytes32 _did, uint256[] _amounts, address[] _receivers, address) external view returns (bool)\n</code></pre>"},{"location":"#aavecredittemplate","title":"AaveCreditTemplate","text":"<p>Implementation of the Aaven Credit Agreement Template  0. Initialize the agreement  1. LockNFT - Delegatee locks the NFT  2. AaveCollateralDeposit - Delegator deposits the collateral into Aave. And approves the delegation flow  3. AaveBorrowCondition - The Delegatee claim the credit amount from Aave  4. AaveRepayCondition. Options:      4.a Fulfilled state - The Delegatee pay back the loan (including fee) into Aave and gets back the NFT      4.b Aborted state - The Delegatee doesn't pay the loan in time so the Delegator gets the NFT. The Delegator pays the loan to Aave  5. TransferNFT. Options:      5.a if AaveRepayCondition was fulfilled, it will allow transfer back to the Delegatee or Borrower      5.b if AaveRepayCondition was aborted, it will allow transfer the NFT to the Delegator or Lender</p>"},{"location":"#didregistry_8","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#nftlockcondition_1","title":"nftLockCondition","text":"<pre><code>contract INFTLock nftLockCondition\n</code></pre>"},{"location":"#depositcondition","title":"depositCondition","text":"<pre><code>contract AaveCollateralDepositCondition depositCondition\n</code></pre>"},{"location":"#borrowcondition","title":"borrowCondition","text":"<pre><code>contract AaveBorrowCondition borrowCondition\n</code></pre>"},{"location":"#repaycondition","title":"repayCondition","text":"<pre><code>contract AaveRepayCondition repayCondition\n</code></pre>"},{"location":"#transfercondition","title":"transferCondition","text":"<pre><code>contract DistributeNFTCollateralCondition transferCondition\n</code></pre>"},{"location":"#withdrawcondition","title":"withdrawCondition","text":"<pre><code>contract AaveCollateralWithdrawCondition withdrawCondition\n</code></pre>"},{"location":"#vaultaddress","title":"vaultAddress","text":"<pre><code>mapping(bytes32 =&gt; address) vaultAddress\n</code></pre>"},{"location":"#nvmfee_1","title":"nvmFee","text":"<pre><code>uint256 nvmFee\n</code></pre>"},{"location":"#vaultlibrary","title":"vaultLibrary","text":"<pre><code>address vaultLibrary\n</code></pre>"},{"location":"#vaultcreated","title":"VaultCreated","text":"<pre><code>event VaultCreated(address _vaultAddress, address _creator, address _lender, address _borrower)\n</code></pre>"},{"location":"#initialize_38","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _nftLockConditionAddress, address _depositConditionAddress, address _borrowConditionAddress, address _repayConditionAddress, address _withdrawCollateralAddress, address _transferConditionAddress, address _vaultLibrary) external\n</code></pre> <p>initialize init the  contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and       set push the required condition types including       access , lock payment and escrow payment conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftLockConditionAddress address NFT Lock Condition contract address _depositConditionAddress address Aave collateral deposit Condition address _borrowConditionAddress address Aave borrow deposit Condition address _repayConditionAddress address Aave repay credit Condition address _withdrawCollateralAddress address _transferConditionAddress address NFT Transfer Condition address _vaultLibrary address"},{"location":"#createvaultagreement","title":"createVaultAgreement","text":"<pre><code>function createVaultAgreement(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address _vaultAddress) public\n</code></pre>"},{"location":"#createagreement_1","title":"createAgreement","text":"<pre><code>function createAgreement(bytes32 _id, address _lendingPool, address _dataProvider, address _weth, uint256 _agreementFee, address _treasuryAddress, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address _lender) public\n</code></pre>"},{"location":"#deployvault","title":"deployVault","text":"<pre><code>function deployVault(address _lendingPool, address _dataProvider, address _weth, uint256 _agreementFee, address _treasuryAddress, address _borrower, address _lender) public returns (address)\n</code></pre>"},{"location":"#getvaultforagreement","title":"getVaultForAgreement","text":"<pre><code>function getVaultForAgreement(bytes32 _agreementId) public view returns (address)\n</code></pre>"},{"location":"#updatenvmfee","title":"updateNVMFee","text":"<pre><code>function updateNVMFee(uint256 _newFee) public\n</code></pre> <p>Updates the nevermined fee for this type of agreement</p> Name Type Description _newFee uint256 New nevermined fee expressed in basis points"},{"location":"#changecreditvaultlibrary","title":"changeCreditVaultLibrary","text":"<pre><code>function changeCreditVaultLibrary(address _vaultLibrary) public\n</code></pre>"},{"location":"#accessprooftemplate","title":"AccessProofTemplate","text":"<p>Implementation of Access Agreement Template</p>"},{"location":"#didregistry_9","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#accesscondition_1","title":"accessCondition","text":"<pre><code>contract AccessProofCondition accessCondition\n</code></pre>"},{"location":"#lockcondition","title":"lockCondition","text":"<pre><code>contract LockPaymentCondition lockCondition\n</code></pre>"},{"location":"#escrowreward","title":"escrowReward","text":"<pre><code>contract EscrowPaymentCondition escrowReward\n</code></pre>"},{"location":"#initialize_39","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _didRegistryAddress, address _accessConditionAddress, address _lockConditionAddress, address payable _escrowConditionAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access , lock payment and escrow payment conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address"},{"location":"#accesstemplate","title":"AccessTemplate","text":"<p>_Implementation of Access Agreement Template</p> <pre><code> Access template is use case specific template.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an on-chain SEA. The template is a composite of three basic\n conditions. Once the agreement is created, the consumer will lock an amount\n of tokens (as listed in the DID document - off-chain metadata) to the \n the lock reward contract which in turn will fire an event. ON the other hand \n the provider is listening to all the emitted events, the provider \n will catch the event and grant permissions to the consumer through \n secret store contract, the consumer now is able to download the data set\n by asking the off-chain component of secret store to decrypt the DID and \n encrypt it using the consumer's public key. Then the secret store will \n provide an on-chain proof that the consumer had access to the data set.\n Finally, the provider can call the escrow reward condition in order \n to release the payment. Every condition has a time window (time lock and \n time out). This implies that if the provider didn't grant the access to \n the consumer through secret store within this time window, the consumer \n can ask for refund._\n</code></pre>"},{"location":"#didregistry_10","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#accesscondition_2","title":"accessCondition","text":"<pre><code>contract AccessCondition accessCondition\n</code></pre>"},{"location":"#lockcondition_1","title":"lockCondition","text":"<pre><code>contract LockPaymentCondition lockCondition\n</code></pre>"},{"location":"#escrowreward_1","title":"escrowReward","text":"<pre><code>contract EscrowPaymentCondition escrowReward\n</code></pre>"},{"location":"#initialize_40","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _didRegistryAddress, address _accessConditionAddress, address _lockConditionAddress, address payable _escrowConditionAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access , lock payment and escrow payment conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address"},{"location":"#agreementtemplate","title":"AgreementTemplate","text":"<p>_Implementation of Agreement Template</p> <pre><code> Agreement template is a reference template where it\n has the ability to create agreements from whitelisted \n template_\n</code></pre>"},{"location":"#conditiontypes","title":"conditionTypes","text":"<pre><code>address[] conditionTypes\n</code></pre>"},{"location":"#agreementstoremanager_4","title":"agreementStoreManager","text":"<pre><code>contract AgreementStoreManager agreementStoreManager\n</code></pre>"},{"location":"#createagreement_2","title":"createAgreement","text":"<pre><code>function createAgreement(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts) public\n</code></pre> <p>createAgreement create new agreement</p> Name Type Description _id bytes32 agreement unique identifier _did bytes32 refers to decentralized identifier (a bytes32 length ID). _conditionIds bytes32[] list of condition identifiers _timeLocks uint256[] list of time locks, each time lock will be assigned to the           same condition that has the same index _timeOuts uint256[] list of time outs, each time out will be assigned to the           same condition that has the same index"},{"location":"#createagreementandpay_1","title":"createAgreementAndPay","text":"<pre><code>function createAgreementAndPay(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, uint256 _idx, address payable _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) public payable\n</code></pre>"},{"location":"#createagreementandfulfill_1","title":"createAgreementAndFulfill","text":"<pre><code>function createAgreementAndFulfill(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, uint256[] _indices, address[] _accounts, bytes[] _params) internal\n</code></pre>"},{"location":"#getconditiontypes_1","title":"getConditionTypes","text":"<pre><code>function getConditionTypes() public view returns (address[])\n</code></pre> <p>getConditionTypes gets the conditions addresses list</p> <p>for the current template returns list of condition contracts       addresses</p> Name Type Description [0] address[] list of conditions contract addresses"},{"location":"#baseescrowtemplate","title":"BaseEscrowTemplate","text":""},{"location":"#agreementdata","title":"agreementData","text":"<pre><code>struct BaseEscrowTemplate.AgreementData agreementData\n</code></pre>"},{"location":"#agreementcreated","title":"AgreementCreated","text":"<pre><code>event AgreementCreated(bytes32 _agreementId, bytes32 _did, address _accessConsumer, address _accessProvider, uint256[] _timeLocks, uint256[] _timeOuts, bytes32[] _conditionIdSeeds, bytes32[] _conditionIds, bytes32 _idSeed, address _creator)\n</code></pre>"},{"location":"#agreementdatamodel","title":"AgreementDataModel","text":"<pre><code>struct AgreementDataModel {\n  address accessConsumer;\n  address accessProvider;\n  bytes32 did;\n}\n</code></pre>"},{"location":"#agreementdata_1","title":"AgreementData","text":"<pre><code>struct AgreementData {\n  mapping(bytes32 &amp;#x3D;&amp;gt; struct BaseEscrowTemplate.AgreementDataModel) agreementDataItems;\n  bytes32[] agreementIds;\n}\n</code></pre>"},{"location":"#createagreement_3","title":"createAgreement","text":"<pre><code>function createAgreement(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address _accessConsumer) public\n</code></pre> <p>createAgreement creates agreements through agreement template</p> <p>this function initializes the agreement by setting the DID,       conditions ID, timeouts, time locks and the consumer address.       The DID provider/owner is automatically detected by the DID       Registry</p> Name Type Description _id bytes32 SEA agreement unique identifier _did bytes32 Decentralized Identifier (DID) _conditionIds bytes32[] conditions ID associated with the condition types _timeLocks uint256[] the starting point of the time window ,time lock is        in block number not seconds _timeOuts uint256[] the ending point of the time window ,time lock is        in block number not seconds _accessConsumer address consumer address"},{"location":"#createagreementandpayescrow","title":"createAgreementAndPayEscrow","text":"<pre><code>function createAgreementAndPayEscrow(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address _accessConsumer, uint256 _idx, address payable _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) public payable\n</code></pre>"},{"location":"#createagreementandfulfill_2","title":"createAgreementAndFulfill","text":"<pre><code>function createAgreementAndFulfill(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address _accessConsumer, uint256[] _indices, address[] _accounts, bytes[] _params) internal\n</code></pre>"},{"location":"#_makeids","title":"_makeIds","text":"<pre><code>function _makeIds(bytes32 _idSeed, bytes32[] _conditionIds) internal view returns (bytes32[])\n</code></pre>"},{"location":"#_initagreement","title":"_initAgreement","text":"<pre><code>function _initAgreement(bytes32 _idSeed, bytes32 _did, uint256[] _timeLocks, uint256[] _timeOuts, address _accessConsumer, bytes32[] _conditionIds) internal\n</code></pre>"},{"location":"#getagreementdata","title":"getAgreementData","text":"<pre><code>function getAgreementData(bytes32 _id) external view returns (address accessConsumer, address accessProvider)\n</code></pre> <p>getAgreementData return the agreement Data</p> Name Type Description _id bytes32 SEA agreement unique identifier Name Type Description accessConsumer address the agreement consumer accessProvider address the provider addresses"},{"location":"#didsalestemplate","title":"DIDSalesTemplate","text":"<p>_Implementation of DID Sales Template</p> <pre><code> The DID Sales template supports an scenario where an Asset owner\n can sell that asset to a new Owner.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing an Asset owner to get transfer the asset ownership\n after some payment. \n The template is a composite of 3 basic conditions: \n - Lock Payment Condition\n - Transfer DID Condition\n - Escrow Reward Condition\n\n This scenario takes into account royalties for original creators in the secondary market.\n Once the agreement is created, the consumer after payment can request the ownership transfer of an asset\n from the current owner for a specific DID._\n</code></pre>"},{"location":"#didregistry_11","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#lockpaymentcondition_1","title":"lockPaymentCondition","text":"<pre><code>contract LockPaymentCondition lockPaymentCondition\n</code></pre>"},{"location":"#transfercondition_1","title":"transferCondition","text":"<pre><code>contract TransferDIDOwnershipCondition transferCondition\n</code></pre>"},{"location":"#rewardcondition","title":"rewardCondition","text":"<pre><code>contract EscrowPaymentCondition rewardCondition\n</code></pre>"},{"location":"#id","title":"id","text":"<pre><code>function id() public pure returns (uint256)\n</code></pre>"},{"location":"#initialize_41","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _lockConditionAddress, address _transferConditionAddress, address payable _escrowPaymentAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockConditionAddress address lock reward condition contract address _transferConditionAddress address transfer ownership condition contract address _escrowPaymentAddress address payable escrow reward condition contract address"},{"location":"#dynamicaccesstemplate","title":"DynamicAccessTemplate","text":"<p>Implementation of Agreement Template This is a dynamic template that allows to setup flexible conditions depending  on the use case.</p>"},{"location":"#didregistry_12","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#templateconfig","title":"templateConfig","text":"<pre><code>struct DynamicAccessTemplate.TemplateConditions templateConfig\n</code></pre>"},{"location":"#templateconditions","title":"TemplateConditions","text":"<pre><code>struct TemplateConditions {\n  mapping(address &amp;#x3D;&amp;gt; contract Condition) templateConditions;\n}\n</code></pre>"},{"location":"#initialize_42","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _didRegistryAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address"},{"location":"#addtemplatecondition","title":"addTemplateCondition","text":"<pre><code>function addTemplateCondition(address _conditionAddress) external returns (uint256 length)\n</code></pre> <p>addTemplateCondition adds a new condition to the template</p> Name Type Description _conditionAddress address condition contract address Name Type Description length uint256 conditionTypes array size"},{"location":"#removelasttemplatecondition","title":"removeLastTemplateCondition","text":"<pre><code>function removeLastTemplateCondition() external returns (address[])\n</code></pre> <p>removeLastTemplateCondition removes last condition added to the template</p> Name Type Description [0] address[] conditionTypes existing in the array"},{"location":"#escrowcomputeexecutiontemplate","title":"EscrowComputeExecutionTemplate","text":"<p>_Implementation of a Compute Execution Agreement Template</p> <pre><code> EscrowComputeExecutionTemplate is use case specific template.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an on-chain SEA. The template is a composite of three basic\n conditions. Once the agreement is created, the consumer will lock an amount\n of tokens (as listed in the DID document - off-chain metadata) to the \n the lock reward contract which in turn will fire an event. ON the other hand \n the provider is listening to all the emitted events, the provider \n will catch the event and grant permissions to trigger a computation granting\n the execution via the ComputeExecutionCondition contract. \n The consumer now is able to trigger that computation\n by asking the off-chain gateway to start the execution of a compute workflow.\n Finally, the provider can call the escrow reward condition in order \n to release the payment. Every condition has a time window (time lock and \n time out). This implies that if the provider didn't grant the execution to \n the consumer within this time window, the consumer \n can ask for refund._\n</code></pre>"},{"location":"#didregistry_13","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#computeexecutioncondition_1","title":"computeExecutionCondition","text":"<pre><code>contract ComputeExecutionCondition computeExecutionCondition\n</code></pre>"},{"location":"#lockpaymentcondition_2","title":"lockPaymentCondition","text":"<pre><code>contract LockPaymentCondition lockPaymentCondition\n</code></pre>"},{"location":"#escrowpayment","title":"escrowPayment","text":"<pre><code>contract EscrowPaymentCondition escrowPayment\n</code></pre>"},{"location":"#initialize_43","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _didRegistryAddress, address _computeExecutionConditionAddress, address _lockPaymentConditionAddress, address payable _escrowPaymentAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        service executor condition, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _computeExecutionConditionAddress address service executor condition contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward contract address"},{"location":"#name","title":"name","text":"<pre><code>function name() public pure returns (string)\n</code></pre>"},{"location":"#nft721accessprooftemplate","title":"NFT721AccessProofTemplate","text":"<p>Implementation of NFT721 Access Proof Template</p>"},{"location":"#nft721accessswaptemplate","title":"NFT721AccessSwapTemplate","text":""},{"location":"#nft721accesstemplate","title":"NFT721AccessTemplate","text":"<p>Implementation of NFT Access Template</p>"},{"location":"#nft721salestemplate","title":"NFT721SalesTemplate","text":"<p>Implementation of NFT Sales Template</p>"},{"location":"#nft721saleswithaccesstemplate","title":"NFT721SalesWithAccessTemplate","text":""},{"location":"#nftaccessprooftemplate","title":"NFTAccessProofTemplate","text":"<p>_Implementation of NFT Access Template</p> <pre><code> The NFT Access template is use case specific template.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing NFT holders to get access to Nevermined services. \n The template is a composite of 2 basic conditions: \n - NFT Holding Condition\n - Access Condition\n\n Once the agreement is created, the consumer can demonstrate is holding a NFT\n for a specific DID. If that's the case the Access condition can be fulfilled\n by the asset owner or provider and all the agreement is fulfilled.\n This can be used in scenarios where a data or services owner, can allow \n users to get access to exclusive services only when they demonstrate the \n are holding a specific number of NFTs of a DID.\n This is very useful in use cases like arts._\n</code></pre>"},{"location":"#didregistry_14","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#nftholdercondition_1","title":"nftHolderCondition","text":"<pre><code>contract INFTHolder nftHolderCondition\n</code></pre>"},{"location":"#accesscondition_3","title":"accessCondition","text":"<pre><code>contract AccessProofCondition accessCondition\n</code></pre>"},{"location":"#initialize_44","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _nftHolderConditionAddress, address _accessConditionAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address"},{"location":"#nftaccessswaptemplate","title":"NFTAccessSwapTemplate","text":"<p>_Implementation of NFT Sales Template</p> <pre><code> The NFT Sales template supports an scenario where a NFT owner\n can sell that asset to a new Owner.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing a NFT owner to transfer the asset ownership\n after some payment. \n The template is a composite of 3 basic conditions: \n - Lock Payment Condition\n - Transfer NFT Condition\n - Escrow Reward Condition\n\n This scenario takes into account royalties for original creators in the secondary market.\n Once the agreement is created, the consumer after payment can request the transfer of the NFT\n from the current owner for a specific DID._\n</code></pre>"},{"location":"#didregistry_15","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#lockpaymentcondition_3","title":"lockPaymentCondition","text":"<pre><code>contract INFTLock lockPaymentCondition\n</code></pre>"},{"location":"#rewardcondition_1","title":"rewardCondition","text":"<pre><code>contract INFTEscrow rewardCondition\n</code></pre>"},{"location":"#accesscondition_4","title":"accessCondition","text":"<pre><code>contract AccessProofCondition accessCondition\n</code></pre>"},{"location":"#id_1","title":"id","text":"<pre><code>function id() public pure returns (uint256)\n</code></pre>"},{"location":"#initialize_45","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _lockPaymentConditionAddress, address payable _escrowPaymentAddress, address _accessCondition) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward condition contract address _accessCondition address"},{"location":"#nftaccesstemplate","title":"NFTAccessTemplate","text":"<p>_Implementation of NFT Access Template</p> <pre><code> The NFT Access template is use case specific template.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing NFT holders to get access to Nevermined services. \n The template is a composite of 2 basic conditions: \n - NFT Holding Condition\n - Access Condition\n\n Once the agreement is created, the consumer can demonstrate is holding a NFT\n for a specific DID. If that's the case the Access condition can be fulfilled\n by the asset owner or provider and all the agreement is fulfilled.\n This can be used in scenarios where a data or services owner, can allow \n users to get access to exclusive services only when they demonstrate the \n are holding a specific number of NFTs of a DID.\n This is very useful in use cases like arts._\n</code></pre>"},{"location":"#didregistry_16","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#nftholdercondition_2","title":"nftHolderCondition","text":"<pre><code>contract INFTHolder nftHolderCondition\n</code></pre>"},{"location":"#accesscondition_5","title":"accessCondition","text":"<pre><code>contract INFTAccess accessCondition\n</code></pre>"},{"location":"#initialize_46","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _nftHolderConditionAddress, address _accessConditionAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address"},{"location":"#nftsalestemplate","title":"NFTSalesTemplate","text":"<p>_Implementation of NFT Sales Template</p> <pre><code> The NFT Sales template supports an scenario where a NFT owner\n can sell that asset to a new Owner.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing a NFT owner to transfer the asset ownership\n after some payment. \n The template is a composite of 3 basic conditions: \n - Lock Payment Condition\n - Transfer NFT Condition\n - Escrow Reward Condition\n\n This scenario takes into account royalties for original creators in the secondary market.\n Once the agreement is created, the consumer after payment can request the transfer of the NFT\n from the current owner for a specific DID._\n</code></pre>"},{"location":"#didregistry_17","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#lockpaymentcondition_4","title":"lockPaymentCondition","text":"<pre><code>contract LockPaymentCondition lockPaymentCondition\n</code></pre>"},{"location":"#transfercondition_2","title":"transferCondition","text":"<pre><code>contract ITransferNFT transferCondition\n</code></pre>"},{"location":"#rewardcondition_2","title":"rewardCondition","text":"<pre><code>contract EscrowPaymentCondition rewardCondition\n</code></pre>"},{"location":"#id_2","title":"id","text":"<pre><code>function id() public pure returns (uint256)\n</code></pre>"},{"location":"#initialize_47","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _lockPaymentConditionAddress, address _transferConditionAddress, address payable _escrowPaymentAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address"},{"location":"#nftprice","title":"nftPrice","text":"<pre><code>mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; mapping(bytes32 =&gt; uint256)))) nftPrice\n</code></pre>"},{"location":"#nftsale","title":"nftSale","text":"<pre><code>function nftSale(address nftAddress, bytes32 nftId, address token, uint256 amount) external\n</code></pre>"},{"location":"#checkparamstransfer","title":"checkParamsTransfer","text":"<pre><code>function checkParamsTransfer(bytes[] _params, bytes32 lockPaymentConditionId, bytes32 _did) internal view returns (address)\n</code></pre>"},{"location":"#checkparamsescrow","title":"checkParamsEscrow","text":"<pre><code>function checkParamsEscrow(bytes[] _params, bytes32 lockPaymentId, bytes32 transferId) internal pure\n</code></pre>"},{"location":"#createagreementfulfill","title":"createAgreementFulfill","text":"<pre><code>function createAgreementFulfill(bytes32 _id, bytes32 _did, uint256[] _timeLocks, uint256[] _timeOuts, address _accessConsumer, bytes[] _params) external payable\n</code></pre>"},{"location":"#nftsaleswithaccesstemplate","title":"NFTSalesWithAccessTemplate","text":"<p>_Implementation of NFT Sales Template</p> <pre><code> The NFT Sales template supports an scenario where a NFT owner\n can sell that asset to a new Owner.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing a NFT owner to transfer the asset ownership\n after some payment. \n The template is a composite of 3 basic conditions: \n - Lock Payment Condition\n - Transfer NFT Condition\n - Escrow Reward Condition\n\n This scenario takes into account royalties for original creators in the secondary market.\n Once the agreement is created, the consumer after payment can request the transfer of the NFT\n from the current owner for a specific DID._\n</code></pre>"},{"location":"#didregistry_18","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"#lockpaymentcondition_5","title":"lockPaymentCondition","text":"<pre><code>contract LockPaymentCondition lockPaymentCondition\n</code></pre>"},{"location":"#transfercondition_3","title":"transferCondition","text":"<pre><code>contract ITransferNFT transferCondition\n</code></pre>"},{"location":"#rewardcondition_3","title":"rewardCondition","text":"<pre><code>contract EscrowPaymentCondition rewardCondition\n</code></pre>"},{"location":"#accesscondition_6","title":"accessCondition","text":"<pre><code>contract AccessProofCondition accessCondition\n</code></pre>"},{"location":"#initialize_48","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _lockPaymentConditionAddress, address _transferConditionAddress, address payable _escrowPaymentAddress, address _accessCondition) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address _accessCondition address"},{"location":"#templatestorelibrary","title":"TemplateStoreLibrary","text":"<p>_Implementation of the Template Store Library.</p> <pre><code> Templates are blueprints for modular SEAs. When \n creating an Agreement, a templateId defines the condition \n and reward types that are instantiated in the ConditionStore._\n</code></pre>"},{"location":"#templatestate","title":"TemplateState","text":"<pre><code>enum TemplateState {\n  Uninitialized,\n  Proposed,\n  Approved,\n  Revoked\n}\n</code></pre>"},{"location":"#template_1","title":"Template","text":"<pre><code>struct Template {\n  enum TemplateStoreLibrary.TemplateState state;\n  address owner;\n  address lastUpdatedBy;\n  uint256 blockNumberUpdated;\n}\n</code></pre>"},{"location":"#templatelist","title":"TemplateList","text":"<pre><code>struct TemplateList {\n  mapping(address &amp;#x3D;&amp;gt; struct TemplateStoreLibrary.Template) templates;\n  address[] templateIds;\n}\n</code></pre>"},{"location":"#propose","title":"propose","text":"<pre><code>function propose(struct TemplateStoreLibrary.TemplateList _self, address _id) internal returns (uint256 size)\n</code></pre> <p>propose new template</p> Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address Name Type Description size uint256 which is the index of the proposed template"},{"location":"#approve_1","title":"approve","text":"<pre><code>function approve(struct TemplateStoreLibrary.TemplateList _self, address _id) internal\n</code></pre> <p>approve new template</p> Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address"},{"location":"#revoke","title":"revoke","text":"<pre><code>function revoke(struct TemplateStoreLibrary.TemplateList _self, address _id) internal\n</code></pre> <p>revoke new template</p> Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address approved template contract address"},{"location":"#templatestoremanager_1","title":"TemplateStoreManager","text":"<p>Implementation of the Template Store Manager.      Templates are blueprints for modular SEAs. When creating an Agreement,       a templateId defines the condition and reward types that are instantiated       in the ConditionStore. This contract manages the life cycle       of the template ( Propose \u2192 Approve \u2192 Revoke ).</p>"},{"location":"#templatelist_1","title":"templateList","text":"<pre><code>struct TemplateStoreLibrary.TemplateList templateList\n</code></pre>"},{"location":"#onlyownerortemplateowner","title":"onlyOwnerOrTemplateOwner","text":"<pre><code>modifier onlyOwnerOrTemplateOwner(address _id)\n</code></pre>"},{"location":"#initialize_49","title":"initialize","text":"<pre><code>function initialize(address _owner) public\n</code></pre> <p>initialize TemplateStoreManager Initializer      Initializes Ownable. Only on contract creation.</p> Name Type Description _owner address refers to the owner of the contract"},{"location":"#proposetemplate","title":"proposeTemplate","text":"<pre><code>function proposeTemplate(address _id) external returns (uint256 size)\n</code></pre> <p>proposeTemplate proposes a new template</p> Name Type Description _id address unique template identifier which is basically        the template contract address"},{"location":"#approvetemplate","title":"approveTemplate","text":"<pre><code>function approveTemplate(address _id) external\n</code></pre> <p>approveTemplate approves a template</p> Name Type Description _id address unique template identifier which is basically        the template contract address. Only template store        manager owner (i.e OPNF) can approve this template."},{"location":"#revoketemplate","title":"revokeTemplate","text":"<pre><code>function revokeTemplate(address _id) external\n</code></pre> <p>revokeTemplate revoke a template</p> Name Type Description _id address unique template identifier which is basically        the template contract address. Only template store        manager owner (i.e OPNF) or template owner        can revoke this template."},{"location":"#gettemplate","title":"getTemplate","text":"<pre><code>function getTemplate(address _id) external view returns (enum TemplateStoreLibrary.TemplateState state, address owner, address lastUpdatedBy, uint256 blockNumberUpdated)\n</code></pre> <p>getTemplate get more information about a template</p> Name Type Description _id address unique template identifier which is basically        the template contract address. Name Type Description state enum TemplateStoreLibrary.TemplateState template status owner address template owner lastUpdatedBy address last updated by blockNumberUpdated uint256 last updated at."},{"location":"#gettemplatelistsize","title":"getTemplateListSize","text":"<pre><code>function getTemplateListSize() external view virtual returns (uint256 size)\n</code></pre> <p>getTemplateListSize number of templates</p> Name Type Description size uint256 number of templates"},{"location":"#istemplateapproved","title":"isTemplateApproved","text":"<pre><code>function isTemplateApproved(address _id) external view returns (bool)\n</code></pre> <p>isTemplateApproved check whether the template is approved</p> Name Type Description _id address unique template identifier which is basically        the template contract address. Name Type Description [0] bool true if the template is approved"},{"location":"#agreementstoremanagerchangefunctionsignature","title":"AgreementStoreManagerChangeFunctionSignature","text":""},{"location":"#createagreement_4","title":"createAgreement","text":"<pre><code>function createAgreement(bytes32 _id, bytes32 _did, address[] _conditionTypes, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address _creator, address _sender) public\n</code></pre>"},{"location":"#agreementstoremanagerchangeinstorage","title":"AgreementStoreManagerChangeInStorage","text":""},{"location":"#agreementcount","title":"agreementCount","text":"<pre><code>uint256 agreementCount\n</code></pre>"},{"location":"#agreementstoremanagerchangeinstorageandlogic","title":"AgreementStoreManagerChangeInStorageAndLogic","text":""},{"location":"#agreementstoremanagerextrafunctionality","title":"AgreementStoreManagerExtraFunctionality","text":""},{"location":"#dummyfunction","title":"dummyFunction","text":"<pre><code>function dummyFunction() public pure returns (bool)\n</code></pre>"},{"location":"#agreementstoremanagerwithbug","title":"AgreementStoreManagerWithBug","text":""},{"location":"#getdidregistryaddress_1","title":"getDIDRegistryAddress","text":"<pre><code>function getDIDRegistryAddress() public pure returns (address)\n</code></pre> <p>getDIDRegistryAddress utility function  used by other contracts or any EOA.</p> Name Type Description [0] address the DIDRegistry address"},{"location":"#conditionstorechangefunctionsignature","title":"ConditionStoreChangeFunctionSignature","text":""},{"location":"#createcondition_2","title":"createCondition","text":"<pre><code>function createCondition(bytes32 _id, address _typeRef, address _sender) public\n</code></pre>"},{"location":"#conditionstorechangeinstorage","title":"ConditionStoreChangeInStorage","text":""},{"location":"#conditioncount","title":"conditionCount","text":"<pre><code>uint256 conditionCount\n</code></pre>"},{"location":"#conditionstorechangeinstorageandlogic","title":"ConditionStoreChangeInStorageAndLogic","text":""},{"location":"#conditionstoreextrafunctionality","title":"ConditionStoreExtraFunctionality","text":""},{"location":"#dummyfunction_1","title":"dummyFunction","text":"<pre><code>function dummyFunction() public pure returns (bool)\n</code></pre>"},{"location":"#conditionstorewithbug","title":"ConditionStoreWithBug","text":""},{"location":"#getconditionstate_1","title":"getConditionState","text":"<pre><code>function getConditionState(bytes32 _id) public view returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>getConditionState</p> Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"#didregistrychangefunctionsignature","title":"DIDRegistryChangeFunctionSignature","text":""},{"location":"#registerattribute_1","title":"registerAttribute","text":"<pre><code>function registerAttribute(bytes32 _didSeed, address[] _providers, bytes32 _checksum, string _url) public\n</code></pre>"},{"location":"#didregistrychangeinstorage","title":"DIDRegistryChangeInStorage","text":""},{"location":"#timeofregister","title":"timeOfRegister","text":"<pre><code>mapping(bytes32 =&gt; uint256) timeOfRegister\n</code></pre>"},{"location":"#didregistrychangeinstorageandlogic","title":"DIDRegistryChangeInStorageAndLogic","text":""},{"location":"#didregistryextrafunctionality","title":"DIDRegistryExtraFunctionality","text":""},{"location":"#getnumber","title":"getNumber","text":"<pre><code>function getNumber() public pure returns (uint256)\n</code></pre>"},{"location":"#didregistrywithbug","title":"DIDRegistryWithBug","text":""},{"location":"#registerattribute_2","title":"registerAttribute","text":"<pre><code>function registerAttribute(bytes32 _checksum, bytes32 _didSeed, address[] _providers, string _url) public\n</code></pre> <p>registerAttribute is called only by DID owner.</p> <p>this function registers DID attributes</p> Name Type Description _checksum bytes32 includes a one-way HASH calculated using the DDO content _didSeed bytes32 refers to decentralized identifier (a byte32 length ID) _providers address[] _url string refers to the attribute value"},{"location":"#ipnft","title":"IPNFT","text":""},{"location":"#tokenurichanged","title":"TokenURIChanged","text":"<pre><code>event TokenURIChanged(uint256 tokenId, string newURI)\n</code></pre>"},{"location":"#initialize_50","title":"initialize","text":"<pre><code>function initialize(string _name, string _symbol) public\n</code></pre>"},{"location":"#settokenuri","title":"setTokenURI","text":"<pre><code>function setTokenURI(uint256 tokenId, string _tokenURI) public\n</code></pre>"},{"location":"#mint_5","title":"mint","text":"<pre><code>function mint(address to, uint256 _tokenId, string _tokenURI) public returns (bool)\n</code></pre>"},{"location":"#mintwithouttokenuri","title":"mintWithoutTokenURI","text":"<pre><code>function mintWithoutTokenURI(address to, uint256 _tokenId) external\n</code></pre>"},{"location":"#transfer_2","title":"transfer","text":"<pre><code>function transfer(address from, address to, uint256 _tokenId) public\n</code></pre>"},{"location":"#neverminedconfigchangeinstorage","title":"NeverminedConfigChangeInStorage","text":""},{"location":"#newvariable","title":"newVariable","text":"<pre><code>uint256 newVariable\n</code></pre>"},{"location":"#neverminedconfigchangefunctionsignature","title":"NeverminedConfigChangeFunctionSignature","text":""},{"location":"#setmarketplacefees_2","title":"setMarketplaceFees","text":"<pre><code>function setMarketplaceFees(uint256 _marketplaceFee, address _feeReceiver, uint256 _newParameter) external virtual\n</code></pre>"},{"location":"#neverminedconfigchangeinstorageandlogic","title":"NeverminedConfigChangeInStorageAndLogic","text":""},{"location":"#neverminedconfigwithbug","title":"NeverminedConfigWithBug","text":""},{"location":"#setmarketplacefees_3","title":"setMarketplaceFees","text":"<pre><code>function setMarketplaceFees(uint256 _marketplaceFee, address _feeReceiver) external virtual\n</code></pre> <p>The governor can update the Nevermined Marketplace fees</p> Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee"},{"location":"#templatestorechangefunctionsignature","title":"TemplateStoreChangeFunctionSignature","text":""},{"location":"#proposetemplate_1","title":"proposeTemplate","text":"<pre><code>function proposeTemplate(address _id, address _sender) external returns (uint256 size)\n</code></pre>"},{"location":"#templatestorechangeinstorage","title":"TemplateStoreChangeInStorage","text":""},{"location":"#templatecount","title":"templateCount","text":"<pre><code>uint256 templateCount\n</code></pre>"},{"location":"#templatestorechangeinstorageandlogic","title":"TemplateStoreChangeInStorageAndLogic","text":""},{"location":"#templatestoreextrafunctionality","title":"TemplateStoreExtraFunctionality","text":""},{"location":"#dummyfunction_2","title":"dummyFunction","text":"<pre><code>function dummyFunction() public pure returns (bool)\n</code></pre>"},{"location":"#templatestorewithbug","title":"TemplateStoreWithBug","text":""},{"location":"#gettemplatelistsize_1","title":"getTemplateListSize","text":"<pre><code>function getTemplateListSize() external view returns (uint256 size)\n</code></pre> <p>getTemplateListSize number of templates</p> Name Type Description size uint256 number of templates"},{"location":"#testerc721","title":"TestERC721","text":""},{"location":"#initialize_51","title":"initialize","text":"<pre><code>function initialize() public\n</code></pre>"},{"location":"#mint_6","title":"mint","text":"<pre><code>function mint(uint256 id) public\n</code></pre>"},{"location":"#didregistrylibraryproxy","title":"DIDRegistryLibraryProxy","text":""},{"location":"#didregister_1","title":"didRegister","text":"<pre><code>struct DIDRegistryLibrary.DIDRegister didRegister\n</code></pre>"},{"location":"#didregisterlist_2","title":"didRegisterList","text":"<pre><code>struct DIDRegistryLibrary.DIDRegisterList didRegisterList\n</code></pre>"},{"location":"#areroyaltiesvalid_2","title":"areRoyaltiesValid","text":"<pre><code>function areRoyaltiesValid(bytes32 _did, uint256[] _amounts, address[] _receivers, address _tokenAddress) public view returns (bool)\n</code></pre>"},{"location":"#updatedidowner_1","title":"updateDIDOwner","text":"<pre><code>function updateDIDOwner(bytes32 _did, address _newOwner) public\n</code></pre>"},{"location":"#update_3","title":"update","text":"<pre><code>function update(bytes32 _did, bytes32 _checksum, string _url) public\n</code></pre>"},{"location":"#initializenftconfig_1","title":"initializeNftConfig","text":"<pre><code>function initializeNftConfig(bytes32 _did, uint256 _cap, uint8 _royalties) public\n</code></pre>"},{"location":"#initializenft721config_1","title":"initializeNft721Config","text":"<pre><code>function initializeNft721Config(bytes32 _did, uint8 _royalties) public\n</code></pre>"},{"location":"#getdidinfo","title":"getDIDInfo","text":"<pre><code>function getDIDInfo(bytes32 _did) public view returns (address owner, address creator, uint256 royalties)\n</code></pre>"},{"location":"#epochlibraryproxy","title":"EpochLibraryProxy","text":""},{"location":"#epoch_1","title":"epoch","text":"<pre><code>struct EpochLibrary.Epoch epoch\n</code></pre>"},{"location":"#epochlist_2","title":"epochList","text":"<pre><code>struct EpochLibrary.EpochList epochList\n</code></pre>"},{"location":"#create_5","title":"create","text":"<pre><code>function create(bytes32 _id, uint256 _timeLock, uint256 _timeOut) external\n</code></pre>"},{"location":"#hashlistlibraryproxy","title":"HashListLibraryProxy","text":""},{"location":"#testdata","title":"testData","text":"<pre><code>struct HashListLibrary.List testData\n</code></pre>"},{"location":"#initialize_52","title":"initialize","text":"<pre><code>function initialize(address _owner) public\n</code></pre>"},{"location":"#hash_1","title":"hash","text":"<pre><code>function hash(address _address) public pure returns (bytes32)\n</code></pre>"},{"location":"#add_5","title":"add","text":"<pre><code>function add(bytes32[] values) external returns (bool)\n</code></pre>"},{"location":"#add_6","title":"add","text":"<pre><code>function add(bytes32 value) external returns (bool)\n</code></pre>"},{"location":"#update_4","title":"update","text":"<pre><code>function update(bytes32 oldValue, bytes32 newValue) external returns (bool)\n</code></pre>"},{"location":"#index_2","title":"index","text":"<pre><code>function index(uint256 from, uint256 to) external returns (bool)\n</code></pre>"},{"location":"#has_5","title":"has","text":"<pre><code>function has(bytes32 value) external view returns (bool)\n</code></pre>"},{"location":"#remove_2","title":"remove","text":"<pre><code>function remove(bytes32 value) external returns (bool)\n</code></pre>"},{"location":"#get_2","title":"get","text":"<pre><code>function get(uint256 _index) external view returns (bytes32)\n</code></pre>"},{"location":"#size_2","title":"size","text":"<pre><code>function size() external view returns (uint256)\n</code></pre>"},{"location":"#all_2","title":"all","text":"<pre><code>function all() external view returns (bytes32[])\n</code></pre>"},{"location":"#indexof_2","title":"indexOf","text":"<pre><code>function indexOf(bytes32 value) external view returns (uint256)\n</code></pre>"},{"location":"#ownedby_2","title":"ownedBy","text":"<pre><code>function ownedBy() external view returns (address)\n</code></pre>"},{"location":"#isindexed_2","title":"isIndexed","text":"<pre><code>function isIndexed() external view returns (bool)\n</code></pre>"},{"location":"#nftbase","title":"NFTBase","text":"<p>Implementation of the Royalties EIP-2981 base contract See https://eips.ethereum.org/EIPS/eip-2981</p>"},{"location":"#_proxyapprovals","title":"_proxyApprovals","text":"<pre><code>mapping(address =&gt; bool) _proxyApprovals\n</code></pre>"},{"location":"#minter_role","title":"MINTER_ROLE","text":"<pre><code>bytes32 MINTER_ROLE\n</code></pre>"},{"location":"#royaltyinfo","title":"RoyaltyInfo","text":"<pre><code>struct RoyaltyInfo {\n  address receiver;\n  uint256 royaltyAmount;\n}\n</code></pre>"},{"location":"#nftmetadata","title":"NFTMetadata","text":"<pre><code>struct NFTMetadata {\n  string nftURI;\n}\n</code></pre>"},{"location":"#_royalties","title":"_royalties","text":"<pre><code>mapping(uint256 =&gt; struct NFTBase.RoyaltyInfo) _royalties\n</code></pre>"},{"location":"#_metadata","title":"_metadata","text":"<pre><code>mapping(uint256 =&gt; struct NFTBase.NFTMetadata) _metadata\n</code></pre>"},{"location":"#_expiration","title":"_expiration","text":"<pre><code>mapping(address =&gt; uint256) _expiration\n</code></pre>"},{"location":"#proxyapproval","title":"ProxyApproval","text":"<pre><code>event ProxyApproval(address sender, address operator, bool approved)\n</code></pre> <p>Event for recording proxy approvals.</p>"},{"location":"#setproxyapproval","title":"setProxyApproval","text":"<pre><code>function setProxyApproval(address operator, bool approved) public virtual\n</code></pre>"},{"location":"#_setnftmetadata","title":"_setNFTMetadata","text":"<pre><code>function _setNFTMetadata(uint256 tokenId, string tokenURI) internal\n</code></pre>"},{"location":"#_settokenroyalty","title":"_setTokenRoyalty","text":"<pre><code>function _setTokenRoyalty(uint256 tokenId, address receiver, uint256 royaltyAmount) internal\n</code></pre>"},{"location":"#royaltyinfo_1","title":"royaltyInfo","text":"<pre><code>function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address receiver, uint256 royaltyAmount)\n</code></pre> <p>@inheritdoc IERC2981Upgradeable</p>"},{"location":"#nftupgradeable","title":"NFTUpgradeable","text":"<p>Implementation of the basic standard multi-token. See https://eips.ethereum.org/EIPS/eip-1155</p>"},{"location":"#initialize_53","title":"initialize","text":"<pre><code>function initialize(string uri_) public\n</code></pre> <p>See {_setURI}.</p>"},{"location":"#isapprovedforall","title":"isApprovedForAll","text":"<pre><code>function isApprovedForAll(address account, address operator) public view virtual returns (bool)\n</code></pre> <p>See {IERC1155-isApprovedForAll}.</p>"},{"location":"#mint_7","title":"mint","text":"<pre><code>function mint(address to, uint256 id, uint256 amount, bytes data) public\n</code></pre>"},{"location":"#burn_3","title":"burn","text":"<pre><code>function burn(address to, uint256 id, uint256 amount) public\n</code></pre>"},{"location":"#addminter","title":"addMinter","text":"<pre><code>function addMinter(address account) public\n</code></pre>"},{"location":"#uri","title":"uri","text":"<pre><code>function uri(uint256 tokenId) public view returns (string)\n</code></pre>"},{"location":"#setnftmetadata","title":"setNFTMetadata","text":"<pre><code>function setNFTMetadata(uint256 tokenId, string nftURI) public\n</code></pre> <p>Record some NFT Metadata</p> Name Type Description tokenId uint256 the id of the asset with the royalties associated nftURI string the URI (https, ipfs, etc) to the metadata describing the NFT"},{"location":"#settokenroyalty","title":"setTokenRoyalty","text":"<pre><code>function setTokenRoyalty(uint256 tokenId, address receiver, uint256 royaltyAmount) public\n</code></pre> <p>Record the asset royalties</p> Name Type Description tokenId uint256 the id of the asset with the royalties associated receiver address the receiver of the royalties (the original creator) royaltyAmount uint256 percentage (no decimals, between 0 and 100)"},{"location":"#supportsinterface_2","title":"supportsInterface","text":"<pre><code>function supportsInterface(bytes4 interfaceId) public view virtual returns (bool)\n</code></pre>"},{"location":"#nft721subscriptionupgradeable","title":"NFT721SubscriptionUpgradeable","text":""},{"location":"#mint_8","title":"mint","text":"<pre><code>function mint(address to, uint256 id, uint256 expirationBlock) public\n</code></pre>"},{"location":"#balanceof_1","title":"balanceOf","text":"<pre><code>function balanceOf(address owner) public view returns (uint256)\n</code></pre> <p>See {IERC721-balanceOf}.</p>"},{"location":"#nft721upgradeable","title":"NFT721Upgradeable","text":"<p>Implementation of the basic standard multi-token.</p>"},{"location":"#initialize_54","title":"initialize","text":"<pre><code>function initialize(string name, string symbol) public virtual\n</code></pre>"},{"location":"#initialize_55","title":"initialize","text":"<pre><code>function initialize() public virtual\n</code></pre>"},{"location":"#isapprovedforall_1","title":"isApprovedForAll","text":"<pre><code>function isApprovedForAll(address account, address operator) public view virtual returns (bool)\n</code></pre> <p>See {IERC1155-isApprovedForAll}.</p>"},{"location":"#addminter_1","title":"addMinter","text":"<pre><code>function addMinter(address account) public\n</code></pre>"},{"location":"#mint_9","title":"mint","text":"<pre><code>function mint(address to, uint256 id) public virtual\n</code></pre>"},{"location":"#burn_4","title":"burn","text":"<pre><code>function burn(uint256 id) public\n</code></pre>"},{"location":"#tokenuri","title":"tokenURI","text":"<pre><code>function tokenURI(uint256 tokenId) public view virtual returns (string)\n</code></pre> <p>See {IERC721Metadata-tokenURI}.</p>"},{"location":"#setnftmetadata_1","title":"setNFTMetadata","text":"<pre><code>function setNFTMetadata(uint256 tokenId, string nftURI) public\n</code></pre> <p>Record some NFT Metadata</p> Name Type Description tokenId uint256 the id of the asset with the royalties associated nftURI string the URI (https, ipfs, etc) to the metadata describing the NFT"},{"location":"#settokenroyalty_1","title":"setTokenRoyalty","text":"<pre><code>function setTokenRoyalty(uint256 tokenId, address receiver, uint256 royaltyAmount) public\n</code></pre> <p>Record the asset royalties</p> Name Type Description tokenId uint256 the id of the asset with the royalties associated receiver address the receiver of the royalties (the original creator) royaltyAmount uint256 percentage (no decimals, between 0 and 100)"},{"location":"#supportsinterface_3","title":"supportsInterface","text":"<pre><code>function supportsInterface(bytes4 interfaceId) public view virtual returns (bool)\n</code></pre>"},{"location":"#poapupgradeable","title":"POAPUpgradeable","text":""},{"location":"#_tokenidcounter","title":"_tokenIdCounter","text":"<pre><code>struct CountersUpgradeable.Counter _tokenIdCounter\n</code></pre>"},{"location":"#_tokenevent","title":"_tokenEvent","text":"<pre><code>mapping(uint256 =&gt; uint256) _tokenEvent\n</code></pre>"},{"location":"#initialize_56","title":"initialize","text":"<pre><code>function initialize() public\n</code></pre>"},{"location":"#initialize_57","title":"initialize","text":"<pre><code>function initialize(string name, string symbol) public virtual\n</code></pre>"},{"location":"#mint_10","title":"mint","text":"<pre><code>function mint(address to, string uri, uint256 eventId) public\n</code></pre>"},{"location":"#mint_11","title":"mint","text":"<pre><code>function mint(address to, uint256 id) public\n</code></pre>"},{"location":"#tokenevent","title":"tokenEvent","text":"<pre><code>function tokenEvent(uint256 tokenId) public view returns (uint256)\n</code></pre>"},{"location":"#_beforetokentransfer_1","title":"_beforeTokenTransfer","text":"<pre><code>function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal\n</code></pre>"},{"location":"#_burn","title":"_burn","text":"<pre><code>function _burn(uint256 tokenId) internal\n</code></pre>"},{"location":"#tokendetailsofowner","title":"tokenDetailsOfOwner","text":"<pre><code>function tokenDetailsOfOwner(address owner) public view returns (uint256[] tokenIds, uint256[] eventIds)\n</code></pre>"},{"location":"#tokenuri_1","title":"tokenURI","text":"<pre><code>function tokenURI(uint256 tokenId) public view returns (string)\n</code></pre>"},{"location":"#isapprovedforall_2","title":"isApprovedForAll","text":"<pre><code>function isApprovedForAll(address account, address operator) public view returns (bool)\n</code></pre>"},{"location":"#supportsinterface_4","title":"supportsInterface","text":"<pre><code>function supportsInterface(bytes4 interfaceId) public view virtual returns (bool)\n</code></pre>"},{"location":"ContractABIs/","title":"Contracts ABIs","text":"<p>Nevermined as a digital ecosystems builder has some differences from a contracts deployment point of view compared with some other protocols.</p> <p>These are some main characteristics:</p> <ul> <li>We support different products built on Nevermined contracts running in different networks</li> <li>Each product will use different versions of the contracts</li> <li>Different products in the same network could require different versions of the contracts</li> </ul>"},{"location":"ContractABIs/#what-defines-a-nevermined-deployment","title":"What defines a Nevermined deployment","text":"<p>So the organization of how the applications are using the which version of the contracts in which network is defined by 3 dimensions:</p> <ul> <li>Version, the version of the Smart Contracts <code>v1.3.9</code>, <code>v2.0.1</code>, etc</li> <li>Network, in which network  (<code>NETWORK_ID</code>) are the contracts deployed. Typically <code>mumbai</code>, <code>polygon</code>, <code>rinkeby</code>,   <code>mainnet</code>, <code>alfajores</code> and <code>celo</code> but it could be others</li> <li>Tag Name, referring to a specific product or app using this specific release of the contracts. This is important   because the same version of the contracts in the same network could be required because different configuration   during the deployment of the instance. If tag name is not specified we assume is a <code>common</code> deployment.</li> </ul> <p>So Version + Network + Tag Name defines a unique Nevermined deployment or instance.</p>"},{"location":"ContractABIs/#how-we-release-the-abis","title":"How we release the ABIs?","text":"<p>Because of this, the releasing and deployment process of the contracts take care of:</p> <ol> <li>When a new version of the contracts is tagged, the ABIs of that version are stored indicating the version.</li> <li>When a new version of the contracts is installed or upgraded into a non-local environment, the ABIs of that version    (with the contract address included) corresponding to that network and tag name are stored in a hierarchy structure    representing this unique version/network/tag</li> </ol> <p> Releasing new Nevermined Contracts ABIs </p>"},{"location":"ContractABIs/#new-release-of-the-contracts-new-tag","title":"New release of the contracts (new tag)","text":"<p>A new tag of Nevermined contracts will generate the ABIs that will be uploaded using the following structure:</p> <pre><code>https://artifacts.nevermined.network/abis/abis_&lt;VERSION&gt;.zip | tar.gz\n</code></pre>"},{"location":"ContractABIs/#deployment-of-the-contracts-in-a-network","title":"Deployment of the contracts in a network","text":"<p>A new deployment (fresh install or upgrade) of the contracts will generate 2 different files:</p> <ul> <li>The contracts file keeping the name of the contract and the address where the contract is deployed. This file will be   in JSON format and have the following format: <pre><code>{\n    \"ContractName1\": \"0x123\",\n    \"ContractName2\": \"0x123\"\n}\n</code></pre></li> <li>The ABIs package file including all the ABI files. The package file could be in zip and tar.gz formats.</li> </ul> <p>Taking all the above into account, after a deployment 2 new files are generated with the contracts addresses and abis using the following structure: <pre><code>https://artifacts.nevermined.network/&lt;NETWORK_ID&gt;/&lt;TAG_NAME&gt;/contracts_&lt;VERSION&gt;.zip | .tar.gz\nhttps://artifacts.nevermined.network/&lt;NETWORK_ID&gt;/&lt;TAG_NAME&gt;/contracts_&lt;VERSION&gt;.json\n</code></pre></p> <p>For example, for a new deployment of contracts <code>v3.0.0</code> on <code>mumbai</code> (network id 80001) and tag <code>public</code>, it will have the following 2 files:</p> <pre><code>https://artifacts.nevermined.network/80001/public/contracts_v3.0.0.zip\nhttps://artifacts.nevermined.network/80001/public/contracts_v3.0.0.json\n</code></pre>"},{"location":"ContractABIs/#integration","title":"Integration","text":"<p>Knowing the version, environment and the tag name, a client can get all the artifacts and addresses of the contracts that needs to use downloading the artifacts from the public repository.</p> <p>In addition to this, the NPM package <code>@nevermined-io/contracts</code> of the contracts will include the ABIs. In combination with the contracts.json, the client should be able to configure the correct address where connect just replacing the contract addresses in the ABIs.</p> <p> Integration of Nevermined Contracts ABIs </p>"},{"location":"Frost/","title":"Frost network","text":""},{"location":"Frost/#basic-idea-without-threshold-signatures-copypasta-from-before","title":"Basic idea without threshold signatures (copypasta from before)","text":"<p>The idea is that actors are able to share decryption keys, also there are proofs that correct keys have been shared. The system has three actors:</p> <ul> <li>Network (can be several actors with threshold signature)</li> <li>Data provider: encrypts the original data, sends decryption key to network</li> <li>Data consumer: gets a decryption key from the network</li> </ul> <p>The network has secret y, and public key yG = Y</p> <p>Data provider view</p> <ul> <li>Will first need to generate password (256 bits, or probably a bit less)</li> <li>The data has to be encrypted and the encrypted data is made publicly available</li> <li>Then will have to generate a secret key x</li> <li>Public key xG: identifier for the secret</li> <li>The shared secret will then be xyG (ecdh)</li> <li>The password is encrypted with the shared secret (just xor)</li> <li>The encrypted password and corresponding public key xG are stored by the network</li> <li>There could be a ZK-SNARK that gives knowledge of the hash of the password, but it depends on the curve if it\u2019s efficient</li> <li>Data provider can forget the secret key (it shouldn\u2019t be used again)</li> <li>In theory could forget the password, but probably the network will have to change the key like once in a year, so it will have to be resent</li> </ul> <p>Consumer view</p> <ul> <li>First can download the encrypted data</li> <li>Can get the corresponding encrypted password and xG from network / smart contracts</li> <li>Will have to generate a secret key z</li> <li>So the agreement will include xG and yG, also encrypted password and zG</li> <li>The network will send y(xG+zG) to fulfill the agreement. There will probably have to be some way to send a reward to the network (re-encrytion)</li> <li>The consumer will get the shared secret by: y(xG+zG) - yzG = xyG</li> <li>Now the consumer will get the password with xor and can decrypt the downloaded data</li> </ul>"},{"location":"Frost/#correctness-guarantees-dleq-proof-that-reencryption-was-correct","title":"Correctness guarantees (DLEQ proof that reencryption was correct)","text":"<p>Making sure that the network sends the correct result (DLEQ; discrete logarithm equality)</p> <p>DLEQ basic description</p> <ul> <li>Given points G, H</li> <li>Send points X, Y</li> <li>DLEQ proves that there exists x such that X = xG and Y = xH</li> <li>In other words, G/X = H/Y</li> <li>This is a ZK proof</li> </ul> <p>Proving that re-encryption is correct</p> <ul> <li>We have points G and xG+zG</li> <li>Send points Y, R (Y is the previously known public key Y=yG)</li> <li>Will prove that R = y(xG+zG)</li> <li>So just DLEQ is enough to prove the correctness</li> </ul>"},{"location":"Frost/#threshold-signatures","title":"Threshold signatures","text":"<p>In the network, the participants should not be able to access the password. To accomplish this, some kind of threshold signatures should be used. Assume that the network has participants 1..n. The secret of the network is y, and each participant has a share y_i. (These are generated by DKG).</p> <p>Then there is some threshold t such that t participants can access the secret. So we have a set T \\subseteq {1..n} such that |T| &gt;= t. Then we have multipliers l_i such that y = \\sum l_i y_i (where i \\in T). The multipliers depend on the set T.</p> <p>The problem now is how the participants can cooperate to generate the DLEQ proof for a given point xG+zG. DLEQ is a sigma protocol similar to Schnorr signatures, basically the only difference is that DLEQ has two points and Schnorr signatures just have one point. So it should be possible to adapt threshold protocols for Schnorr signatures to DLEQ.</p> <p>One protocol is FROST https://eprint.iacr.org/2020/852.pdf. At the beginning round, the participants commit to a point pair. It should be enough to modify it so that participants commit to two point pairs. Because of the properties of DLEQ, we know that the aggregated signature is correct. In the case of DLEQ there will have to be two rounds, so the participants will have to interact with each other. The aggregator coordinates the communication, and would probably in this case also send the result to the blockchain.</p>"},{"location":"Frost/#network-setup","title":"Network setup","text":"<p>The network will have n nodes. One of the nodes is coordinator. The nodes will have to communicate with each other via secure channels. To setup the network, the nodes will have to use DKG (distributed key generation) to generate their secret shares and the public key for the network.</p> <p>The network public key has to be setup in the contracts so that the network can start fulfilling the requests. After this, the coordinating node will monitor the contracts for conditions that should be fulfilled. When a condition is found, it will select <code>t</code> nodes and generate a DLEQ proof with them. Finally the coordinator fulfills the condition.</p>"},{"location":"Frost/#rpc-calls","title":"RPC calls","text":"<p>There are the following RPC calls:</p> <ul> <li><code>coordinate_round1</code>: start first round of DKG</li> <li><code>coordinate_round2</code>: start second round of DKG. Will return the network public key.</li> <li><code>listen</code>: poll the contract for conditions to fulfill, fulfill all found conditions.</li> </ul> <p>RPC calls that are internal for DKG:</p> <ul> <li><code>init_round1</code>: participants commit to their secrets</li> <li><code>validate_round1</code>: send commitments to other participants. Other nodes should validate that the commitment are correct</li> <li><code>make_shares</code>: generating shares</li> <li><code>set_share</code>: send shares to other participants. When all shares are received, validate them</li> </ul> <p>RPC calls that are internal for Frost:</p> <ul> <li><code>crypt</code>: encrypt message with share</li> <li><code>reencrypt</code>: coordinate threshold encryption</li> <li><code>frost_round1</code>: each node commits to secret</li> <li><code>frost_round2</code>: compute the common DLEQ challenge and make own part of the response</li> </ul>"},{"location":"Frost/#interface-with-the-contracts","title":"Interface with the contracts","text":"<p>The owner of the assets has to post the secret ID to the network. There should be a way to decide which agreements should be fulfilled. For this, the asset owner has to post the price for the asset. The asset buyer or some third party can submit the agreement for fulfillment by the network.</p>"},{"location":"Packages/","title":"Packages","text":"<p>The following package describes how to package the Keeper Contracts in different formats. It is helpful to distribute the compiled smart contracts ABI's in different \"flavours\". It allows to import those ABI's from different languages enabling an easier interaction with the Keeper.</p>"},{"location":"Packages/#javascript-npm","title":"Javascript (NPM)","text":"<p>NPM packages are published as part of the Nevermined NPM organization. Github Actions is configured to release a new version of the nevermined-io/contracts NPM library after tagging.</p> <p>Versions of the library must be modified in the package.json file.</p> <pre><code>{\n  \"name\": \"@nevermined-io/contracts\",\n  \"version\": \"1.0.0\",\n\n  ..\n\n}\n</code></pre> <p>Typically you can't overwrite NPM already published versions of the libraries. This package uses Semantic Versioning, so if you are testing with new versions, it's recommended to play with the patch numbers.</p> <p>If you need to build a local version of the package you need to run the following commands:</p> <pre><code>yarn\nyarn build\n</code></pre> <p>If you need to release a new version of the library before tagging, you need to execute the following command: <pre><code>npm publish --access public\n</code></pre></p> <p>To do that you need to be an authorized user in the NPM Nevermined organization.</p>"},{"location":"Packages/#python","title":"Python","text":"<p>Python packages are generated automatically in Pypi format:</p> <p>https://pypi.org/project/nevermined-contracts/</p>"},{"location":"Packages/#java","title":"Java","text":"<p>Java packages are generated automatically for JVM applications and published into Maven central:</p> <p>https://search.maven.org/artifact/io.keyko.nevermined/contracts</p>"},{"location":"ReleaseProcess/","title":"Release Process","text":""},{"location":"ReleaseProcess/#build-a-new-version","title":"Build a new version","text":"<p>Nevermined contracts follow the semantic versioning pattern. To release a new version it's necessary:</p> <ul> <li>Make sure the versions is correctly updated in the: <code>package.json</code></li> <li>Create a tag:</li> </ul> <pre><code>git tag v2.0.0\n</code></pre> <ul> <li>Push the tag:</li> </ul> <pre><code>git push origin v2.0.0\n</code></pre>"},{"location":"ReleaseProcess/#interact-with-networks","title":"Interact with networks","text":""},{"location":"ReleaseProcess/#roles","title":"Roles","text":"<p> wallets.json file is needed if using a MultiSig Wallet for the deployment. Currently none of the Nevermined contract deployments is using Multisig wallets.</p> <p>We define six roles (check code configuration in wallets.js):</p> <ul> <li><code>deployer</code>: represented as <code>accounts[8]</code></li> <li><code>upgrader</code>: represented as <code>accounts[8]</code></li> <li><code>governor</code>: represented as <code>accounts[9]</code></li> <li><code>ownerWallet</code>: represented as the <code>owner</code> from <code>wallets.json</code> or <code>accounts[8]</code></li> <li><code>upgraderWallet</code>: represented as the <code>upgrader</code> from <code>wallets.json</code> or <code>accounts[8]</code></li> <li><code>governorWallet</code>: represented as the <code>governor</code> from <code>wallets.json</code> or <code>accounts[9]</code></li> </ul>"},{"location":"ReleaseProcess/#flags","title":"Flags","text":"<ul> <li><code>--testnet</code> Deploys the <code>Dispenser</code>, the <code>NeverminedToken</code> and the contracts from <code>contracts.json</code></li> <li><code>--with-token</code> Deploys the <code>NeverminedToken</code> and the contracts from <code>contracts.json</code></li> </ul>"},{"location":"ReleaseProcess/#nevermined-configuration","title":"Nevermined Configuration","text":"<p>The set of Nevermined contracts can be deployed in different networks and interact with several use cases. Each of these different scenarios could require different configurations so to facilitate that Nevermined provides an on-chain configuration mechanism allowing the governance (via DAO or similar) of a Nevermined deployment. To see all the available possibilities please see the <code>INeverminedConfig</code> interface.</p> <p>During the deployment of Nevermined all of these parameters can be specified allowing a bespoke environment configuration. This can be done via the definition of the following environment variables:</p> <ul> <li><code>NVM_MARKETPLACE_FEE</code>. It refers to the fee charged by Nevermined for using the Service Agreements. It uses an integer number representing a 4 decimal number. It means 145000 means 14.50% fee. The value must be beteen 0 and 10000 (100%). See <code>marketplaceFee</code> variable.</li> <li><code>NVM_RECEIVER_FEE</code>. It refers to the address that will receive the fee charged by Nevermined per transaction. See <code>feeReceiver</code> variable</li> </ul>"},{"location":"ReleaseProcess/#deployer","title":"Deployer","text":"<p>Can be any account. It is used for deploying the initial proxy contracts and the logic contracts.</p>"},{"location":"ReleaseProcess/#upgrader","title":"Upgrader","text":"<p>Has to be an <code>owner</code> of the <code>upgrader</code> multi sig wallet. It is used for issuing upgrade requests against the <code>upgrader</code> multi sig wallet.</p>"},{"location":"ReleaseProcess/#upgraderwallet","title":"UpgraderWallet","text":"<p>One instance of the multi sig wallet, defined as <code>upgrader</code>. This wallet will be assigned as zos admin and is required to do upgrades.</p>"},{"location":"ReleaseProcess/#ownerwallet","title":"OwnerWallet","text":"<p>One instance of the multi sig wallet, defined as <code>owner</code>. This wallet will be assigned as the <code>owner</code> of all the contracts. It can be used to call specific functions in the contracts ie. change the configuration.</p>"},{"location":"ReleaseProcess/#deploy-upgrade","title":"Deploy &amp; Upgrade","text":"<p>Deployment configurations are on <code>hardhat.config.js</code>.</p> <ul> <li>run <code>yarn clean</code> to clean the work dir.</li> <li>run <code>yarn compile</code> to compile the contracts.</li> </ul> <p> The following steps shows how to perform contracts deployment for new deployments (check <code>[Upgrades.md](./Upgrades.md)</code> for upgrading details)</p> <ul> <li>Export the <code>NETWORK</code> (check in the <code>hardhat.config.js</code> for the supported networks) and contract's tag <code>TAG</code>:</li> </ul> <pre><code>export NETWORK=mumbai\nexport TAG=common\n</code></pre> <ul> <li>it will be useful to set <code>export DEPLOY_ERROR_EXIT=true</code>, then the deployment script will exit if any error occurs in contract calls. Then the deployment can be retried easily.</li> <li>for a clean deployment remove all the artifacts existing with the network you are deploying: <code>rm -f artifacts/*.$NETWORK.json</code></li> <li>run <code>export MNEMONIC=&lt;deployment's mnemonic&gt;</code>. You will find them in the password manager.</li> </ul> <p>Here a full example:</p> <pre><code>MNEMONIC=\"my 24 words mnemonic\"\nDEPLOYER=0xe08A1dAe983BC701D05E492DB80e0144f8f4b909\nUPGRADER=0xe08A1dAe983BC701D05E492DB80e0144f8f4b909\nGOVERNOR=0xbcE5A3468386C64507D30136685A99cFD5603135\n\nNVM_MARKETPLACE_FEE=010000\n\nNVM_RECEIVER_FEE=0x309039F6A4e876bE0a3FCA8c1e32292358D7f07c\nOPENGSN_FORWARDER=0x4d4581c01A457925410cd3877d17b2fd4553b2C5\n\nNETWORK=mumbai\nTAG=public\n</code></pre> <p>To make meta-transactions work, <code>OPENGSN_FORWARDER</code> should be set to the correct forwarder address for the network. The OpenGSN v2 contract addresses should be used.</p>"},{"location":"ReleaseProcess/#deploy-and-initialize-the-contracts","title":"Deploy and initialize the contracts","text":"<ul> <li>To deploy and initialize all contracts run <code>yarn deploy:$NETWORK</code></li> </ul> <p>This step will create <code>cache/</code> and <code>deploy-cache.json</code> used to resume the deployment in case something fails.</p> <p>:::info If you want to make a clean deployment, do: <code>export CONTRACTS_DEEPER_CLEAN=true &amp;&amp; rm deploy-cache.json</code> :::</p>"},{"location":"ReleaseProcess/#script-for-uploading-the-artifacts-abiscontracts-to-contract-repository","title":"Script for uploading the artifacts (abis/contracts) to Contract Repository","text":"<p>Once the contracts are deployed to a public network or a new contract version whose contract abis has been uploaded, use <code>scripts/upload_artifacts_gs.sh</code> to upload the contracts or artifacts to nevermined repository.</p> <p> Your environment has to be configured and authorized to use aws cli to upload files to <code>artifacts-nevermined-network</code> bucket.</p> <p>For all this commands you need to have access to artifacts-nevermined-rocks Google Cloud bucket.</p> <p>The script has the next variables:</p> <ul> <li><code>branch</code> is the branch from where the workflow and artifacts will be used.</li> <li><code>asset</code> can be <code>abis</code>/<code>contracts</code>. Use abis if you want to upload the contract ABIs that not contain deployment information. Contracts for uploading abis with deployment information to <code>network</code>.</li> <li><code>network</code> refers to network name, based on filename/hardhat config. Not used if <code>abis</code> is selected.</li> <li><code>tag</code> refers to deployment tag. Defaults to common. Not used if <code>abis</code> is selected.</li> </ul> <p>This workflow uses the script <code>scripts/upload_artifacts_gs.sh</code> that can be used with the next syntax:</p> <pre><code>./scripts/upload_artifacts_gs.sh contracts $NETWORK $TAG\n./scripts/upload_artifacts_gs.sh abis $NETWORK $TAG\n./scripts/upload_artifacts_gs.sh circuits $NETWORK $TAG\n</code></pre> <ul> <li>Commit the changes in <code>.openzeppelin/unknown-$NETWORK_ID.json.$TAG</code> file</li> </ul>"},{"location":"ReleaseProcess/#deployment-nft-contracts","title":"Deployment NFT Contracts","text":"<p>When a new version of the contracts, automatically the NFT common contracts are deployed too. It's possible to deploy new instances having the ABIs and using the Nevermined CLI:</p> <pre><code>ncli nfts721 deploy build/contracts/token/erc721/NFT721SubscriptionUpgradeable.sol/NFT721SubscriptionUpgradeable.json --params \"Nevermined NFT\" --params \"NVM\"\n\nncli nfts1155 deploy build/contracts/token/erc1155/NFT1155SubscriptionWithoutBlocks.sol/NFT1155SubscriptionWithoutBlocks.json --params \"Nevermined Credits Plan\" --params \"NVM\"\n</code></pre>"},{"location":"ReleaseProcess/#verifying-contracts-code-in-different-networks","title":"Verifying contracts code in different networks","text":"<p>Once the contracts are deployed and the ABIs are uploaded into the artifacts repository, it's time to verify the contracts code in all the different networks where this has been deployed.</p> <p>The script to do that is <code>scripts/contracts/verify-contracts.js</code> and requires the following parameters:</p> <ul> <li><code>version</code> the version/tag of the contracts. For example <code>v2.1.0</code></li> <li><code>network</code> refers to network name, based on filename/hardhat config. For example <code>goerli</code></li> <li><code>tag</code> refers to deployment tag. For example <code>public</code></li> </ul> <p>An example of an execution is:</p> <pre><code>nodejs ./scripts/contracts/verify-contracts.js v3.2.1 mumbai public\n</code></pre>"},{"location":"ReleaseProcess/#document","title":"Document","text":""},{"location":"ReleaseProcess/#contracts-documentation","title":"Contracts documentation","text":"<ul> <li>Update the contracts documentation</li> <li>run <code>yarn doc:contracts</code></li> <li>Commit the changes in <code>docs/contracts</code> folder</li> </ul>"},{"location":"ReleaseProcess/#trigger-ci","title":"Trigger CI","text":"<ul> <li>Commit the missing changes to the feature branch.</li> <li>Tag the last commit with the new version number ie. <code>v0.2.5</code></li> <li>Push the feature branch to GitHub.</li> <li>Make a pull request from the just-pushed branch to <code>develop</code> branch.</li> <li>Wait for all the tests to pass!</li> <li>Merge the pull request into the <code>develop</code> branch.</li> </ul>"},{"location":"ReleaseProcess/#release-and-packages","title":"Release and packages","text":"<p>The release itself is done by <code>github actions</code> based on the tagged commit.</p> <p>It will deploy the following components:</p> <ul> <li>npm</li> <li>docker</li> </ul> <p>The npm, pypi and maven packages contain the contract artifacts for the contracts already deployed in different networks (such as <code>Production</code>, <code>Rinkeby</code>, <code>Mumbai</code>, <code>Testing</code>, or <code>Spree</code>). The docker image generated contains the contracts and script ready to be used to deploy the contracts to a network. It is used for deploying the contracts in the local network <code>Spree</code> in nevermined-io/tools</p> <p>Once the new version is tagged and released, you can edit the <code>Releases</code> section of GitHub with the information and changes about the new version (in the future, these will come from the changelog):</p>"},{"location":"ReleaseProcess/#audit","title":"Audit","text":"<p>To check or document that all transactions have been approved in the multi sig wallet you can run <code>yarn audit:rinkeby</code> to get a list of all the current transactions and their current status.</p> <pre><code> Wallet: 0x24EB26D4042a2AB576E7E39b87c3f33f276AeF92\n\n Transaction ID: 64\n Destination: 0xfA16d26e9F4fffC6e40963B281a0bB08C31ed40C\n Contract: EscrowAccessSecretStoreTemplate\n Data is `upgradeTo` call: true\n Confirmed from: 0x7A13E1aD23546c9b804aDFd13e9AcB184EfCAF58\n Executed: false\n</code></pre>"},{"location":"Upgrades/","title":"Upgrade Process","text":"<p>This documents explains in detail how nevermined-contracts should be deployed using zeppelinOS and how the contracts can be upgraded. The latest section describes the test procedure.</p>"},{"location":"Upgrades/#quickstart","title":"Quickstart","text":"<p>The first step to work with <code>zos</code> is to install dependencies then initialize the project. Then compile contracts and add contracts to the project. Finally push the contracts into the network and create the  upgradable instances. Once the contracts are deployed they can be tested and upgraded. Also we change the proxy administrator to a MultiSignature wallet to approve upgrades. We are going to use the Nevermined Contract Tools in order to perform any future deployments/upgrades.</p>"},{"location":"Upgrades/#details","title":"Details","text":"<p>Here we provide more details into each step of the initial deploy and the approach of upgradeability and governance.</p>"},{"location":"Upgrades/#roles","title":"Roles","text":"<p> wallets.json file is needed if using a Gnosis MultiSig Wallet for the deployment. Currently none of the Nevermined contract deployments is using Gnosis Multisig wallets.</p> <p>Before going into more details about the deployment. We should differentiate between different roles in the system which govern the upgradeability in nevermined-contracts.</p> <p>Roles are defined as follows (check code configuration in wallets.js):</p> <pre><code>deployer: represented as accounts[8]\nupgrader: represented as accounts[8]\ngovernor: represented as accounts[9]\nownerWallet: represented as the owner from wallets.json or accounts[8]\nupgraderWallet: represented as the upgrader from wallets.json or accounts[8]\ngovernorWallet: represented as the governor from wallets.json or accounts[9]\n</code></pre> <ul> <li> <p>Deployer: Can be any account. It is used for deploying the initial <code>proxy contracts</code> and the <code>logic contracts</code>.</p> </li> <li> <p>Upgrader: Has to be an <code>owner</code> of the <code>upgrader</code> multi sig wallet. It is used for issuing upgrade requests against the upgrader multi sig wallet.</p> </li> </ul>"},{"location":"Upgrades/#-governor-has-to-have-the-governor_role-in-the-contracts-it-is-used-for-issuing-upgrade-config-requests","title":"- Governor: Has to have the <code>GOVERNOR_ROLE</code> in the contracts. It is used for issuing upgrade config requests.","text":"<ul> <li> <p>UpgraderWallet: One instance of the multi sig wallet, defined as <code>upgrader</code>. This wallet will be assigned as zos admin and is required to do upgrades.</p> </li> <li> <p>OwnerWallet: One instance of the multi sig wallet, defined as <code>owner</code>. This wallet will be assigned as the owner of all the contracts. It can be used to call specific functions in the contracts ie. change the configuration.</p> </li> <li> <p>GovernorWallet: One instance of the multi sig wallet, defined as <code>governor</code>. This wallet will be assigned as zos admin and is required to do config updates in a Nevermined deployment.</p> </li> </ul>"},{"location":"Upgrades/#deploy-upgrade","title":"Deploy &amp; Upgrade","text":"<p><code>zos</code> does not support migrations, hence all the initial configuration should be performed with Nevermined Contract Tools. Contract constructors are ignored so the initial setup of the contract should be made in a <code>initialize</code> function that will be executed only once after the initial deployment.</p>"},{"location":"Upgrades/#1-configuration","title":"1. Configuration","text":"<p>Nevermined Contract Tools checks the <code>contracts.json</code> in order to detect the current contracts that are going to be deployed:</p> <pre><code>[\n  \"ConditionStoreManager\",\n  \"TemplateStoreManager\",\n  \"AgreementStoreManager\",\n  \"SignCondition\",\n  \"HashLockCondition\",\n  \"LockRewardCondition\",\n  \"NFTHolderCondition\",\n  \"AccessCondition\",\n  \"EscrowReward\",\n  \"EscrowAccessSecretStoreTemplate\",\n  \"NFTAccessTemplate\",\n  \"DIDRegistry\"\n]\n</code></pre> <p>Moreover for each network, Nevermined Contract Tools needs to detect the roles and their addresses from a pre-defined wallets config file. The following configuration should be an example for <code>wallets-&lt;NETWORK_NAME&gt;.json</code>:</p> <pre><code>[\n    {\n        \"name\": \"upgrader\",\n        \"address\": \"0x24eb26d4042a2ab576e7e39b87c3f33f276aef92\"\n    },\n    {\n        \"name\": \"owner\",\n        \"address\": \"0xd02d68c62401472ce35ba3c7e505deae62db2b8b\"\n    },\n    {\n        \"name\": \"governor\",\n        \"address\": \"0xeeff68c62401472ce35ba3c7e505deae62db2b8b\"\n    }\n]\n</code></pre>"},{"location":"Upgrades/#2-preparation","title":"2. Preparation","text":"<p>The following commands clean, install dependencies and compile the contracts:</p> <pre><code>yarn clean #to clean the work dir\nyarn #install dependencies\nyarn compile #to compile the contracts\n</code></pre>"},{"location":"Upgrades/#3-deploy-upgrade","title":"3. Deploy &amp; Upgrade","text":"<p>The following steps shows how to perform contracts deployment and upgrade on <code>Mumbai</code> and <code>&lt;Polygon&gt;</code> networks.</p>"},{"location":"Upgrades/#copy-the-files-and-artifacts","title":"Copy the files and artifacts","text":"<ul> <li>Export the <code>NETWORK_ID</code> (check in https://chainlist.org/) and contract's tag <code>TAG</code>, and latest version deployed <code>VERSION</code> for this contract release:</li> </ul> <pre><code>export NETWORK_ID=80001 # Network_ID for mumbai\nexport NETWORK=mumbai\nexport TAG=public\nexport VERSION='3.1.0'\n</code></pre> <ul> <li>Copy the .openzeppelin file for the <code>&lt;NETWORK_ID&gt;</code> and <code>&lt;TAG&gt;</code>(like <code>common</code> or <code>public</code>) deployment you want to upgrade:</li> <li><code>cp .openzeppelin/unknown-$NETWORK_ID.json.$TAG .openzeppelin/unknown-$NETWORK_ID.json</code></li> <li>Unpack the latest version of the artifacts for the <code>&lt;NETWORK_ID&gt;</code> and <code>&lt;TAG&gt;</code> in <code>artifacts</code>:</li> </ul> <pre><code>wget -O artifacts.tar.gz \"https://artifacts.nevermined.network/$NETWORK_ID/$TAG/contracts_v$VERSION.tar.gz\"\ntar xvzf artifacts.tar.gz -C artifacts/\n</code></pre> <ul> <li>run <code>export MNEMONIC=&lt;deployment's mnemonic&gt;</code>. You will find them in the password manager.</li> </ul>"},{"location":"Upgrades/#upgrade-already-deployed-core-contracts","title":"Upgrade already deployed core contracts","text":"<ul> <li>To upgrade the contracts run <code>yarn upgrade:$NETWORK</code></li> </ul>"},{"location":"Upgrades/#deploy-and-initialize-new-version-of-agreement-contracts","title":"Deploy and initialize new version of agreement contracts","text":"<ul> <li>To deploy and initialize all contracts: See the Release Process.</li> </ul> <p>This process will show multiple errors for the contracts that are being upgraded. You can ignore those messages.</p> <p>New versions are deployed with new addresses to make sure that existing agreements won't be messed up.</p>"},{"location":"Upgrades/#upgrade-the-plonk-verifier-contract-to-the-new-version","title":"Upgrade the plonk verifier contract to the new version","text":"<ul> <li>To upgrade the plonk verifier contract to the new version run <code>npx hardhat run ./scripts/deploy/upgradePlonkVerifier.js --network $NETWORK</code></li> </ul>"},{"location":"Upgrades/#upload-the-artifacts-to-the-repository-and-persist-any-change-in-openzeppelin-file","title":"Upload the artifacts to the repository and persist any change in <code>openzeppelin/</code> file","text":"<ul> <li>To upload the artifacts to the repository run:</li> </ul> <pre><code># Because we are upgrading to a specific version export which version is\nexport UPGRADE_VERSION=v3.5.4\n./scripts/upload_artifacts_gs.sh contracts $NETWORK $TAG\n./scripts/upload_artifacts_gs.sh abis $NETWORK $TAG\n./scripts/upload_artifacts_gs.sh circuits $NETWORK $TAG\n</code></pre> <ul> <li> <p>Copy the openzeppeling file base on tag: <code>cp -rp .openzeppelin/unknown-$NETWORK_ID.json .openzeppelin/unknown-$NETWORK_ID.json.$TAG</code></p> </li> <li> <p>Commit all changes in <code>.openzeppelin/unknown-$NETWORK_ID.json.$TAG</code> file</p> </li> <li> <p>Verify the changes</p> </li> </ul> <pre><code>nodejs ./scripts/contracts/verify-contracts.js $UPGRADE_VERSION $NETWORK $TAG\n</code></pre>"},{"location":"Upgrades/#4-approve-upgrades-no-applicable-for-current-deployments-","title":"4. Approve Upgrade(s) -no applicable for current deployments-","text":"<p>All upgrades of the contracts have to be approved by the <code>upgrader</code> wallet configured in the <code>wallets.json</code> file.</p> <ul> <li>go to https://wallet.gnosis.pm</li> <li>Load <code>upgrader</code> wallet</li> <li>Select an Ethereum Account that is an <code>owner</code> of the multi sig wallet, but not the one who issued the upgrade request. This can be done in the following ways:</li> <li>Connect to a local Blockchain node that holds the private key.</li> <li>Connect to MetaMask and select the owner account from the multi sig wallet.</li> <li>Connect a hardware wallet like ledger or trezor.</li> <li>Select the transaction you want to confirm (the upgrade script will tell you which transactions have to be approved in which wallets)</li> <li>Click Confirm</li> </ul>"},{"location":"Upgrades/#5-audit-contracts-no-applicable-for-current-deployments-","title":"5. Audit Contracts -no applicable for current deployments-","text":"<p>To check or document that all transactions have been approved in the multi sig wallet you can run <code>yarn audit:rinkeby</code> to get a list of all the current transactions and their current status.</p> <pre><code> Wallet: 0x24EB26D4042a2AB576E7E39b87c3f33f276AeF92\n\n Transaction ID: 64\n Destination: 0xfA16d26e9F4fffC6e40963B281a0bB08C31ed40C\n Contract: EscrowAccessSecretStoreTemplate\n Data is `upgradeTo` call: true\n Confirmed from: 0x7A13E1aD23546c9b804aDFd13e9AcB184EfCAF58\n Executed: false\n</code></pre>"},{"location":"Upgrades/#6-typical-problems-and-workarounds","title":"6. Typical problems and workarounds","text":"<p>Workarounds for some of the operational problems suffered to the date. For these, you have to configure your environment as for any upgrade (replacing openzeppelin files, artifacts, exporting mnemnic, running <code>yarn</code>, <code>yarn compile</code>, ...).</p>"},{"location":"Upgrades/#transfer-proxy-address-ownership-to-upgrader-wallet","title":"Transfer Proxy Address Ownership to Upgrader Wallet","text":"<ul> <li> <p>Get the DIDRegistry contract address from the <code>artifacts/DIDRegistry.json</code> file: <code>cat artifacts/DIDRegistry.mumbai.json| grep -i '\"address\":'</code></p> </li> <li> <p>Run the <code>hardhat</code> console: <code>npx hardhat console --network mumbai</code></p> </li> <li> <p>Execute the next snippet replacing the <code>&lt;DIDRegistryAddress&gt;</code> with the DIDRegistry contract address:</p> </li> </ul> <pre><code>const PROXY_ADMIN_ABI = `[{\n    \"inputs\": [],\n    \"name\": \"owner\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }, {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"newOwner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"transferOwnership\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n}]`\n\nconst DIDRegistry = '&lt;DIDRegistryAddress&gt;'\nconst addr = await ethers.provider.getStorageAt(DIDRegistry, '0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103')\nconsole.log('Proxy admin address', addr)\nconst admin = new ethers.Contract('0x' + addr.substring(26), PROXY_ADMIN_ABI, ethers.provider)\nconst adminOwner = await admin.owner()\nconsole.log('Proxy admin owner', adminOwner)\nconst signer = ethers.provider.getSigner(adminOwner)\nconst accounts = await web3.eth.getAccounts()\nconst upgraderWallet = accounts[8]\nawait admin.connect(signer).transferOwnership(upgraderWallet)\n</code></pre>"},{"location":"Upgrades/#cannot-upgrade-error-deployment-at-address-0x-is-not-registered","title":"Cannot upgrade Error: Deployment at address 0x... is not registered","text":"<p>This happens when the contract is not registered in openzeppelin file. It can be fixed using the <code>forceImport</code> function from openzeppelin library.</p> <p>Given the next error:</p> <pre><code>upgrading NFT721EscrowPaymentCondition at 0x7fF506C7148a46e57b8A349C1F848F0cC6d9Cfa8\nCannot upgrade Error: Deployment at address 0xB54C6A5d60cB3984f8120EFA0c629a59DA8881aA is not registered\n\nTo register a previously deployed proxy for upgrading, use the forceImport function.\n\n/Users/jcortejoso/Projects/nevermined/contracts/node_modules/@openzeppelin/upgrades-core/src/manifest-storage-layout.ts:20\n    throw new UpgradesError(\n          ^\nError: Deployment at address 0xB54C6A5d60cB3984f8120EFA0c629a59DA8881aA is not registered\n\nTo register a previously deployed proxy for upgrading, use the forceImport function.\n    at getStorageLayoutForAddress (/Users/jcortejoso/Projects/nevermined/contracts/node_modules/@openzeppelin/upgrades-core/src/manifest-storage-layout.ts:20:11)\n    at deployImpl (/Users/jcortejoso/Projects/nevermined/contracts/node_modules/@openzeppelin/hardhat-upgrades/src/utils/deploy-impl.ts:108:27)\n    at Proxy.prepareUpgrade (/Users/jcortejoso/Projects/nevermined/contracts/node_modules/@openzeppelin/hardhat-upgrades/src/prepare-upgrade.ts:25:22)\n    at upgradeContracts (/Users/jcortejoso/Projects/nevermined/contracts/scripts/deploy/truffle-wrapper/upgradeContracts.js:76:29)\n    at main (/Users/jcortejoso/Projects/nevermined/contracts/scripts/deploy/truffle-wrapper/upgradeContractsWrapper.js:9:5)\nerror Command failed with exit code 1.\ninfo Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\nerror Command failed with exit code 1.\ninfo Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\n</code></pre> <p>To fix it you can run the next commands in <code>hardhat</code> console, replacing the contract name and the proxy address (<code>npx hardhat console --network mumbai</code>):</p> <pre><code>const { ethers, upgrades, web3 } = require('hardhat')\nconst factory = await ethers.getContractFactory('NFT721EscrowPaymentCondition')\nconst update = await upgrades.forceImport(\"0x7fF506C7148a46e57b8A349C1F848F0cC6d9Cfa8\", factory, {kind: \"transparent\"})\n.exit\n</code></pre>"},{"location":"contracts/Common/","title":"Common","text":""},{"location":"contracts/Common/#functions","title":"Functions","text":""},{"location":"contracts/Common/#getcurrentblocknumber","title":"getCurrentBlockNumber","text":"<p><pre><code>  function getCurrentBlockNumber(\n  ) external returns (uint256)\n</code></pre> getCurrentBlockNumber get block number</p>"},{"location":"contracts/Common/#return-values","title":"Return Values:","text":"Name Type Description <code>the</code> current block number ### isContract <pre><code>  function isContract(\n  ) public returns (bool)\n</code></pre> <p>isContract detect whether the address is           is a contract address or externally owned account</p>"},{"location":"contracts/Common/#return-values_1","title":"Return Values:","text":"Name Type Description <code>true</code> address if it is a contract address ### provenanceSignatureIsCorrect <pre><code>  function provenanceSignatureIsCorrect(\n    address _agentId,\n    bytes32 _hash,\n    bytes _signature\n  ) public returns (bool)\n</code></pre>"},{"location":"contracts/Common/#parameters","title":"Parameters:","text":"Name Type Description <code>_agentId</code> address The address of the agent <code>_hash</code> bytes32 bytes32 message, the hash is the signed message. What is recovered is the signer address. <code>_signature</code> bytes Signatures provided by the agent"},{"location":"contracts/Common/#return-values_2","title":"Return Values:","text":"Name Type Description <code>true</code> address if the signature correspond to the agent address ### calculateTotalAmount <pre><code>  function calculateTotalAmount(\n  ) public returns (uint256)\n</code></pre> <p>Sum the total amount given an uint array</p>"},{"location":"contracts/Common/#return-values_3","title":"Return Values:","text":"Name Type Description <code>the</code> uint256[] total amount"},{"location":"contracts/Dispenser/","title":"Dispenser","text":""},{"location":"contracts/Dispenser/#functions","title":"Functions","text":""},{"location":"contracts/Dispenser/#initialize","title":"initialize","text":"<pre><code>  function initialize(\n    address _tokenAddress,\n    address _owner\n  ) external\n</code></pre> <p>Dispenser Initializer</p>"},{"location":"contracts/Dispenser/#parameters","title":"Parameters:","text":"Name Type Description <code>_tokenAddress</code> address The deployed contract address of an ERC20 <code>_owner</code> address The owner of the Dispenser Runs only on initial contract creation."},{"location":"contracts/Dispenser/#requesttokens","title":"requestTokens","text":"<pre><code>  function requestTokens(\n    uint256 amount\n  ) external returns (bool tokensTransferred)\n</code></pre> <p>user can request some tokens for testing</p>"},{"location":"contracts/Dispenser/#parameters_1","title":"Parameters:","text":"Name Type Description <code>amount</code> uint256 the amount of tokens to be requested"},{"location":"contracts/Dispenser/#return-values","title":"Return Values:","text":"Name Type Description <code>tokensTransferred</code> uint256 Boolean indication of tokens are requested ### setMinPeriod <pre><code>  function setMinPeriod(\n    uint256 period\n  ) external\n</code></pre> <p>the Owner can set the min period for token requests</p>"},{"location":"contracts/Dispenser/#parameters_2","title":"Parameters:","text":"Name Type Description <code>period</code> uint256 the min amount of time before next request"},{"location":"contracts/Dispenser/#setmaxamount","title":"setMaxAmount","text":"<pre><code>  function setMaxAmount(\n    uint256 amount\n  ) external\n</code></pre> <p>the Owner can set the max amount for token requests</p>"},{"location":"contracts/Dispenser/#parameters_3","title":"Parameters:","text":"Name Type Description <code>amount</code> uint256 the max amount of tokens that can be requested"},{"location":"contracts/Dispenser/#setmaxmintamount","title":"setMaxMintAmount","text":"<pre><code>  function setMaxMintAmount(\n    uint256 amount\n  ) external\n</code></pre> <p>the Owner can set the max amount for token requests</p>"},{"location":"contracts/Dispenser/#parameters_4","title":"Parameters:","text":"Name Type Description <code>amount</code> uint256 the max amount of tokens that can be requested"},{"location":"contracts/Dispenser/#events","title":"Events","text":""},{"location":"contracts/Dispenser/#requestfrequencyexceeded","title":"RequestFrequencyExceeded","text":"<pre><code>  event RequestFrequencyExceeded(\n  )\n</code></pre>"},{"location":"contracts/Dispenser/#requestlimitexceeded","title":"RequestLimitExceeded","text":"<pre><code>  event RequestLimitExceeded(\n  )\n</code></pre>"},{"location":"contracts/HashLists/","title":"HashLists","text":"<p>Hash lists contract is a sample list contract in which uses       HashListLibrary.sol in order to store, retrieve, remove, and       update bytes32 values in hash lists.      This is a reference implementation for IList interface. It is       used for whitelisting condition. Any entity can have its own       implementation of the interface in which could be used for the      same condition.</p>"},{"location":"contracts/HashLists/#functions","title":"Functions","text":""},{"location":"contracts/HashLists/#initialize","title":"initialize","text":"<pre><code>  function initialize(\n    address _owner\n  ) public\n</code></pre> <p>HashLists Initializer</p>"},{"location":"contracts/HashLists/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address The owner of the hash list Runs only upon contract creation."},{"location":"contracts/HashLists/#hash","title":"hash","text":"<pre><code>  function hash(\n    address account\n  ) public returns (bytes32)\n</code></pre> <p>hash ethereum accounts</p>"},{"location":"contracts/HashLists/#parameters_1","title":"Parameters:","text":"Name Type Description <code>account</code> address Ethereum address"},{"location":"contracts/HashLists/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> address hash of the account ### add <pre><code>  function add(\n    bytes32[] values\n  ) external returns (bool)\n</code></pre> <p>put an array of elements without indexing      this meant to save gas in case of large arrays</p>"},{"location":"contracts/HashLists/#parameters_2","title":"Parameters:","text":"Name Type Description <code>values</code> bytes32[] is an array of elements value"},{"location":"contracts/HashLists/#return-values_1","title":"Return Values:","text":"Name Type Description <code>true</code> bytes32[] if values are added successfully ### add <pre><code>  function add(\n    bytes32 value\n  ) external returns (bool)\n</code></pre> <p>add indexes an element then adds it to a list</p>"},{"location":"contracts/HashLists/#parameters_3","title":"Parameters:","text":"Name Type Description <code>value</code> bytes32 is a bytes32 value"},{"location":"contracts/HashLists/#return-values_2","title":"Return Values:","text":"Name Type Description <code>true</code> bytes32 if value is added successfully ### update <pre><code>  function update(\n    bytes32 oldValue,\n    bytes32 newValue\n  ) external returns (bool)\n</code></pre> <p>update the value with a new value and maintain indices</p>"},{"location":"contracts/HashLists/#parameters_4","title":"Parameters:","text":"Name Type Description <code>oldValue</code> bytes32 is an element value in a list <code>newValue</code> bytes32 new value"},{"location":"contracts/HashLists/#return-values_3","title":"Return Values:","text":"Name Type Description <code>true</code> bytes32 if value is updated successfully ### index <pre><code>  function index(\n    uint256 from,\n    uint256 to\n  ) external returns (bool)\n</code></pre> <p>index is used to map each element value to its index on the list </p>"},{"location":"contracts/HashLists/#parameters_5","title":"Parameters:","text":"Name Type Description <code>from</code> uint256 index is where to 'from' indexing in the list <code>to</code> uint256 index is where to stop indexing"},{"location":"contracts/HashLists/#return-values_4","title":"Return Values:","text":"Name Type Description <code>true</code> uint256 if the sub list is indexed ### has <pre><code>  function has(\n    bytes32 id,\n    bytes32 value\n  ) external returns (bool)\n</code></pre> <p>has checks whether a value is exist</p>"},{"location":"contracts/HashLists/#parameters_6","title":"Parameters:","text":"Name Type Description <code>id</code> bytes32 the list identifier (the hash of list owner's address) <code>value</code> bytes32 is element value in list"},{"location":"contracts/HashLists/#return-values_5","title":"Return Values:","text":"Name Type Description <code>true</code> bytes32 if the value exists ### has <pre><code>  function has(\n    bytes32 value\n  ) external returns (bool)\n</code></pre> <p>has checks whether a value is exist</p>"},{"location":"contracts/HashLists/#parameters_7","title":"Parameters:","text":"Name Type Description <code>value</code> bytes32 is element value in list"},{"location":"contracts/HashLists/#return-values_6","title":"Return Values:","text":"Name Type Description <code>true</code> bytes32 if the value exists ### remove <pre><code>  function remove(\n    bytes32 value\n  ) external returns (bool)\n</code></pre> <p>remove value from a list, updates indices, and list size </p>"},{"location":"contracts/HashLists/#parameters_8","title":"Parameters:","text":"Name Type Description <code>value</code> bytes32 is an element value in a list"},{"location":"contracts/HashLists/#return-values_7","title":"Return Values:","text":"Name Type Description <code>true</code> bytes32 if value is removed successfully ### get <pre><code>  function get(\n    bytes32 id,\n    uint256 _index\n  ) external returns (bytes32)\n</code></pre> <p>has value by index </p>"},{"location":"contracts/HashLists/#parameters_9","title":"Parameters:","text":"Name Type Description <code>id</code> bytes32 the list identifier (the hash of list owner's address) <code>_index</code> uint256 is where is value is stored in the list"},{"location":"contracts/HashLists/#return-values_8","title":"Return Values:","text":"Name Type Description <code>the</code> bytes32 value if exists ### size <pre><code>  function size(\n    bytes32 id\n  ) external returns (uint256)\n</code></pre> <p>size gets the list size</p>"},{"location":"contracts/HashLists/#parameters_10","title":"Parameters:","text":"Name Type Description <code>id</code> bytes32 the list identifier (the hash of list owner's address)"},{"location":"contracts/HashLists/#return-values_9","title":"Return Values:","text":"Name Type Description <code>total</code> bytes32 length of the list ### all <pre><code>  function all(\n    bytes32 id\n  ) external returns (bytes32[])\n</code></pre> <p>all returns all list elements</p>"},{"location":"contracts/HashLists/#parameters_11","title":"Parameters:","text":"Name Type Description <code>id</code> bytes32 the list identifier (the hash of list owner's address)"},{"location":"contracts/HashLists/#return-values_10","title":"Return Values:","text":"Name Type Description <code>all</code> bytes32 list elements ### indexOf <pre><code>  function indexOf(\n    bytes32 id,\n    bytes32 value\n  ) external returns (uint256)\n</code></pre> <p>indexOf gets the index of a value in a list</p>"},{"location":"contracts/HashLists/#parameters_12","title":"Parameters:","text":"Name Type Description <code>id</code> bytes32 the list identifier (the hash of list owner's address) <code>value</code> bytes32 is element value in list"},{"location":"contracts/HashLists/#return-values_11","title":"Return Values:","text":"Name Type Description <code>value</code> bytes32 index in list ### ownedBy <pre><code>  function ownedBy(\n    bytes32 id\n  ) external returns (address)\n</code></pre> <p>ownedBy gets the list owner</p>"},{"location":"contracts/HashLists/#parameters_13","title":"Parameters:","text":"Name Type Description <code>id</code> bytes32 the list identifier (the hash of list owner's address)"},{"location":"contracts/HashLists/#return-values_12","title":"Return Values:","text":"Name Type Description <code>list</code> bytes32 owner ### isIndexed <pre><code>  function isIndexed(\n    bytes32 id\n  ) external returns (bool)\n</code></pre> <p>isIndexed checks if the list is indexed</p>"},{"location":"contracts/HashLists/#parameters_14","title":"Parameters:","text":"Name Type Description <code>id</code> bytes32 the list identifier (the hash of list owner's address)"},{"location":"contracts/HashLists/#return-values_13","title":"Return Values:","text":"Name Type Description <code>true</code> bytes32 if the list is indexed"},{"location":"contracts/NeverminedToken/","title":"NeverminedToken","text":"<p>Implementation of a Test Token.      Test Token is an ERC20 token only for testing purposes</p>"},{"location":"contracts/NeverminedToken/#functions","title":"Functions","text":""},{"location":"contracts/NeverminedToken/#initialize","title":"initialize","text":"<pre><code>  function initialize(\n    address _owner,\n    address payable _initialMinter\n  ) public\n</code></pre> <p>NeverminedToken Initializer      Runs only on initial contract creation.</p>"},{"location":"contracts/NeverminedToken/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address refers to the owner of the contract <code>_initialMinter</code> address payable is the first token minter added"},{"location":"contracts/NeverminedToken/#_beforetokentransfer","title":"_beforeTokenTransfer","text":"<pre><code>  function _beforeTokenTransfer(\n  ) internal\n</code></pre> <p>See {ERC20-_beforeTokenTransfer}.</p> <p>Requirements:</p> <ul> <li>minted tokens must not cause the total supply to go over the cap.</li> </ul>"},{"location":"contracts/NeverminedToken/#mint","title":"mint","text":"<pre><code>  function mint(\n  ) external returns (bool)\n</code></pre> <p>Creates <code>amount</code> tokens and assigns them to <code>account</code>, increasing the total supply.</p> <p>Emits a {Transfer} event with <code>from</code> set to the zero address.</p> <p>Requirements:</p> <ul> <li><code>to</code> cannot be the zero address.</li> </ul>"},{"location":"contracts/PlonkVerifier/","title":"PlonkVerifier","text":""},{"location":"contracts/PlonkVerifier/#functions","title":"Functions","text":""},{"location":"contracts/PlonkVerifier/#verifyproof","title":"verifyProof","text":"<pre><code>  function verifyProof(\n  ) public returns (bool)\n</code></pre>"},{"location":"contracts/agreements/AgreementStoreLibrary/","title":"AgreementStoreLibrary","text":"<p>Implementation of the Agreement Store Library.      The agreement store library holds the business logic      in which manages the life cycle of SEA agreement, each      agreement is linked to the DID of an asset, template, and      condition IDs.</p>"},{"location":"contracts/agreements/AgreementStoreLibrary/#functions","title":"Functions","text":""},{"location":"contracts/agreements/AgreementStoreLibrary/#create","title":"create","text":"<pre><code>  function create(\n    struct AgreementStoreLibrary.AgreementList _self,\n    bytes32 _id,\n    bytes32 _did,\n    address _templateId,\n    bytes32[] _conditionIds\n  ) internal returns (uint256 size)\n</code></pre> <p>create new agreement      checks whether the agreement Id exists, creates new agreement      instance, including the template, conditions and DID.</p>"},{"location":"contracts/agreements/AgreementStoreLibrary/#parameters","title":"Parameters:","text":"Name Type Description <code>_self</code> struct AgreementStoreLibrary.AgreementList is AgreementList storage pointer <code>_id</code> bytes32 agreement identifier <code>_did</code> bytes32 asset decentralized identifier <code>_templateId</code> address template identifier <code>_conditionIds</code> bytes32[] array of condition identifiers"},{"location":"contracts/agreements/AgreementStoreLibrary/#return-values","title":"Return Values:","text":"Name Type Description <code>size</code> struct AgreementStoreLibrary.AgreementList which is the index of the created agreement"},{"location":"contracts/agreements/AgreementStoreManager/","title":"AgreementStoreManager","text":"<p>Implementation of the Agreement Store.</p> <pre><code> The agreement store generates conditions for an agreement template.\n Agreement templates must to be approved in the Template Store\n Each agreement is linked to the DID of an asset.\n</code></pre>"},{"location":"contracts/agreements/AgreementStoreManager/#functions","title":"Functions","text":""},{"location":"contracts/agreements/AgreementStoreManager/#initialize","title":"initialize","text":"<pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress,\n    address _templateStoreManagerAddress,\n    address _didRegistryAddress\n  ) public\n</code></pre> <p>initialize AgreementStoreManager Initializer      Initializes Ownable. Only on contract creation.</p>"},{"location":"contracts/agreements/AgreementStoreManager/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address refers to the owner of the contract <code>_conditionStoreManagerAddress</code> address is the address of the connected condition store <code>_templateStoreManagerAddress</code> address is the address of the connected template store <code>_didRegistryAddress</code> address is the address of the connected DID Registry"},{"location":"contracts/agreements/AgreementStoreManager/#createagreement","title":"createAgreement","text":"<pre><code>  function createAgreement(\n    bytes32 _id,\n    bytes32 _did,\n    address[] _conditionTypes,\n    bytes32[] _conditionIds,\n    uint256[] _timeLocks,\n    uint256[] _timeOuts\n  ) public returns (uint256 size)\n</code></pre> <p>Create a new agreement and associate the agreement created to the address originating the transaction.      The agreement will create conditions of conditionType with conditionId.      Only \"approved\" templates can access this function.</p>"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 is the ID of the new agreement. Must be unique. <code>_did</code> bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. <code>_conditionTypes</code> address[] is a list of addresses that point to Condition contracts. <code>_conditionIds</code> bytes32[] is a list of bytes32 content-addressed Condition IDs <code>_timeLocks</code> uint256[] is a list of uint time lock values associated to each Condition <code>_timeOuts</code> uint256[] is a list of uint time out values associated to each Condition"},{"location":"contracts/agreements/AgreementStoreManager/#return-values","title":"Return Values:","text":"Name Type Description <code>size</code> bytes32 the size of the agreement list after the create action. ### createAgreement <pre><code>  function createAgreement(\n    bytes32 _id,\n    bytes32 _did,\n    address[] _conditionTypes,\n    bytes32[] _conditionIds,\n    uint256[] _timeLocks,\n    uint256[] _timeOuts,\n    address _creator\n  ) public returns (uint256 size)\n</code></pre> <p>Create a new agreement.      The agreement will create conditions of conditionType with conditionId.      Only \"approved\" templates can access this function.</p>"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 is the ID of the new agreement. Must be unique. <code>_did</code> bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. <code>_conditionTypes</code> address[] is a list of addresses that point to Condition contracts. <code>_conditionIds</code> bytes32[] is a list of bytes32 content-addressed Condition IDs <code>_timeLocks</code> uint256[] is a list of uint time lock values associated to each Condition <code>_timeOuts</code> uint256[] is a list of uint time out values associated to each Condition <code>_creator</code> address address of the account associated as agreement and conditions creator"},{"location":"contracts/agreements/AgreementStoreManager/#return-values_1","title":"Return Values:","text":"Name Type Description <code>size</code> bytes32 the size of the agreement list after the create action. ### getAgreement <pre><code>  function getAgreement(\n    bytes32 _id\n  ) external returns (bytes32 did, address didOwner, address templateId, bytes32[] conditionIds, address lastUpdatedBy, uint256 blockNumberUpdated)\n</code></pre> <p>Get agreement with _id.      The agreement will create conditions of conditionType with conditionId.      Only \"approved\" templates can access this function.</p>"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 is the ID of the agreement."},{"location":"contracts/agreements/AgreementStoreManager/#getagreementdidowner","title":"getAgreementDIDOwner","text":"<pre><code>  function getAgreementDIDOwner(\n    bytes32 _id\n  ) external returns (address didOwner)\n</code></pre> <p>get the DID owner for this agreement with _id.</p>"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 is the ID of the agreement."},{"location":"contracts/agreements/AgreementStoreManager/#return-values_2","title":"Return Values:","text":"Name Type Description <code>didOwner</code> bytes32 the DID owner associated with agreement.did from the DID registry. ### isAgreementDIDOwner <pre><code>  function isAgreementDIDOwner(\n    bytes32 _id,\n    address _owner\n  ) external returns (bool)\n</code></pre> <p>check the DID owner for this agreement with _id.</p>"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_5","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 is the ID of the agreement. <code>_owner</code> address is the DID owner"},{"location":"contracts/agreements/AgreementStoreManager/#return-values_3","title":"Return Values:","text":"Name Type Description <code>the</code> bytes32 DID owner associated with agreement.did from the DID registry. ### isAgreementDIDProvider <pre><code>  function isAgreementDIDProvider(\n    bytes32 _id,\n    address _provider\n  ) external returns (bool)\n</code></pre> <p>isAgreementDIDProvider for a given agreement Id  and address check whether a DID provider is associated with this agreement</p>"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_6","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 is the ID of the agreement <code>_provider</code> address is the DID provider"},{"location":"contracts/agreements/AgreementStoreManager/#return-values_4","title":"Return Values:","text":"Name Type Description <code>true</code> bytes32 if a DID provider is associated with the agreement ID ### getAgreementListSize <pre><code>  function getAgreementListSize(\n  ) public returns (uint256 size)\n</code></pre>"},{"location":"contracts/agreements/AgreementStoreManager/#return-values_5","title":"Return Values:","text":"Name Type Description <code>size</code> the length of the agreement list. ### getAgreementIdsForDID <pre><code>  function getAgreementIdsForDID(\n    bytes32 _did\n  ) public returns (bytes32[])\n</code></pre>"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_7","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 is the bytes32 DID of the asset."},{"location":"contracts/agreements/AgreementStoreManager/#return-values_6","title":"Return Values:","text":"Name Type Description <code>the</code> bytes32 agreement IDs for a given DID ### getAgreementIdsForTemplateId <pre><code>  function getAgreementIdsForTemplateId(\n    address _templateId\n  ) public returns (bytes32[])\n</code></pre>"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_8","title":"Parameters:","text":"Name Type Description <code>_templateId</code> address is the address of the agreement template."},{"location":"contracts/agreements/AgreementStoreManager/#return-values_7","title":"Return Values:","text":"Name Type Description <code>the</code> address agreement IDs for a given DID ### getDIDRegistryAddress <pre><code>  function getDIDRegistryAddress(\n  ) public returns (address)\n</code></pre> <p>getDIDRegistryAddress utility function  used by other contracts or any EOA.</p>"},{"location":"contracts/agreements/AgreementStoreManager/#return-values_8","title":"Return Values:","text":"Name Type Description <code>the</code> DIDRegistry address"},{"location":"contracts/conditions/AccessCondition/","title":"AccessCondition","text":"<p>Implementation of the Access Condition</p> <pre><code> Access Secret Store Condition is special condition\n where a client or Parity secret store can encrypt/decrypt documents \n based on the on-chain granted permissions. For a given DID \n document, and agreement ID, the owner/provider of the DID \n will fulfill the condition. Consequently secret store \n will check whether the permission is granted for the consumer\n in order to encrypt/decrypt the document.\n</code></pre>"},{"location":"contracts/conditions/AccessCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/AccessCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress,\n    address _agreementStoreManagerAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/AccessCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address <code>_agreementStoreManagerAddress</code> address agreement store manager address"},{"location":"contracts/conditions/AccessCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _documentId,\n    address _grantee\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/AccessCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_documentId</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_grantee</code> address is the address of the granted user or the DID provider"},{"location":"contracts/conditions/AccessCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _documentId,\n    address _grantee\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill access secret store condition <p>only DID owner or DID provider can call this       method. Fulfill method sets the permissions        for the granted consumer's address to true then       fulfill the condition</p>"},{"location":"contracts/conditions/AccessCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 agreement identifier <code>_documentId</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_grantee</code> address is the address of the granted user or the DID provider"},{"location":"contracts/conditions/AccessCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state (Fulfilled/Aborted) ### grantPermission <pre><code>  function grantPermission(\n    address _grantee,\n    bytes32 _documentId\n  ) public\n</code></pre> grantPermission is called only by DID owner or provider"},{"location":"contracts/conditions/AccessCondition/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_grantee</code> address is the address of the granted user or the DID provider <code>_documentId</code> bytes32 refers to the DID in which secret store will issue the decryption keys"},{"location":"contracts/conditions/AccessCondition/#renouncepermission","title":"renouncePermission","text":"<p><pre><code>  function renouncePermission(\n    address _grantee,\n    bytes32 _documentId\n  ) public\n</code></pre> renouncePermission is called only by DID owner or provider</p>"},{"location":"contracts/conditions/AccessCondition/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_grantee</code> address is the address of the granted user or the DID provider <code>_documentId</code> bytes32 refers to the DID in which secret store will issue the decryption keys"},{"location":"contracts/conditions/AccessCondition/#checkpermissions","title":"checkPermissions","text":"<p><pre><code>  function checkPermissions(\n    address _documentId,\n    bytes32 _grantee\n  ) external returns (bool permissionGranted)\n</code></pre> checkPermissions is called by Parity secret store</p>"},{"location":"contracts/conditions/AccessCondition/#parameters_5","title":"Parameters:","text":"Name Type Description <code>_documentId</code> address refers to the DID in which secret store will issue the decryption keys <code>_grantee</code> bytes32 is the address of the granted user or the DID provider"},{"location":"contracts/conditions/AccessCondition/#return-values_2","title":"Return Values:","text":"Name Type Description <code>permissionGranted</code> address true if the access was granted ## Events ### Fulfilled <pre><code>  event Fulfilled(\n  )\n</code></pre>"},{"location":"contracts/conditions/AccessProofCondition/","title":"AccessProofCondition","text":"<p>Implementation of the Access Condition with transfer proof. The idea is that the hash of the decryption key is known before hand, and the key matching this hash is passed from data provider to the buyer using this smart contract. Using ZK proof the key is kept hidden from outsiders. For the protocol to work, both the provider and buyer need to have public keys in the babyjub curve. To initiate the deal, buyer will pass the key hash and the public keys of participants. The provider needs to pass the cipher text encrypted using MIMC (symmetric encryption). The secret key for MIMC is computed using ECDH (requires one public key and one secret key for the curve). The hash function that is used is Poseidon.</p>"},{"location":"contracts/conditions/AccessProofCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/AccessProofCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress,\n    address _agreementStoreManagerAddress,\n    address _disputeManagerAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/AccessProofCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address <code>_agreementStoreManagerAddress</code> address agreement store manager address <code>_disputeManagerAddress</code> address dispute manager address"},{"location":"contracts/conditions/AccessProofCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    uint256 _origHash,\n    uint256[2] _buyer,\n    uint256[2] _provider\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/AccessProofCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_origHash</code> uint256 is the hash of the key <code>_buyer</code> uint256[2] buyer public key <code>_provider</code> uint256[2] provider public key"},{"location":"contracts/conditions/AccessProofCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> uint256 hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    uint256 _origHash,\n    uint256[2] _buyer,\n    uint256[2] _provider,\n    uint256[2] _cipher,\n    bytes _proof\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill key transfer <p>The key with hash _origHash is transferred to the _buyer from _provider.</p>"},{"location":"contracts/conditions/AccessProofCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 associated agreement <code>_origHash</code> uint256 is the hash of data to access <code>_buyer</code> uint256[2] buyer public key <code>_provider</code> uint256[2] provider public key <code>_cipher</code> uint256[2] encrypted version of the key <code>_proof</code> bytes SNARK proof that the cipher text can be decrypted by buyer to give the key with hash _origHash"},{"location":"contracts/conditions/AccessProofCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled <pre><code>  event Fulfilled(\n  )\n</code></pre>"},{"location":"contracts/conditions/ComputeExecutionCondition/","title":"ComputeExecutionCondition","text":"<p>Implementation of the Compute Execution Condition      This condition is meant to be a signal in which triggers      the execution of a compute service. The compute service is fully described      in the associated DID document. The provider of the compute service will      send this signal to its workers by fulfilling the condition where      they are listening to the fulfilled event.</p>"},{"location":"contracts/conditions/ComputeExecutionCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/ComputeExecutionCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress,\n    address _agreementStoreManagerAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/ComputeExecutionCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address <code>_agreementStoreManagerAddress</code> address agreement store manager address"},{"location":"contracts/conditions/ComputeExecutionCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _did,\n    address _computeConsumer\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/ComputeExecutionCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service <code>_computeConsumer</code> address is the consumer's address"},{"location":"contracts/conditions/ComputeExecutionCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _did,\n    address _computeConsumer\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill compute execution condition <p>only the compute provider can fulfill this condition. By fulfilling this  condition the compute provider will trigger the execution of  the offered job/compute. The compute service is described in a DID document.</p>"},{"location":"contracts/conditions/ComputeExecutionCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 agreement identifier <code>_did</code> bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service <code>_computeConsumer</code> address is the consumer's address"},{"location":"contracts/conditions/ComputeExecutionCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state (Fulfilled/Aborted) ### wasComputeTriggered <pre><code>  function wasComputeTriggered(\n    bytes32 _did,\n    address _computeConsumer\n  ) public returns (bool)\n</code></pre> wasComputeTriggered checks whether the compute is triggered or not."},{"location":"contracts/conditions/ComputeExecutionCondition/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service <code>_computeConsumer</code> address is the compute consumer's address"},{"location":"contracts/conditions/ComputeExecutionCondition/#return-values_2","title":"Return Values:","text":"Name Type Description <code>true</code> bytes32 if the compute is triggered ## Events ### Fulfilled <pre><code>  event Fulfilled(\n  )\n</code></pre>"},{"location":"contracts/conditions/Condition/","title":"Condition","text":"<p>Implementation of the Condition</p> <pre><code> Each condition has a validation function that returns either FULFILLED, \n ABORTED or UNFULFILLED. When a condition is successfully solved, we call \n it FULFILLED. If a condition cannot be FULFILLED anymore due to a timeout \n or other types of counter-proofs, the condition is ABORTED. UNFULFILLED \n values imply that a condition has not been provably FULFILLED or ABORTED. \n All initialized conditions start out as UNFULFILLED.\n</code></pre>"},{"location":"contracts/conditions/Condition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/Condition/#generateid","title":"generateId","text":"<p><pre><code>  function generateId(\n    bytes32 _agreementId,\n    bytes32 _valueHash\n  ) public returns (bytes32)\n</code></pre> generateId condition Id from the following        parameters</p>"},{"location":"contracts/conditions/Condition/#parameters","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 SEA agreement ID <code>_valueHash</code> bytes32 hash of all the condition input values"},{"location":"contracts/conditions/Condition/#fulfill","title":"fulfill","text":"<p><pre><code>  function fulfill(\n    bytes32 _id,\n    enum ConditionStoreLibrary.ConditionState _newState\n  ) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill set the condition state to Fulfill | Abort</p>"},{"location":"contracts/conditions/Condition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 condition identifier <code>_newState</code> enum ConditionStoreLibrary.ConditionState new condition state (Fulfill/Abort)"},{"location":"contracts/conditions/Condition/#return-values","title":"Return Values:","text":"Name Type Description <code>the</code> bytes32 updated condition state ### abortByTimeOut <pre><code>  function abortByTimeOut(\n    bytes32 _id\n  ) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> abortByTimeOut set condition state to Aborted if the condition is timed out"},{"location":"contracts/conditions/Condition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 condition identifier"},{"location":"contracts/conditions/Condition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>the</code> bytes32 updated condition state"},{"location":"contracts/conditions/ConditionStoreLibrary/","title":"ConditionStoreLibrary","text":"<p>Implementation of the Condition Store Library.</p> <pre><code> Condition is a key component in the service execution agreement. \n This library holds the logic for creating and updating condition \n Any Condition has only four state transitions starts with Uninitialized,\n Unfulfilled, Fulfilled, and Aborted. Condition state transition goes only \n forward from Unintialized -&gt; Unfulfilled -&gt; {Fulfilled || Aborted}\n</code></pre>"},{"location":"contracts/conditions/ConditionStoreLibrary/#functions","title":"Functions","text":""},{"location":"contracts/conditions/ConditionStoreLibrary/#create","title":"create","text":"<p><pre><code>  function create(\n    struct ConditionStoreLibrary.ConditionList _self,\n    bytes32 _id,\n    address _typeRef,\n    address _creator\n  ) internal returns (uint256 size)\n</code></pre> create new condition</p> <p>check whether the condition exists, assigns        condition type, condition state, last updated by,        and update at (which is the current block number)</p>"},{"location":"contracts/conditions/ConditionStoreLibrary/#parameters","title":"Parameters:","text":"Name Type Description <code>_self</code> struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer <code>_id</code> bytes32 valid condition identifier <code>_typeRef</code> address condition contract address <code>_creator</code> address address of the condition creator"},{"location":"contracts/conditions/ConditionStoreLibrary/#return-values","title":"Return Values:","text":"Name Type Description <code>size</code> struct ConditionStoreLibrary.ConditionList is the condition index ### updateState <pre><code>  function updateState(\n    struct ConditionStoreLibrary.ConditionList _self,\n    bytes32 _id,\n    enum ConditionStoreLibrary.ConditionState _newState\n  ) internal\n</code></pre> updateState update the condition state <p>check whether the condition state transition is right,       assign the new state, update last updated by and       updated at.</p>"},{"location":"contracts/conditions/ConditionStoreLibrary/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_self</code> struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer <code>_id</code> bytes32 condition identifier <code>_newState</code> enum ConditionStoreLibrary.ConditionState the new state of the condition"},{"location":"contracts/conditions/ConditionStoreManager/","title":"ConditionStoreManager","text":"<p>Implementation of the Condition Store Manager.</p> <pre><code> Condition store manager is responsible for enforcing the \n the business logic behind creating/updating the condition state\n based on the assigned role to each party. Only specific type of\n contracts are allowed to call this contract, therefore there are \n two types of roles, create role that in which is able to create conditions.\n The second role is the update role, which is can update the condition state.\n Also, it support delegating the roles to other contract(s)/account(s).\n</code></pre>"},{"location":"contracts/conditions/ConditionStoreManager/#functions","title":"Functions","text":""},{"location":"contracts/conditions/ConditionStoreManager/#initialize","title":"initialize","text":"<pre><code>  function initialize(\n    address _owner\n  ) public\n</code></pre> <p>initialize ConditionStoreManager Initializer      Initialize Ownable. Only on contract creation, </p>"},{"location":"contracts/conditions/ConditionStoreManager/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address refers to the owner of the contract"},{"location":"contracts/conditions/ConditionStoreManager/#getcreaterole","title":"getCreateRole","text":"<pre><code>  function getCreateRole(\n  ) external returns (address)\n</code></pre> <p>getCreateRole get the address of contract      which has the create role</p>"},{"location":"contracts/conditions/ConditionStoreManager/#return-values","title":"Return Values:","text":"Name Type Description <code>create</code> condition role address ### delegateCreateRole <pre><code>  function delegateCreateRole(\n    address delegatee\n  ) external\n</code></pre> <p>delegateCreateRole only owner can delegate the       create condition role to a different address</p>"},{"location":"contracts/conditions/ConditionStoreManager/#parameters_1","title":"Parameters:","text":"Name Type Description <code>delegatee</code> address delegatee address"},{"location":"contracts/conditions/ConditionStoreManager/#delegateupdaterole","title":"delegateUpdateRole","text":"<pre><code>  function delegateUpdateRole(\n    bytes32 delegatee\n  ) external\n</code></pre> <p>delegateUpdateRole only owner can delegate       the update role to a different address for       specific condition Id which has the create role</p>"},{"location":"contracts/conditions/ConditionStoreManager/#parameters_2","title":"Parameters:","text":"Name Type Description <code>delegatee</code> bytes32 delegatee address"},{"location":"contracts/conditions/ConditionStoreManager/#createcondition","title":"createCondition","text":"<pre><code>  function createCondition(\n    bytes32 _id,\n    address _typeRef\n  ) external returns (uint256 size)\n</code></pre> <p>createCondition only called by create role address       the condition should use a valid condition contract       address, valid time lock and timeout. Moreover, it       enforce the condition state transition from       Uninitialized to Unfulfilled.</p>"},{"location":"contracts/conditions/ConditionStoreManager/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 unique condition identifier <code>_typeRef</code> address condition contract address"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_1","title":"Return Values:","text":"Name Type Description <code>size</code> bytes32 the index of the created condition ### createCondition <pre><code>  function createCondition(\n    bytes32 _id,\n    address _typeRef,\n    address _creator\n  ) external returns (uint256 size)\n</code></pre> <p>createCondition only called by create role address       the condition should use a valid condition contract       address, valid time lock and timeout. Moreover, it       enforce the condition state transition from       Uninitialized to Unfulfilled.</p>"},{"location":"contracts/conditions/ConditionStoreManager/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 unique condition identifier <code>_typeRef</code> address condition contract address <code>_creator</code> address address of the condition creator"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_2","title":"Return Values:","text":"Name Type Description <code>size</code> bytes32 the index of the created condition ### createCondition <pre><code>  function createCondition(\n    bytes32 _id,\n    address _typeRef,\n    uint256 _timeLock,\n    uint256 _timeOut,\n    address _creator\n  ) public returns (uint256 size)\n</code></pre> <p>createCondition only called by create role address       the condition should use a valid condition contract       address, valid time lock and timeout. Moreover, it       enforce the condition state transition from       Uninitialized to Unfulfilled.</p>"},{"location":"contracts/conditions/ConditionStoreManager/#parameters_5","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 unique condition identifier <code>_typeRef</code> address condition contract address <code>_timeLock</code> uint256 start of the time window <code>_timeOut</code> uint256 end of the time window <code>_creator</code> address address of the condition creator"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_3","title":"Return Values:","text":"Name Type Description <code>size</code> bytes32 the index of the created condition ### updateConditionState <pre><code>  function updateConditionState(\n    bytes32 _id\n  ) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>updateConditionState only called by update role address.       It enforce the condition state transition to either       Fulfill or Aborted state</p>"},{"location":"contracts/conditions/ConditionStoreManager/#parameters_6","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 unique condition identifier"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_4","title":"Return Values:","text":"Name Type Description <code>the</code> bytes32 current condition state ### getConditionListSize <pre><code>  function getConditionListSize(\n  ) external returns (uint256 size)\n</code></pre> <p>getConditionListSize </p>"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_5","title":"Return Values:","text":"Name Type Description <code>size</code> the length of the condition list ### getCondition <pre><code>  function getCondition(\n  ) external returns (address typeRef, enum ConditionStoreLibrary.ConditionState state, uint256 timeLock, uint256 timeOut, uint256 blockNumber, address createdBy, address lastUpdatedBy, uint256 blockNumberUpdated)\n</code></pre> <p>getCondition  </p>"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_6","title":"Return Values:","text":"Name Type Description <code>typeRef</code> bytes32 the type reference <code>state</code> condition state <code>timeLock</code> the time lock <code>timeOut</code> time out <code>blockNumber</code> block number <code>createdBy</code> address <code>lastUpdatedBy</code> address <code>blockNumberUpdated</code> block number updated ### getConditionState <pre><code>  function getConditionState(\n  ) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>getConditionState  </p>"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_7","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state ### getConditionTypeRef <pre><code>  function getConditionTypeRef(\n  ) external returns (address)\n</code></pre> <p>getConditionTypeRef  </p>"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_8","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 typeRef ### getConditionCreatedBy <pre><code>  function getConditionCreatedBy(\n  ) external returns (address)\n</code></pre> <p>getConditionCreatedBy  </p>"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_9","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 createdBy address ### isConditionTimeLocked <pre><code>  function isConditionTimeLocked(\n  ) public returns (bool)\n</code></pre> <p>isConditionTimeLocked  </p>"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_10","title":"Return Values:","text":"Name Type Description <code>whether</code> bytes32 the condition is timedLock ended ### isConditionTimedOut <pre><code>  function isConditionTimedOut(\n  ) public returns (bool)\n</code></pre> <p>isConditionTimedOut  </p>"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_11","title":"Return Values:","text":"Name Type Description <code>whether</code> bytes32 the condition is timed out ## Events ### ConditionCreated <pre><code>  event ConditionCreated(\n  )\n</code></pre>"},{"location":"contracts/conditions/ConditionStoreManager/#conditionupdated","title":"ConditionUpdated","text":"<pre><code>  event ConditionUpdated(\n  )\n</code></pre>"},{"location":"contracts/conditions/HashLockCondition/","title":"HashLockCondition","text":"<p>Implementation of the Hash Lock Condition</p>"},{"location":"contracts/conditions/HashLockCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/HashLockCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/HashLockCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address"},{"location":"contracts/conditions/HashLockCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    uint256 _preimage\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/HashLockCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_preimage</code> uint256 refers uint value of the hash pre-image."},{"location":"contracts/conditions/HashLockCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> uint256 hash of all these values ### hashValues <pre><code>  function hashValues(\n    string _preimage\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs with the following parameters"},{"location":"contracts/conditions/HashLockCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_preimage</code> string refers string value of the hash pre-image."},{"location":"contracts/conditions/HashLockCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>bytes32</code> string hash of all these values ### hashValues <pre><code>  function hashValues(\n    bytes32 _preimage\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs with the following parameters"},{"location":"contracts/conditions/HashLockCondition/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_preimage</code> bytes32 refers bytes32 value of the hash pre-image."},{"location":"contracts/conditions/HashLockCondition/#return-values_2","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId\n  ) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill the condition by calling check the the hash and the pre-image uint value"},{"location":"contracts/conditions/HashLockCondition/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 SEA agreement identifier"},{"location":"contracts/conditions/HashLockCondition/#return-values_3","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill the condition by calling check the the hash and the pre-image string value"},{"location":"contracts/conditions/HashLockCondition/#parameters_5","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 SEA agreement identifier"},{"location":"contracts/conditions/HashLockCondition/#return-values_4","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId\n  ) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill the condition by calling check the the hash and the pre-image bytes32 value"},{"location":"contracts/conditions/HashLockCondition/#parameters_6","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 SEA agreement identifier"},{"location":"contracts/conditions/HashLockCondition/#return-values_5","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state"},{"location":"contracts/conditions/IDisputeManager/","title":"IDisputeManager","text":""},{"location":"contracts/conditions/IDisputeManager/#functions","title":"Functions","text":""},{"location":"contracts/conditions/IDisputeManager/#verifyproof","title":"verifyProof","text":"<pre><code>  function verifyProof(\n  ) external returns (bool)\n</code></pre>"},{"location":"contracts/conditions/LockPaymentCondition/","title":"LockPaymentCondition","text":"<p>Implementation of the Lock Payment Condition This condition allows to lock payment for multiple receivers taking into account the royalties to be paid to the original creators in a secondary market.</p>"},{"location":"contracts/conditions/LockPaymentCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/LockPaymentCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress,\n    address _didRegistryAddress\n  ) external\n</code></pre> initialize init the contract with the following parameters</p> <p>this function is called only once during the contract initialization.</p>"},{"location":"contracts/conditions/LockPaymentCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address <code>_didRegistryAddress</code> address DID Registry address"},{"location":"contracts/conditions/LockPaymentCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _did,\n    address _rewardAddress,\n    address _tokenAddress,\n    uint256[] _amounts,\n    address[] _receivers\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/LockPaymentCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 the asset decentralized identifier <code>_rewardAddress</code> address the contract address where the reward is locked <code>_tokenAddress</code> address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment <code>_amounts</code> uint256[] token amounts to be locked/released <code>_receivers</code> address[] receiver's addresses"},{"location":"contracts/conditions/LockPaymentCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _did,\n    address payable _rewardAddress,\n    address _tokenAddress,\n    uint256[] _amounts,\n    address[] _receivers\n  ) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill requires valid token transfer in order to lock the amount of tokens based on the SEA"},{"location":"contracts/conditions/LockPaymentCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 the agreement identifier <code>_did</code> bytes32 the asset decentralized identifier <code>_rewardAddress</code> address payable the contract address where the reward is locked <code>_tokenAddress</code> address the ERC20 contract address to use during the lock payment. <code>_amounts</code> uint256[] token amounts to be locked/released <code>_receivers</code> address[] receiver's addresses"},{"location":"contracts/conditions/LockPaymentCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state ### _transferERC20 <pre><code>  function _transferERC20(\n    address _rewardAddress,\n    address _tokenAddress,\n    uint256 _amount\n  ) internal\n</code></pre> _transferERC20 transfer ERC20 tokens <p>Will throw if transfer fails</p>"},{"location":"contracts/conditions/LockPaymentCondition/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_rewardAddress</code> address the address to receive the tokens <code>_tokenAddress</code> address the ERC20 contract address to use during the payment <code>_amount</code> uint256 token amount to be locked/released"},{"location":"contracts/conditions/LockPaymentCondition/#_transfereth","title":"_transferETH","text":"<p><pre><code>  function _transferETH(\n    address payable _rewardAddress,\n    uint256 _amount\n  ) internal\n</code></pre> _transferETH transfer ETH </p>"},{"location":"contracts/conditions/LockPaymentCondition/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_rewardAddress</code> address payable the address to receive the ETH <code>_amount</code> uint256 ETH amount to be locked/released"},{"location":"contracts/conditions/LockPaymentCondition/#events","title":"Events","text":""},{"location":"contracts/conditions/LockPaymentCondition/#fulfilled","title":"Fulfilled","text":"<pre><code>  event Fulfilled(\n  )\n</code></pre>"},{"location":"contracts/conditions/SignCondition/","title":"SignCondition","text":"<p>Implementation of the Sign Condition</p>"},{"location":"contracts/conditions/SignCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/SignCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/SignCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address"},{"location":"contracts/conditions/SignCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _message,\n    address _publicKey\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/SignCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_message</code> bytes32 the message to be signed <code>_publicKey</code> address the public key of the signing address"},{"location":"contracts/conditions/SignCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _message,\n    address _publicKey,\n    bytes _signature\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill validate the signed message and fulfill the condition"},{"location":"contracts/conditions/SignCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 SEA agreement identifier <code>_message</code> bytes32 the message to be signed <code>_publicKey</code> address the public key of the signing address <code>_signature</code> bytes signature of the signed message using the public key"},{"location":"contracts/conditions/SignCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state"},{"location":"contracts/conditions/ThresholdCondition/","title":"ThresholdCondition","text":"<p>Implementation of the Threshold Condition</p> <pre><code> Threshold condition acts as a filter for a set of input condition(s) in which sends \n a signal whether to complete the flow execution or abort it. This type of conditions \n works as intermediary conditions where they wire SEA conditions in order to support  \n more complex scenarios.\n</code></pre>"},{"location":"contracts/conditions/ThresholdCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/ThresholdCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/ThresholdCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address"},{"location":"contracts/conditions/ThresholdCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32[] inputConditions,\n    uint256 threshold\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/ThresholdCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>inputConditions</code> bytes32[] array of input conditions IDs <code>threshold</code> uint256 the required number of fulfilled input conditions"},{"location":"contracts/conditions/ThresholdCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32[] hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32[] _inputConditions,\n    uint256 threshold\n  ) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill threshold condition <p>the fulfill method check whether input conditions are       fulfilled or not.</p>"},{"location":"contracts/conditions/ThresholdCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 agreement identifier <code>_inputConditions</code> bytes32[] array of input conditions IDs <code>threshold</code> uint256 the required number of fulfilled input conditions"},{"location":"contracts/conditions/ThresholdCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state (Fulfilled/Aborted)"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/","title":"TransferDIDOwnershipCondition","text":"<p>Implementation of condition allowing to transfer the ownership      between the original owner and a receiver</p>"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress,\n    address _didRegistryAddress\n  ) external\n</code></pre> initialize init the contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address <code>_didRegistryAddress</code> address DID Registry address"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _did,\n    address _receiver\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_receiver</code> address is the address of the granted user or the DID provider"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _did,\n    address _receiver\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill the transfer DID ownership condition <p>only DID owner or DID provider can call this       method. Fulfill method transfer full ownership permissions        to to _receiver address.        When true then fulfill the condition</p>"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 agreement identifier <code>_did</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_receiver</code> address is the address of the granted user"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled <pre><code>  event Fulfilled(\n  )\n</code></pre>"},{"location":"contracts/conditions/WhitelistingCondition/","title":"WhitelistingCondition","text":"<p>Implementation of the Whitelisting Condition</p>"},{"location":"contracts/conditions/WhitelistingCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/WhitelistingCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/WhitelistingCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address"},{"location":"contracts/conditions/WhitelistingCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    address _listAddress,\n    bytes32 _item\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/WhitelistingCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_listAddress</code> address list contract address <code>_item</code> bytes32 item in the list"},{"location":"contracts/conditions/WhitelistingCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> address hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    address _listAddress,\n    bytes32 _item\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill check whether address is whitelisted in order to fulfill the condition. This method will be called by any one in this whitelist."},{"location":"contracts/conditions/WhitelistingCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 SEA agreement identifier <code>_listAddress</code> address list contract address <code>_item</code> bytes32 item in the list"},{"location":"contracts/conditions/WhitelistingCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state"},{"location":"contracts/conditions/NFTs/INFTAccess/","title":"INFTAccess","text":""},{"location":"contracts/conditions/NFTs/INFTAccess/#functions","title":"Functions","text":""},{"location":"contracts/conditions/NFTs/INFTAccess/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _documentId,\n    address _grantee,\n    address _contractAddress\n  ) external returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/NFTs/INFTAccess/#parameters","title":"Parameters:","text":"Name Type Description <code>_documentId</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_grantee</code> address is the address of the granted user or the DID provider <code>_contractAddress</code> address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155)"},{"location":"contracts/conditions/NFTs/INFTAccess/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _documentId,\n    address _grantee,\n    address _contractAddress\n  ) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill NFT Access conditions <p>only DID owner or DID provider can call this       method. Fulfill method sets the permissions        for the granted consumer's address to true then       fulfill the condition</p>"},{"location":"contracts/conditions/NFTs/INFTAccess/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 agreement identifier <code>_documentId</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_grantee</code> address is the address of the granted user or the DID provider <code>_contractAddress</code> address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155)"},{"location":"contracts/conditions/NFTs/INFTAccess/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled <pre><code>  event Fulfilled(\n  )\n</code></pre>"},{"location":"contracts/conditions/NFTs/INFTHolder/","title":"INFTHolder","text":""},{"location":"contracts/conditions/NFTs/INFTHolder/#functions","title":"Functions","text":""},{"location":"contracts/conditions/NFTs/INFTHolder/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _did,\n    address _holderAddress,\n    uint256 _amount,\n    address _contractAddress\n  ) external returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/NFTs/INFTHolder/#parameters","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 the Decentralized Identifier of the asset <code>_holderAddress</code> address the address of the NFT holder <code>_amount</code> uint256 is the amount NFTs that need to be hold by the holder <code>_contractAddress</code> address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155)"},{"location":"contracts/conditions/NFTs/INFTHolder/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _did,\n    address _holderAddress,\n    uint256 _amount,\n    address _contractAddress\n  ) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill requires a validation that holder has enough NFTs for a specific DID"},{"location":"contracts/conditions/NFTs/INFTHolder/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 SEA agreement identifier <code>_did</code> bytes32 the Decentralized Identifier of the asset <code>_holderAddress</code> address the contract address where the reward is locked <code>_amount</code> uint256 is the amount of NFT to be hold <code>_contractAddress</code> address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155)"},{"location":"contracts/conditions/NFTs/INFTHolder/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state ## Events ### Fulfilled <pre><code>  event Fulfilled(\n  )\n</code></pre>"},{"location":"contracts/conditions/NFTs/ITransferNFT/","title":"ITransferNFT","text":""},{"location":"contracts/conditions/NFTs/ITransferNFT/#functions","title":"Functions","text":""},{"location":"contracts/conditions/NFTs/ITransferNFT/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _did,\n    address _nftReceiver,\n    address _nftAmount,\n    uint256 _lockCondition\n  ) external returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/NFTs/ITransferNFT/#parameters","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_nftReceiver</code> address is the address of the granted user or the DID provider <code>_nftAmount</code> address amount of NFTs to transfer <code>_lockCondition</code> uint256 lock condition identifier"},{"location":"contracts/conditions/NFTs/ITransferNFT/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _did,\n    address _nftReceiver,\n    uint256 _nftAmount,\n    bytes32 _lockPaymentCondition\n  ) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill the transfer NFT condition <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p>"},{"location":"contracts/conditions/NFTs/ITransferNFT/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 agreement identifier <code>_did</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_nftReceiver</code> address is the address of the account to receive the NFT <code>_nftAmount</code> uint256 amount of NFTs to transfer <code>_lockPaymentCondition</code> bytes32 lock payment condition identifier"},{"location":"contracts/conditions/NFTs/ITransferNFT/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled <pre><code>  event Fulfilled(\n  )\n</code></pre>"},{"location":"contracts/conditions/NFTs/NFT721HolderCondition/","title":"NFT721HolderCondition","text":"<p>Implementation of the Nft Holder Condition</p>"},{"location":"contracts/conditions/NFTs/NFT721HolderCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/NFTs/NFT721HolderCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/NFTs/NFT721HolderCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address"},{"location":"contracts/conditions/NFTs/NFT721HolderCondition/#hashvalues","title":"hashValues","text":"<pre><code>  function hashValues(\n  ) public returns (bytes32)\n</code></pre>"},{"location":"contracts/conditions/NFTs/NFT721HolderCondition/#fulfill","title":"fulfill","text":"<pre><code>  function fulfill(\n  ) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/","title":"NFTAccessCondition","text":"<p>Implementation of the Access Condition specific for NFTs</p> <pre><code> NFT Access Condition is special condition used to give access \n to a specific NFT related to a DID.\n</code></pre>"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress,\n    address _didRegistryAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address <code>_didRegistryAddress</code> address DID registry address"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _documentId,\n    address _grantee\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_documentId</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_grantee</code> address is the address of the granted user or the DID provider"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### hashValues <pre><code>  function hashValues(\n  ) public returns (bytes32)\n</code></pre>"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#fulfill","title":"fulfill","text":"<p><pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _documentId,\n    address _grantee\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill NFT Access condition</p> <p>only DID owner or DID provider can call this       method. Fulfill method sets the permissions        for the granted consumer's address to true then       fulfill the condition</p>"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 agreement identifier <code>_documentId</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_grantee</code> address is the address of the granted user or the DID provider"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state (Fulfilled/Aborted) ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _documentId,\n    address _grantee,\n    address _contractAddress\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill NFT Access condition <p>only DID owner or DID provider can call this       method. Fulfill method sets the permissions        for the granted consumer's address to true then       fulfill the condition</p>"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 agreement identifier <code>_documentId</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_grantee</code> address is the address of the granted user or the DID provider <code>_contractAddress</code> address is the contract address of the NFT implementation (ERC-1155 or ERC-721)"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#return-values_2","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state (Fulfilled/Aborted) ### grantPermission <pre><code>  function grantPermission(\n    address _grantee,\n    bytes32 _documentId\n  ) public\n</code></pre> grantPermission is called only by DID owner or provider"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_grantee</code> address is the address of the granted user or the DID provider <code>_documentId</code> bytes32 refers to the DID in which secret store will issue the decryption keys"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#checkpermissions","title":"checkPermissions","text":"<p><pre><code>  function checkPermissions(\n    address _documentId,\n    bytes32 _grantee\n  ) external returns (bool permissionGranted)\n</code></pre> checkPermissions is called to validate the permissions of user related to the NFT attached to an asset</p>"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#parameters_5","title":"Parameters:","text":"Name Type Description <code>_documentId</code> address refers to the DID <code>_grantee</code> bytes32 is the address of the granted user or the DID provider"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#return-values_3","title":"Return Values:","text":"Name Type Description <code>permissionGranted</code> address true if the access was granted"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/","title":"NFTHolderCondition","text":"<p>Implementation of the Nft Holder Condition</p>"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress,\n    address _didRegistryAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address <code>_didRegistryAddress</code> address DIDRegistry address"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _did,\n    address _holderAddress,\n    uint256 _amount\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 the Decentralized Identifier of the asset <code>_holderAddress</code> address the address of the NFT holder <code>_amount</code> uint256 is the amount NFTs that need to be hold by the holder"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### hashValues <pre><code>  function hashValues(\n  ) public returns (bytes32)\n</code></pre>"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#fulfill","title":"fulfill","text":"<p><pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _did,\n    address _holderAddress,\n    uint256 _amount\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill requires a validation that holder has enough       NFTs for a specific DID</p>"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 SEA agreement identifier <code>_did</code> bytes32 the Decentralized Identifier of the asset <code>_holderAddress</code> address the contract address where the reward is locked <code>_amount</code> uint256 is the amount of NFT to be hold"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state ### fulfill <pre><code>  function fulfill(\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"contracts/conditions/NFTs/NFTLockCondition/","title":"NFTLockCondition","text":"<p>Implementation of the NFT Lock Condition</p>"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/NFTs/NFTLockCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress,\n    address _didRegistryAddress\n  ) external\n</code></pre> initialize init the  contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address <code>_didRegistryAddress</code> address DIDRegistry contract address"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _did,\n    address _rewardAddress,\n    uint256 _amount\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 the DID of the asset with NFTs attached to lock <code>_rewardAddress</code> address the final address to receive the NFTs <code>_amount</code> uint256 is the amount of the locked tokens"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _did,\n    address _rewardAddress,\n    uint256 _amount\n  ) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill requires valid NFT transfer in order to lock the amount of DID NFTs based on the SEA"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 SEA agreement identifier <code>_did</code> bytes32 Asset Decentralized Identifier <code>_rewardAddress</code> address the contract address where the reward is locked <code>_amount</code> uint256 is the amount of tokens to be transferred"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state ### onERC1155Received <pre><code>  function onERC1155Received(\n  ) external returns (bytes4)\n</code></pre>"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#onerc1155batchreceived","title":"onERC1155BatchReceived","text":"<pre><code>  function onERC1155BatchReceived(\n  ) external returns (bytes4)\n</code></pre>"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#supportsinterface","title":"supportsInterface","text":"<pre><code>  function supportsInterface(\n  ) external returns (bool)\n</code></pre>"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#events","title":"Events","text":""},{"location":"contracts/conditions/NFTs/NFTLockCondition/#fulfilled","title":"Fulfilled","text":"<pre><code>  event Fulfilled(\n  )\n</code></pre>"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/","title":"TransferNFT721Condition","text":"<p>Implementation of condition allowing to transfer an NFT      between the original owner and a receiver</p>"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress,\n    address _didRegistryAddress\n  ) external\n</code></pre> initialize init the contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address <code>_didRegistryAddress</code> address DID Registry address"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _did,\n    address _nftReceiver,\n    address _nftAmount,\n    uint256 _lockCondition,\n    bytes32 _contract\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_nftReceiver</code> address is the address of the granted user or the DID provider <code>_nftAmount</code> address amount of NFTs to transfer <code>_lockCondition</code> uint256 lock condition identifier <code>_contract</code> bytes32 NFT contract to use"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _did,\n    address _nftReceiver,\n    uint256 _nftAmount,\n    bytes32 _lockPaymentCondition,\n    address _contract\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill the transfer NFT condition <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p>"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 agreement identifier <code>_did</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_nftReceiver</code> address is the address of the account to receive the NFT <code>_nftAmount</code> uint256 amount of NFTs to transfer <code>_lockPaymentCondition</code> bytes32 lock payment condition identifier <code>_contract</code> address NFT contract to use"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state (Fulfilled/Aborted)"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/","title":"TransferNFTCondition","text":"<p>Implementation of condition allowing to transfer an NFT      between the original owner and a receiver</p>"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress,\n    address _didRegistryAddress,\n    address _nftContractAddress\n  ) external\n</code></pre> initialize init the contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p>"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address <code>_didRegistryAddress</code> address DID Registry address <code>_nftContractAddress</code> address Market address"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#grantmarketrole","title":"grantMarketRole","text":"<pre><code>  function grantMarketRole(\n  ) public\n</code></pre>"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#revokemarketrole","title":"revokeMarketRole","text":"<pre><code>  function revokeMarketRole(\n  ) public\n</code></pre>"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _did,\n    address _nftReceiver,\n    address _nftAmount,\n    uint256 _lockCondition\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_nftReceiver</code> address is the address of the granted user or the DID provider <code>_nftAmount</code> address amount of NFTs to transfer <code>_lockCondition</code> uint256 lock condition identifier"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### hashValues <pre><code>  function hashValues(\n    bytes32 _did,\n    address _nftReceiver,\n    address _nftAmount,\n    uint256 _lockCondition,\n    bytes32 _nftContractAddress\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs with the following parameters"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_nftReceiver</code> address is the address of the granted user or the DID provider <code>_nftAmount</code> address amount of NFTs to transfer <code>_lockCondition</code> uint256 lock condition identifier <code>_nftContractAddress</code> bytes32 NFT contract to use"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### fulfill <pre><code>  function fulfill(\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#fulfill","title":"fulfill","text":"<p><pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _did,\n    address _nftReceiver,\n    uint256 _nftAmount,\n    bytes32 _lockPaymentCondition,\n    address _nftContractAddress\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p>"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 agreement identifier <code>_did</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_nftReceiver</code> address is the address of the account to receive the NFT <code>_nftAmount</code> uint256 amount of NFTs to transfer <code>_lockPaymentCondition</code> bytes32 lock payment condition identifier <code>_nftContractAddress</code> address NFT contract to use"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#return-values_2","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state (Fulfilled/Aborted) ### fulfillForMarket <pre><code>  function fulfillForMarket(\n    bytes32 _agreementId,\n    bytes32 _did,\n    address _nftReceiver,\n    address _nftAmount,\n    uint256 _lockPaymentCondition,\n    bytes32 _nftHolder\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill the transfer NFT condition <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address in the DIDRegistry contract.        When true then fulfill the condition</p>"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 agreement identifier <code>_did</code> bytes32 refers to the DID in which secret store will issue the decryption keys <code>_nftReceiver</code> address is the address of the account to receive the NFT <code>_nftAmount</code> address amount of NFTs to transfer <code>_lockPaymentCondition</code> uint256 lock payment condition identifier <code>_nftHolder</code> bytes32 is the address of the account to receive the NFT"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#return-values_3","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state (Fulfilled/Aborted)"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/","title":"EscrowPaymentCondition","text":"<p>Implementation of the Escrow Payment Condition</p> <pre><code> The Escrow payment is reward condition in which only \n can release reward if lock and release conditions\n are fulfilled.\n</code></pre>"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#functions","title":"Functions","text":""},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#receive","title":"receive","text":"<pre><code>  function receive(\n  ) external\n</code></pre>"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _conditionStoreManagerAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters</p>"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_conditionStoreManagerAddress</code> address condition store manager address"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#hashvalues","title":"hashValues","text":"<p><pre><code>  function hashValues(\n    bytes32 _did,\n    uint256[] _amounts,\n    address[] _receivers,\n    address _lockPaymentAddress,\n    address _tokenAddress,\n    bytes32 _lockCondition,\n    bytes32 _releaseCondition\n  ) public returns (bytes32)\n</code></pre> hashValues generates the hash of condition inputs         with the following parameters</p>"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 asset decentralized identifier <code>_amounts</code> uint256[] token amounts to be locked/released <code>_receivers</code> address[] receiver's addresses <code>_lockPaymentAddress</code> address lock payment contract address <code>_tokenAddress</code> address the ERC20 contract address to use during the payment <code>_lockCondition</code> bytes32 lock condition identifier <code>_releaseCondition</code> bytes32 release condition identifier"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#return-values","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### hashValuesLockPayment <pre><code>  function hashValuesLockPayment(\n    bytes32 _did,\n    address _rewardAddress,\n    address _tokenAddress,\n    uint256[] _amounts,\n    address[] _receivers\n  ) public returns (bytes32)\n</code></pre> hashValuesLockPayment generates the hash of condition inputs with the following parameters"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 the asset decentralized identifier <code>_rewardAddress</code> address the contract address where the reward is locked <code>_tokenAddress</code> address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment <code>_amounts</code> uint256[] token amounts to be locked/released <code>_receivers</code> address[] receiver's addresses"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#return-values_1","title":"Return Values:","text":"Name Type Description <code>bytes32</code> bytes32 hash of all these values ### fulfill <pre><code>  function fulfill(\n    bytes32 _agreementId,\n    bytes32 _did,\n    uint256[] _amounts,\n    address[] _receivers,\n    address _lockPaymentAddress,\n    address _tokenAddress,\n    bytes32 _lockCondition,\n    bytes32 _releaseCondition\n  ) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> fulfill escrow reward condition <p>fulfill method checks whether the lock and       release conditions are fulfilled in order to       release/refund the reward to receiver/sender       respectively.</p>"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_agreementId</code> bytes32 agreement identifier <code>_did</code> bytes32 asset decentralized identifier <code>_amounts</code> uint256[] token amounts to be locked/released <code>_receivers</code> address[] receiver's address <code>_lockPaymentAddress</code> address lock payment contract address <code>_tokenAddress</code> address the ERC20 contract address to use during the payment <code>_lockCondition</code> bytes32 lock condition identifier <code>_releaseCondition</code> bytes32 release condition identifier"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#return-values_2","title":"Return Values:","text":"Name Type Description <code>condition</code> bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled <pre><code>  event Fulfilled(\n  )\n</code></pre>"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#received","title":"Received","text":"<pre><code>  event Received(\n  )\n</code></pre>"},{"location":"contracts/conditions/rewards/Reward/","title":"Reward","text":"<p>Implementation of the Reward.</p> <pre><code> Generic reward condition\n</code></pre>"},{"location":"contracts/interfaces/IList/","title":"IList","text":""},{"location":"contracts/interfaces/IList/#functions","title":"Functions","text":""},{"location":"contracts/interfaces/IList/#has","title":"has","text":"<pre><code>  function has(\n  ) external returns (bool)\n</code></pre>"},{"location":"contracts/interfaces/IList/#has_1","title":"has","text":"<pre><code>  function has(\n  ) external returns (bool)\n</code></pre>"},{"location":"contracts/interfaces/ISecretStore/","title":"ISecretStore","text":""},{"location":"contracts/interfaces/ISecretStore/#functions","title":"Functions","text":""},{"location":"contracts/interfaces/ISecretStore/#checkpermissions","title":"checkPermissions","text":"<p><pre><code>  function checkPermissions(\n  ) external returns (bool permissionGranted)\n</code></pre> checkPermissions is called by Parity secret store</p>"},{"location":"contracts/interfaces/ISecretStorePermission/","title":"ISecretStorePermission","text":""},{"location":"contracts/interfaces/ISecretStorePermission/#functions","title":"Functions","text":""},{"location":"contracts/interfaces/ISecretStorePermission/#grantpermission","title":"grantPermission","text":"<p><pre><code>  function grantPermission(\n  ) external\n</code></pre> grantPermission is called only by documentKeyId Owner or provider</p>"},{"location":"contracts/interfaces/ISecretStorePermission/#renouncepermission","title":"renouncePermission","text":"<p><pre><code>  function renouncePermission(\n  ) external\n</code></pre> renouncePermission is called only by documentKeyId Owner or provider</p>"},{"location":"contracts/libraries/EpochLibrary/","title":"EpochLibrary","text":"<p>Implementation of Epoch Library.      For an arbitrary Epoch, this library manages the life      cycle of an Epoch. Usually this library is used for      handling the time window between conditions in an agreement.</p>"},{"location":"contracts/libraries/EpochLibrary/#functions","title":"Functions","text":""},{"location":"contracts/libraries/EpochLibrary/#create","title":"create","text":"<p><pre><code>  function create(\n    struct EpochLibrary.EpochList _self,\n    bytes32 _timeLock,\n    uint256 _timeOut\n  ) internal\n</code></pre> create creates new Epoch</p>"},{"location":"contracts/libraries/EpochLibrary/#parameters","title":"Parameters:","text":"Name Type Description <code>_self</code> struct EpochLibrary.EpochList is the Epoch storage pointer <code>_timeLock</code> bytes32 value in block count (can not fulfill before) <code>_timeOut</code> uint256 value in block count (can not fulfill after)"},{"location":"contracts/libraries/EpochLibrary/#istimedout","title":"isTimedOut","text":"<p><pre><code>  function isTimedOut(\n    struct EpochLibrary.EpochList _self\n  ) external returns (bool)\n</code></pre> isTimedOut means you cannot fulfill after</p>"},{"location":"contracts/libraries/EpochLibrary/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_self</code> struct EpochLibrary.EpochList is the Epoch storage pointer"},{"location":"contracts/libraries/EpochLibrary/#return-values","title":"Return Values:","text":"Name Type Description <code>true</code> struct EpochLibrary.EpochList if the current block number is gt timeOut ### isTimeLocked <pre><code>  function isTimeLocked(\n    struct EpochLibrary.EpochList _self\n  ) external returns (bool)\n</code></pre> isTimeLocked means you cannot fulfill before"},{"location":"contracts/libraries/EpochLibrary/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_self</code> struct EpochLibrary.EpochList is the Epoch storage pointer"},{"location":"contracts/libraries/EpochLibrary/#return-values_1","title":"Return Values:","text":"Name Type Description <code>true</code> struct EpochLibrary.EpochList if the current block number is gt timeLock ### getEpochTimeOut <pre><code>  function getEpochTimeOut(\n    struct EpochLibrary.Epoch _self\n  ) public returns (uint256)\n</code></pre> getEpochTimeOut"},{"location":"contracts/libraries/EpochLibrary/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_self</code> struct EpochLibrary.Epoch is the Epoch storage pointer"},{"location":"contracts/libraries/EpochLibrary/#getepochtimelock","title":"getEpochTimeLock","text":"<p><pre><code>  function getEpochTimeLock(\n    struct EpochLibrary.Epoch _self\n  ) public returns (uint256)\n</code></pre> getEpochTimeLock</p>"},{"location":"contracts/libraries/EpochLibrary/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_self</code> struct EpochLibrary.Epoch is the Epoch storage pointer"},{"location":"contracts/libraries/HashListLibrary/","title":"HashListLibrary","text":"<p>Implementation of the basic functionality of list of hash values. This library allows other contracts to build and maintain lists and also preserves the privacy of the data by accepting only hashed  content (bytes32 based data type)</p>"},{"location":"contracts/libraries/HashListLibrary/#functions","title":"Functions","text":""},{"location":"contracts/libraries/HashListLibrary/#add","title":"add","text":"<pre><code>  function add(\n    struct HashListLibrary.List _self,\n    bytes32 value\n  ) public returns (bool)\n</code></pre> <p>add index an element then add it to a list</p>"},{"location":"contracts/libraries/HashListLibrary/#parameters","title":"Parameters:","text":"Name Type Description <code>_self</code> struct HashListLibrary.List is a pointer to list in the storage <code>value</code> bytes32 is a bytes32 value"},{"location":"contracts/libraries/HashListLibrary/#return-values","title":"Return Values:","text":"Name Type Description <code>true</code> struct HashListLibrary.List if value is added successfully ### add <pre><code>  function add(\n    struct HashListLibrary.List _self,\n    bytes32[] values\n  ) public returns (bool)\n</code></pre> <p>put an array of elements without indexing      this meant to save gas in case of large arrays</p>"},{"location":"contracts/libraries/HashListLibrary/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_self</code> struct HashListLibrary.List is a pointer to list in the storage <code>values</code> bytes32[] is an array of elements value"},{"location":"contracts/libraries/HashListLibrary/#return-values_1","title":"Return Values:","text":"Name Type Description <code>true</code> struct HashListLibrary.List if values are added successfully ### update <pre><code>  function update(\n    struct HashListLibrary.List _self,\n    bytes32 oldValue,\n    bytes32 newValue\n  ) public returns (bool)\n</code></pre> <p>update the value with a new value and maintain indices</p>"},{"location":"contracts/libraries/HashListLibrary/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_self</code> struct HashListLibrary.List is a pointer to list in the storage <code>oldValue</code> bytes32 is an element value in a list <code>newValue</code> bytes32 new value"},{"location":"contracts/libraries/HashListLibrary/#return-values_2","title":"Return Values:","text":"Name Type Description <code>true</code> struct HashListLibrary.List if value is updated successfully ### remove <pre><code>  function remove(\n    struct HashListLibrary.List _self,\n    bytes32 value\n  ) public returns (bool)\n</code></pre> <p>remove value from a list, updates indices, and list size </p>"},{"location":"contracts/libraries/HashListLibrary/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_self</code> struct HashListLibrary.List is a pointer to list in the storage <code>value</code> bytes32 is an element value in a list"},{"location":"contracts/libraries/HashListLibrary/#return-values_3","title":"Return Values:","text":"Name Type Description <code>true</code> struct HashListLibrary.List if value is removed successfully ### get <pre><code>  function get(\n    struct HashListLibrary.List _self,\n    uint256 index\n  ) public returns (bytes32)\n</code></pre> <p>has value by index </p>"},{"location":"contracts/libraries/HashListLibrary/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_self</code> struct HashListLibrary.List is a pointer to list in the storage <code>index</code> uint256 is where is value is stored in the list"},{"location":"contracts/libraries/HashListLibrary/#return-values_4","title":"Return Values:","text":"Name Type Description <code>the</code> struct HashListLibrary.List value if exists ### index <pre><code>  function index(\n    struct HashListLibrary.List _self,\n    uint256 from,\n    uint256 to\n  ) public returns (bool)\n</code></pre> <p>index is used to map each element value to its index on the list </p>"},{"location":"contracts/libraries/HashListLibrary/#parameters_5","title":"Parameters:","text":"Name Type Description <code>_self</code> struct HashListLibrary.List is a pointer to list in the storage <code>from</code> uint256 index is where to 'from' indexing in the list <code>to</code> uint256 index is where to stop indexing"},{"location":"contracts/libraries/HashListLibrary/#return-values_5","title":"Return Values:","text":"Name Type Description <code>true</code> struct HashListLibrary.List if the sub list is indexed ### setOwner <pre><code>  function setOwner(\n  ) public\n</code></pre> <p>setOwner set list owner param _owner owner address</p>"},{"location":"contracts/libraries/HashListLibrary/#indexof","title":"indexOf","text":"<pre><code>  function indexOf(\n    struct HashListLibrary.List _self,\n    bytes32 value\n  ) public returns (uint256)\n</code></pre> <p>indexOf gets the index of a value in a list</p>"},{"location":"contracts/libraries/HashListLibrary/#parameters_6","title":"Parameters:","text":"Name Type Description <code>_self</code> struct HashListLibrary.List is a pointer to list in the storage <code>value</code> bytes32 is element value in list"},{"location":"contracts/libraries/HashListLibrary/#return-values_6","title":"Return Values:","text":"Name Type Description <code>value</code> struct HashListLibrary.List index in list ### isIndexed <pre><code>  function isIndexed(\n    struct HashListLibrary.List _self\n  ) public returns (bool)\n</code></pre> <p>isIndexed checks if the list is indexed</p>"},{"location":"contracts/libraries/HashListLibrary/#parameters_7","title":"Parameters:","text":"Name Type Description <code>_self</code> struct HashListLibrary.List is a pointer to list in the storage"},{"location":"contracts/libraries/HashListLibrary/#return-values_7","title":"Return Values:","text":"Name Type Description <code>true</code> struct HashListLibrary.List if the list is indexed ### all <pre><code>  function all(\n    struct HashListLibrary.List _self\n  ) public returns (bytes32[])\n</code></pre> <p>all returns all list elements</p>"},{"location":"contracts/libraries/HashListLibrary/#parameters_8","title":"Parameters:","text":"Name Type Description <code>_self</code> struct HashListLibrary.List is a pointer to list in the storage"},{"location":"contracts/libraries/HashListLibrary/#return-values_8","title":"Return Values:","text":"Name Type Description <code>all</code> struct HashListLibrary.List list elements ### has <pre><code>  function has(\n    struct HashListLibrary.List _self,\n    bytes32 value\n  ) public returns (bool)\n</code></pre> <p>size returns the list size</p>"},{"location":"contracts/libraries/HashListLibrary/#parameters_9","title":"Parameters:","text":"Name Type Description <code>_self</code> struct HashListLibrary.List is a pointer to list in the storage <code>value</code> bytes32 is element value in list"},{"location":"contracts/libraries/HashListLibrary/#return-values_9","title":"Return Values:","text":"Name Type Description <code>true</code> struct HashListLibrary.List if the value exists ### size <pre><code>  function size(\n    struct HashListLibrary.List _self\n  ) public returns (uint256)\n</code></pre> <p>size gets the list size</p>"},{"location":"contracts/libraries/HashListLibrary/#parameters_10","title":"Parameters:","text":"Name Type Description <code>_self</code> struct HashListLibrary.List is a pointer to list in the storage"},{"location":"contracts/libraries/HashListLibrary/#return-values_10","title":"Return Values:","text":"Name Type Description <code>total</code> struct HashListLibrary.List length of the list ### ownedBy <pre><code>  function ownedBy(\n    struct HashListLibrary.List _self\n  ) public returns (address)\n</code></pre> <p>ownedBy gets the list owner</p>"},{"location":"contracts/libraries/HashListLibrary/#parameters_11","title":"Parameters:","text":"Name Type Description <code>_self</code> struct HashListLibrary.List is a pointer to list in the storage"},{"location":"contracts/libraries/HashListLibrary/#return-values_11","title":"Return Values:","text":"Name Type Description <code>list</code> struct HashListLibrary.List owner"},{"location":"contracts/registry/DIDFactory/","title":"DIDFactory","text":"<p>Implementation of the DID Registry.</p>"},{"location":"contracts/registry/DIDFactory/#functions","title":"Functions","text":""},{"location":"contracts/registry/DIDFactory/#initialize","title":"initialize","text":"<pre><code>  function initialize(\n    address _owner\n  ) public\n</code></pre> <p>DIDRegistry Initializer      Initialize Ownable. Only on contract creation.</p>"},{"location":"contracts/registry/DIDFactory/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address refers to the owner of the contract."},{"location":"contracts/registry/DIDFactory/#setmanager","title":"setManager","text":"<p><pre><code>  function setManager(\n  ) external\n</code></pre> Sets the manager role. Should be the TransferCondition contract address</p>"},{"location":"contracts/registry/DIDFactory/#registerattribute","title":"registerAttribute","text":"<p><pre><code>  function registerAttribute(\n    bytes32 _didSeed,\n    bytes32 _checksum,\n    address[] _url\n  ) public returns (uint256 size)\n</code></pre> Register DID attributes.</p> <p>The first attribute of a DID registered sets the DID owner.      Subsequent updates record _checksum and update info.</p>"},{"location":"contracts/registry/DIDFactory/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_didSeed</code> bytes32 refers to decentralized identifier seed (a bytes32 length ID). <code>_checksum</code> bytes32 includes a one-way HASH calculated using the DDO content. <code>_url</code> address[] refers to the attribute value, limited to 2048 bytes."},{"location":"contracts/registry/DIDFactory/#return-values","title":"Return Values:","text":"Name Type Description <code>size</code> bytes32 refers to the size of the registry after the register action. ### registerDID <pre><code>  function registerDID(\n    bytes32 _didSeed,\n    bytes32 _checksum,\n    address[] _providers,\n    string _url,\n    bytes32 _providers,\n    string _activityId,\n     _attributes\n  ) public returns (uint256 size)\n</code></pre> Register DID attributes. <p>The first attribute of a DID registered sets the DID owner.      Subsequent updates record _checksum and update info.</p>"},{"location":"contracts/registry/DIDFactory/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_didSeed</code> bytes32 refers to decentralized identifier seed (a bytes32 length ID). The final DID will be calculated with the creator address using the <code>hashDID</code> function <code>_checksum</code> bytes32 includes a one-way HASH calculated using the DDO content. <code>_providers</code> address[] list of addresses that can act as an asset provider <code>_url</code> string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. <code>_providers</code> bytes32 list of DID providers addresses <code>_activityId</code> string refers to activity <code>_attributes</code> refers to the provenance attributes"},{"location":"contracts/registry/DIDFactory/#return-values_1","title":"Return Values:","text":"Name Type Description <code>size</code> bytes32 refers to the size of the registry after the register action. ### hashDID <pre><code>  function hashDID(\n    bytes32 _didSeed,\n    address _creator\n  ) public returns (bytes32)\n</code></pre> It generates a DID using as seed a bytes32 and the address of the DID creator"},{"location":"contracts/registry/DIDFactory/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_didSeed</code> bytes32 refers to DID Seed used as base to generate the final DID <code>_creator</code> address address of the creator of the DID"},{"location":"contracts/registry/DIDFactory/#return-values_2","title":"Return Values:","text":"Name Type Description <code>the</code> bytes32 new DID created ### areRoyaltiesValid <pre><code>  function areRoyaltiesValid(\n    bytes32 _did,\n    uint256[] _amounts,\n    address[] _receivers\n  ) public returns (bool)\n</code></pre> areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly"},{"location":"contracts/registry/DIDFactory/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>_amounts</code> uint256[] refers to the amounts to reward <code>_receivers</code> address[] refers to the receivers of rewards"},{"location":"contracts/registry/DIDFactory/#return-values_3","title":"Return Values:","text":"Name Type Description <code>true</code> bytes32 if the rewards distribution respect the original creator royalties ### wasGeneratedBy <pre><code>  function wasGeneratedBy(\n  ) internal returns (bool)\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#used","title":"used","text":"<pre><code>  function used(\n  ) public returns (bool success)\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#wasderivedfrom","title":"wasDerivedFrom","text":"<pre><code>  function wasDerivedFrom(\n  ) public returns (bool success)\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#wasassociatedwith","title":"wasAssociatedWith","text":"<pre><code>  function wasAssociatedWith(\n  ) public returns (bool success)\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#actedonbehalf","title":"actedOnBehalf","text":"<p><pre><code>  function actedOnBehalf(\n    bytes32 _provId,\n    bytes32 _did,\n    address _delegateAgentId,\n    address _responsibleAgentId,\n    bytes32 _activityId,\n    bytes _signatureDelegate,\n    string _attributes\n  ) public returns (bool success)\n</code></pre> Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId &amp; _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId) </p>"},{"location":"contracts/registry/DIDFactory/#parameters_5","title":"Parameters:","text":"Name Type Description <code>_provId</code> bytes32 unique identifier referring to the provenance entry <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity <code>_delegateAgentId</code> address refers to address acting on behalf of the provenance record <code>_responsibleAgentId</code> address refers to address responsible of the provenance record <code>_activityId</code> bytes32 refers to activity <code>_signatureDelegate</code> bytes refers to the digital signature provided by the did delegate. <code>_attributes</code> string refers to the provenance attributes"},{"location":"contracts/registry/DIDFactory/#return-values_4","title":"Return Values:","text":"Name Type Description <code>success</code> bytes32 true if the action was properly registered ### addDIDProvider <pre><code>  function addDIDProvider(\n    bytes32 _did,\n    address _provider\n  ) external\n</code></pre> addDIDProvider add new DID provider. <p>it adds new DID provider to the providers list. A provider      is any entity that can serve the registered asset</p>"},{"location":"contracts/registry/DIDFactory/#parameters_6","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID). <code>_provider</code> address provider's address."},{"location":"contracts/registry/DIDFactory/#removedidprovider","title":"removeDIDProvider","text":"<p><pre><code>  function removeDIDProvider(\n    bytes32 _did,\n    address _provider\n  ) external\n</code></pre> removeDIDProvider delete an existing DID provider.</p>"},{"location":"contracts/registry/DIDFactory/#parameters_7","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID). <code>_provider</code> address provider's address."},{"location":"contracts/registry/DIDFactory/#adddidprovenancedelegate","title":"addDIDProvenanceDelegate","text":"<p><pre><code>  function addDIDProvenanceDelegate(\n    bytes32 _did,\n    address _delegate\n  ) public\n</code></pre> addDIDProvenanceDelegate add new DID provenance delegate.</p> <p>it adds new DID provenance delegate to the delegates list.  A delegate is any entity that interact with the provenance entries of one DID</p>"},{"location":"contracts/registry/DIDFactory/#parameters_8","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID). <code>_delegate</code> address delegates's address."},{"location":"contracts/registry/DIDFactory/#removedidprovenancedelegate","title":"removeDIDProvenanceDelegate","text":"<p><pre><code>  function removeDIDProvenanceDelegate(\n    bytes32 _did,\n    address _delegate\n  ) external\n</code></pre> removeDIDProvenanceDelegate delete an existing DID delegate.</p>"},{"location":"contracts/registry/DIDFactory/#parameters_9","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID). <code>_delegate</code> address delegate's address."},{"location":"contracts/registry/DIDFactory/#transferdidownership","title":"transferDIDOwnership","text":"<p><pre><code>  function transferDIDOwnership(\n    bytes32 _did,\n    address _newOwner\n  ) external\n</code></pre> transferDIDOwnership transfer DID ownership</p>"},{"location":"contracts/registry/DIDFactory/#parameters_10","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID) <code>_newOwner</code> address new owner address"},{"location":"contracts/registry/DIDFactory/#transferdidownershipmanaged","title":"transferDIDOwnershipManaged","text":"<p><pre><code>  function transferDIDOwnershipManaged(\n    address _did,\n    bytes32 _newOwner\n  ) external\n</code></pre> transferDIDOwnershipManaged transfer DID ownership</p>"},{"location":"contracts/registry/DIDFactory/#parameters_11","title":"Parameters:","text":"Name Type Description <code>_did</code> address refers to decentralized identifier (a bytes32 length ID) <code>_newOwner</code> bytes32 new owner address"},{"location":"contracts/registry/DIDFactory/#_transferdidownership","title":"_transferDIDOwnership","text":"<pre><code>  function _transferDIDOwnership(\n  ) internal\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#grantpermission","title":"grantPermission","text":"<pre><code>  function grantPermission(\n    bytes32 _did,\n    address _grantee\n  ) external\n</code></pre> <p>grantPermission grants access permission to grantee </p>"},{"location":"contracts/registry/DIDFactory/#parameters_12","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID) <code>_grantee</code> address address"},{"location":"contracts/registry/DIDFactory/#revokepermission","title":"revokePermission","text":"<pre><code>  function revokePermission(\n    bytes32 _did,\n    address _grantee\n  ) external\n</code></pre> <p>revokePermission revokes access permission from grantee </p>"},{"location":"contracts/registry/DIDFactory/#parameters_13","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID) <code>_grantee</code> address address"},{"location":"contracts/registry/DIDFactory/#getpermission","title":"getPermission","text":"<pre><code>  function getPermission(\n    bytes32 _did,\n    address _grantee\n  ) external returns (bool)\n</code></pre> <p>getPermission gets access permission of a grantee</p>"},{"location":"contracts/registry/DIDFactory/#parameters_14","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID) <code>_grantee</code> address address"},{"location":"contracts/registry/DIDFactory/#return-values_5","title":"Return Values:","text":"Name Type Description <code>true</code> bytes32 if grantee has access permission to a DID ### isDIDProvider <pre><code>  function isDIDProvider(\n    bytes32 _did,\n    address _provider\n  ) public returns (bool)\n</code></pre> isDIDProvider check whether a given DID provider exists"},{"location":"contracts/registry/DIDFactory/#parameters_15","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID). <code>_provider</code> address provider's address."},{"location":"contracts/registry/DIDFactory/#getdidregister","title":"getDIDRegister","text":"<pre><code>  function getDIDRegister(\n    bytes32 _did\n  ) public returns (address owner, bytes32 lastChecksum, string url, address lastUpdatedBy, uint256 blockNumberUpdated, address[] providers, uint256 nftSupply, uint256 mintCap, uint256 royalties)\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#parameters_16","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID)."},{"location":"contracts/registry/DIDFactory/#return-values_6","title":"Return Values:","text":"Name Type Description <code>owner</code> bytes32 the did owner <code>lastChecksum</code> <code>url</code> <code>lastUpdatedBy</code> <code>blockNumberUpdated</code>"},{"location":"contracts/registry/DIDFactory/#getblocknumberupdated","title":"getBlockNumberUpdated","text":"<pre><code>  function getBlockNumberUpdated(\n    bytes32 _did\n  ) public returns (uint256 blockNumberUpdated)\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#parameters_17","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID)."},{"location":"contracts/registry/DIDFactory/#return-values_7","title":"Return Values:","text":"Name Type Description <code>blockNumberUpdated</code> bytes32 last modified (update) block number of a DID. ### getDIDOwner <pre><code>  function getDIDOwner(\n    bytes32 _did\n  ) public returns (address didOwner)\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#parameters_18","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID)."},{"location":"contracts/registry/DIDFactory/#return-values_8","title":"Return Values:","text":"Name Type Description <code>didOwner</code> bytes32 the address of the DID owner. ### getDIDRegistrySize <pre><code>  function getDIDRegistrySize(\n  ) public returns (uint256 size)\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#return-values_9","title":"Return Values:","text":"Name Type Description <code>size</code> the length of the DID registry. ### getDIDRegisterIds <pre><code>  function getDIDRegisterIds(\n  ) public returns (bytes32[])\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#return-values_10","title":"Return Values:","text":"Name Type Description <code>the</code> list of items in the DID registry. ### _grantPermission <pre><code>  function _grantPermission(\n    bytes32 _did,\n    address _grantee\n  ) internal\n</code></pre> <p>_grantPermission grants access permission to grantee </p>"},{"location":"contracts/registry/DIDFactory/#parameters_19","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID) <code>_grantee</code> address address"},{"location":"contracts/registry/DIDFactory/#_revokepermission","title":"_revokePermission","text":"<pre><code>  function _revokePermission(\n    bytes32 _did,\n    address _grantee\n  ) internal\n</code></pre> <p>_revokePermission revokes access permission from grantee </p>"},{"location":"contracts/registry/DIDFactory/#parameters_20","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID) <code>_grantee</code> address address"},{"location":"contracts/registry/DIDFactory/#_getpermission","title":"_getPermission","text":"<pre><code>  function _getPermission(\n    bytes32 _did,\n    address _grantee\n  ) internal returns (bool)\n</code></pre> <p>_getPermission gets access permission of a grantee</p>"},{"location":"contracts/registry/DIDFactory/#parameters_21","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID) <code>_grantee</code> address address"},{"location":"contracts/registry/DIDFactory/#return-values_11","title":"Return Values:","text":"Name Type Description <code>true</code> bytes32 if grantee has access permission to a DID ### getProvenanceEntry <pre><code>  function getProvenanceEntry(\n    bytes32 _provId\n  ) public returns (bytes32 did, bytes32 relatedDid, address agentId, bytes32 activityId, address agentInvolvedId, uint8 method, address createdBy, uint256 blockNumberUpdated, bytes signature)\n</code></pre> Fetch the complete provenance entry attributes"},{"location":"contracts/registry/DIDFactory/#parameters_22","title":"Parameters:","text":"Name Type Description <code>_provId</code> bytes32 refers to the provenance identifier"},{"location":"contracts/registry/DIDFactory/#return-values_12","title":"Return Values:","text":"Name Type Description <code>did</code> bytes32 <code>relatedDid</code> <code>activityId</code> <code>agentInvolvedId</code> <code>createdBy</code> <code>blockNumberUpdated</code> <code>signature</code>"},{"location":"contracts/registry/DIDFactory/#isdidowner","title":"isDIDOwner","text":"<p><pre><code>  function isDIDOwner(\n    address _address,\n    bytes32 _did\n  ) public returns (bool)\n</code></pre> isDIDOwner check whether a given address is owner for a DID</p>"},{"location":"contracts/registry/DIDFactory/#parameters_23","title":"Parameters:","text":"Name Type Description <code>_address</code> address user address. <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID)."},{"location":"contracts/registry/DIDFactory/#isownerproviderordelegate","title":"isOwnerProviderOrDelegate","text":"<p><pre><code>  function isOwnerProviderOrDelegate(\n    bytes32 _did\n  ) public returns (bool)\n</code></pre> isOwnerProviderOrDelegate check whether msg.sender is owner, provider or delegate for a DID given</p>"},{"location":"contracts/registry/DIDFactory/#parameters_24","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID)."},{"location":"contracts/registry/DIDFactory/#return-values_13","title":"Return Values:","text":"Name Type Description <code>boolean</code> bytes32 true if yes ### isProvenanceDelegate <pre><code>  function isProvenanceDelegate(\n    bytes32 _did,\n    address _delegate\n  ) public returns (bool)\n</code></pre> isProvenanceDelegate check whether a given DID delegate exists"},{"location":"contracts/registry/DIDFactory/#parameters_25","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID). <code>_delegate</code> address delegate's address."},{"location":"contracts/registry/DIDFactory/#return-values_14","title":"Return Values:","text":"Name Type Description <code>boolean</code> bytes32 true if yes ### getProvenanceOwner <pre><code>  function getProvenanceOwner(\n    bytes32 _did\n  ) public returns (address provenanceOwner)\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#parameters_26","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID)."},{"location":"contracts/registry/DIDFactory/#return-values_15","title":"Return Values:","text":"Name Type Description <code>provenanceOwner</code> bytes32 the address of the Provenance owner. ## Events ### DIDAttributeRegistered <pre><code>  event DIDAttributeRegistered(\n  )\n</code></pre> DID Events"},{"location":"contracts/registry/DIDFactory/#didproviderremoved","title":"DIDProviderRemoved","text":"<pre><code>  event DIDProviderRemoved(\n  )\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#didprovideradded","title":"DIDProviderAdded","text":"<pre><code>  event DIDProviderAdded(\n  )\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#didownershiptransferred","title":"DIDOwnershipTransferred","text":"<pre><code>  event DIDOwnershipTransferred(\n  )\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#didpermissiongranted","title":"DIDPermissionGranted","text":"<pre><code>  event DIDPermissionGranted(\n  )\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#didpermissionrevoked","title":"DIDPermissionRevoked","text":"<pre><code>  event DIDPermissionRevoked(\n  )\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#didprovenancedelegateremoved","title":"DIDProvenanceDelegateRemoved","text":"<pre><code>  event DIDProvenanceDelegateRemoved(\n  )\n</code></pre>"},{"location":"contracts/registry/DIDFactory/#didprovenancedelegateadded","title":"DIDProvenanceDelegateAdded","text":"<pre><code>  event DIDProvenanceDelegateAdded(\n  )\n</code></pre>"},{"location":"contracts/registry/DIDRegistry/","title":"DIDRegistry","text":"<p>Implementation of a Mintable DID Registry.</p>"},{"location":"contracts/registry/DIDRegistry/#functions","title":"Functions","text":""},{"location":"contracts/registry/DIDRegistry/#initialize","title":"initialize","text":"<pre><code>  function initialize(\n    address _owner\n  ) public\n</code></pre> <p>DIDRegistry Initializer      Initialize Ownable. Only on contract creation.</p>"},{"location":"contracts/registry/DIDRegistry/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address refers to the owner of the contract."},{"location":"contracts/registry/DIDRegistry/#registermintabledid","title":"registerMintableDID","text":"<p><pre><code>  function registerMintableDID(\n    bytes32 _didSeed,\n    bytes32 _checksum,\n    address[] _providers,\n    string _url,\n    uint256 _cap,\n    uint8 _royalties,\n    bytes32 _activityId,\n    string _attributes\n  ) public returns (uint256 size)\n</code></pre> Register a Mintable DID.</p> <p>The first attribute of a DID registered sets the DID owner.      Subsequent updates record _checksum and update info.</p>"},{"location":"contracts/registry/DIDRegistry/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_didSeed</code> bytes32 refers to decentralized identifier seed (a bytes32 length ID). <code>_checksum</code> bytes32 includes a one-way HASH calculated using the DDO content. <code>_providers</code> address[] list of addresses that can act as an asset provider <code>_url</code> string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. <code>_cap</code> uint256 refers to the mint cap <code>_royalties</code> uint8 refers to the royalties to reward to the DID creator in the secondary market <code>_activityId</code> bytes32 refers to activity <code>_attributes</code> string refers to the provenance attributes"},{"location":"contracts/registry/DIDRegistry/#return-values","title":"Return Values:","text":"Name Type Description <code>size</code> bytes32 refers to the size of the registry after the register action. ### enableAndMintDidNft <pre><code>  function enableAndMintDidNft(\n    bytes32 _did,\n    uint256 _cap,\n    uint8 _royalties,\n    bool _preMint\n  ) public returns (bool success)\n</code></pre> enableDidNft creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. <p>update the DID registry providers list by adding the mintCap and royalties configuration</p>"},{"location":"contracts/registry/DIDRegistry/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>_cap</code> uint256 refers to the mint cap <code>_royalties</code> uint8 refers to the royalties to reward to the DID creator in the secondary market <code>_preMint</code> bool if is true mint directly the amount capped tokens and lock in the _lockAddress"},{"location":"contracts/registry/DIDRegistry/#mint","title":"mint","text":"<p><pre><code>  function mint(\n    bytes32 _did,\n    uint256 _amount\n  ) public\n</code></pre> Mints a NFT associated to the DID</p> <p>Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both      Only the DID owner can mint NFTs associated to the DID</p>"},{"location":"contracts/registry/DIDRegistry/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID). <code>_amount</code> uint256 amount to mint"},{"location":"contracts/registry/DIDRegistry/#burn","title":"burn","text":"<p><pre><code>  function burn(\n    bytes32 _did,\n    uint256 _amount\n  ) public\n</code></pre> Burns NFTs associated to the DID</p> <p>Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both      Only the DID owner can burn NFTs associated to the DID</p>"},{"location":"contracts/registry/DIDRegistry/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID). <code>_amount</code> uint256 amount to burn"},{"location":"contracts/registry/DIDRegistryLibrary/","title":"DIDRegistryLibrary","text":"<p>All function calls are currently implemented without side effects</p>"},{"location":"contracts/registry/DIDRegistryLibrary/#functions","title":"Functions","text":""},{"location":"contracts/registry/DIDRegistryLibrary/#update","title":"update","text":"<p><pre><code>  function update(\n    struct DIDRegistryLibrary.DIDRegisterList _self,\n    bytes32 _did,\n    bytes32 _checksum,\n    string _url\n  ) external returns (uint256 size)\n</code></pre> update the DID store</p> <p>access modifiers and storage pointer should be implemented in DIDRegistry</p>"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters","title":"Parameters:","text":"Name Type Description <code>_self</code> struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer <code>_did</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>_checksum</code> bytes32 includes a one-way HASH calculated using the DDO content <code>_url</code> string includes the url resolving to the DID Document (DDO)"},{"location":"contracts/registry/DIDRegistryLibrary/#initializenftconfig","title":"initializeNftConfig","text":"<p><pre><code>  function initializeNftConfig(\n    struct DIDRegistryLibrary.DIDRegisterList _self,\n    bytes32 _did,\n    uint256 _cap,\n    uint8 _royalties\n  ) internal\n</code></pre> initializeNftConfig creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the  valuation of NFTs of a DID already created. </p> <p>update the DID registry providers list by adding the mintCap and royalties configuration</p>"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_self</code> struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer <code>_did</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>_cap</code> uint256 refers to the mint cap <code>_royalties</code> uint8 refers to the royalties to reward to the DID creator in the secondary market The royalties in secondary market for the creator should be between 0% &gt;= x &lt; 100%"},{"location":"contracts/registry/DIDRegistryLibrary/#areroyaltiesvalid","title":"areRoyaltiesValid","text":"<p><pre><code>  function areRoyaltiesValid(\n    struct DIDRegistryLibrary.DIDRegisterList _self,\n    bytes32 _did,\n    uint256[] _amounts,\n    address[] _receivers\n  ) internal returns (bool)\n</code></pre> areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly</p>"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_self</code> struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer <code>_did</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>_amounts</code> uint256[] refers to the amounts to reward <code>_receivers</code> address[] refers to the receivers of rewards"},{"location":"contracts/registry/DIDRegistryLibrary/#return-values","title":"Return Values:","text":"Name Type Description <code>true</code> struct DIDRegistryLibrary.DIDRegisterList if the rewards distribution respect the original creator royalties ### addProvider <pre><code>  function addProvider(\n    struct DIDRegistryLibrary.DIDRegisterList _self,\n    bytes32 _did,\n    address provider\n  ) internal\n</code></pre> addProvider add provider to DID registry <p>update the DID registry providers list by adding a new provider</p>"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_self</code> struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer <code>_did</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>provider</code> address the provider's address"},{"location":"contracts/registry/DIDRegistryLibrary/#removeprovider","title":"removeProvider","text":"<p><pre><code>  function removeProvider(\n    struct DIDRegistryLibrary.DIDRegisterList _self,\n    bytes32 _did,\n    address _provider\n  ) internal returns (bool)\n</code></pre> removeProvider remove provider from DID registry</p> <p>update the DID registry providers list by removing an existing provider</p>"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_self</code> struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer <code>_did</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>_provider</code> address the provider's address"},{"location":"contracts/registry/DIDRegistryLibrary/#updatedidowner","title":"updateDIDOwner","text":"<p><pre><code>  function updateDIDOwner(\n    struct DIDRegistryLibrary.DIDRegisterList _self,\n    bytes32 _did,\n    address _newOwner\n  ) internal\n</code></pre> updateDIDOwner transfer DID ownership to a new owner</p>"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_5","title":"Parameters:","text":"Name Type Description <code>_self</code> struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer <code>_did</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>_newOwner</code> address the new DID owner address"},{"location":"contracts/registry/DIDRegistryLibrary/#isprovider","title":"isProvider","text":"<p><pre><code>  function isProvider(\n    struct DIDRegistryLibrary.DIDRegisterList _self,\n    bytes32 _did,\n    address _provider\n  ) public returns (bool)\n</code></pre> isProvider check whether DID provider exists</p>"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_6","title":"Parameters:","text":"Name Type Description <code>_self</code> struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer <code>_did</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>_provider</code> address the provider's address"},{"location":"contracts/registry/DIDRegistryLibrary/#return-values_1","title":"Return Values:","text":"Name Type Description <code>true</code> struct DIDRegistryLibrary.DIDRegisterList if the provider already exists ### addDelegate <pre><code>  function addDelegate(\n    struct DIDRegistryLibrary.DIDRegisterList _self,\n    bytes32 _did,\n    address delegate\n  ) internal\n</code></pre> addDelegate add delegate to DID registry <p>update the DID registry delegates list by adding a new delegate</p>"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_7","title":"Parameters:","text":"Name Type Description <code>_self</code> struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer <code>_did</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>delegate</code> address the delegate's address"},{"location":"contracts/registry/DIDRegistryLibrary/#removedelegate","title":"removeDelegate","text":"<p><pre><code>  function removeDelegate(\n    struct DIDRegistryLibrary.DIDRegisterList _self,\n    bytes32 _did,\n    address _delegate\n  ) internal returns (bool)\n</code></pre> removeDelegate remove delegate from DID registry</p> <p>update the DID registry delegates list by removing an existing delegate</p>"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_8","title":"Parameters:","text":"Name Type Description <code>_self</code> struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer <code>_did</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>_delegate</code> address the delegate's address"},{"location":"contracts/registry/DIDRegistryLibrary/#isdelegate","title":"isDelegate","text":"<p><pre><code>  function isDelegate(\n    struct DIDRegistryLibrary.DIDRegisterList _self,\n    bytes32 _did,\n    address _delegate\n  ) public returns (bool)\n</code></pre> isDelegate check whether DID delegate exists</p>"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_9","title":"Parameters:","text":"Name Type Description <code>_self</code> struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer <code>_did</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>_delegate</code> address the delegate's address"},{"location":"contracts/registry/DIDRegistryLibrary/#return-values_2","title":"Return Values:","text":"Name Type Description <code>true</code> struct DIDRegistryLibrary.DIDRegisterList if the delegate already exists"},{"location":"contracts/registry/ProvenanceRegistry/","title":"ProvenanceRegistry","text":"<p>All function calls are currently implemented without side effects</p>"},{"location":"contracts/registry/ProvenanceRegistry/#functions","title":"Functions","text":""},{"location":"contracts/registry/ProvenanceRegistry/#__provenanceregistry_init","title":"__ProvenanceRegistry_init","text":"<pre><code>  function __ProvenanceRegistry_init(\n  ) internal\n</code></pre>"},{"location":"contracts/registry/ProvenanceRegistry/#__provenanceregistry_init_unchained","title":"__ProvenanceRegistry_init_unchained","text":"<pre><code>  function __ProvenanceRegistry_init_unchained(\n  ) internal\n</code></pre>"},{"location":"contracts/registry/ProvenanceRegistry/#createprovenanceentry","title":"createProvenanceEntry","text":"<p><pre><code>  function createProvenanceEntry(\n    bytes32 _provId,\n    bytes32 _did,\n    bytes32 _relatedDid,\n    address _agentId,\n    bytes32 _activityId,\n    address _agentInvolvedId,\n    enum ProvenanceRegistry.ProvenanceMethod _method,\n    address _createdBy,\n    bytes _signatureDelegate\n  ) internal returns (bool)\n</code></pre> create an event in the Provenance store</p> <p>access modifiers and storage pointer should be implemented in ProvenanceRegistry</p>"},{"location":"contracts/registry/ProvenanceRegistry/#parameters","title":"Parameters:","text":"Name Type Description <code>_provId</code> bytes32 refers to provenance event identifier <code>_did</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>_relatedDid</code> bytes32 refers to decentralized identifier (a byte32 length ID) of a related entity <code>_agentId</code> address refers to address of the agent creating the provenance record <code>_activityId</code> bytes32 refers to activity <code>_agentInvolvedId</code> address refers to address of the agent involved with the provenance record <code>_method</code> enum ProvenanceRegistry.ProvenanceMethod refers to the W3C Provenance method <code>_createdBy</code> address refers to address of the agent triggering the activity <code>_signatureDelegate</code> bytes refers to the digital signature provided by the did delegate."},{"location":"contracts/registry/ProvenanceRegistry/#_wasgeneratedby","title":"_wasGeneratedBy","text":"<p><pre><code>  function _wasGeneratedBy(\n    bytes32 _provId,\n    bytes32 _did,\n    address _agentId,\n    bytes32 _activityId,\n    string _attributes\n  ) internal returns (bool)\n</code></pre> Implements the W3C PROV Generation action</p>"},{"location":"contracts/registry/ProvenanceRegistry/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_provId</code> bytes32 unique identifier referring to the provenance entry <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created <code>_agentId</code> address refers to address of the agent creating the provenance record <code>_activityId</code> bytes32 refers to activity <code>_attributes</code> string refers to the provenance attributes"},{"location":"contracts/registry/ProvenanceRegistry/#return-values","title":"Return Values:","text":"Name Type Description <code>the</code> bytes32 number of the new provenance size ### _used <pre><code>  function _used(\n    bytes32 _provId,\n    bytes32 _did,\n    address _agentId,\n    bytes32 _activityId,\n    bytes _signatureUsing,\n    string _attributes\n  ) internal returns (bool success)\n</code></pre> Implements the W3C PROV Usage action"},{"location":"contracts/registry/ProvenanceRegistry/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_provId</code> bytes32 unique identifier referring to the provenance entry <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created <code>_agentId</code> address refers to address of the agent creating the provenance record <code>_activityId</code> bytes32 refers to activity <code>_signatureUsing</code> bytes refers to the digital signature provided by the agent using the _did <code>_attributes</code> string refers to the provenance attributes"},{"location":"contracts/registry/ProvenanceRegistry/#return-values_1","title":"Return Values:","text":"Name Type Description <code>success</code> bytes32 true if the action was properly registered ### _wasDerivedFrom <pre><code>  function _wasDerivedFrom(\n    bytes32 _provId,\n    bytes32 _newEntityDid,\n    bytes32 _usedEntityDid,\n    address _agentId,\n    bytes32 _activityId,\n    string _attributes\n  ) internal returns (bool success)\n</code></pre> Implements the W3C PROV Derivation action"},{"location":"contracts/registry/ProvenanceRegistry/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_provId</code> bytes32 unique identifier referring to the provenance entry <code>_newEntityDid</code> bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created <code>_usedEntityDid</code> bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity used to derive the new did <code>_agentId</code> address refers to address of the agent creating the provenance record <code>_activityId</code> bytes32 refers to activity <code>_attributes</code> string refers to the provenance attributes"},{"location":"contracts/registry/ProvenanceRegistry/#return-values_2","title":"Return Values:","text":"Name Type Description <code>success</code> bytes32 true if the action was properly registered ### _wasAssociatedWith <pre><code>  function _wasAssociatedWith(\n    bytes32 _provId,\n    bytes32 _did,\n    address _agentId,\n    bytes32 _activityId,\n    string _attributes\n  ) internal returns (bool success)\n</code></pre> Implements the W3C PROV Association action"},{"location":"contracts/registry/ProvenanceRegistry/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_provId</code> bytes32 unique identifier referring to the provenance entry <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity <code>_agentId</code> address refers to address of the agent creating the provenance record <code>_activityId</code> bytes32 refers to activity <code>_attributes</code> string refers to the provenance attributes"},{"location":"contracts/registry/ProvenanceRegistry/#return-values_3","title":"Return Values:","text":"Name Type Description <code>success</code> bytes32 true if the action was properly registered ### _actedOnBehalf <pre><code>  function _actedOnBehalf(\n    bytes32 _provId,\n    bytes32 _did,\n    address _delegateAgentId,\n    address _responsibleAgentId,\n    bytes32 _activityId,\n    bytes _signatureDelegate,\n    string _attributes\n  ) internal returns (bool success)\n</code></pre> Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId &amp; _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId)"},{"location":"contracts/registry/ProvenanceRegistry/#parameters_5","title":"Parameters:","text":"Name Type Description <code>_provId</code> bytes32 unique identifier referring to the provenance entry <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity <code>_delegateAgentId</code> address refers to address acting on behalf of the provenance record <code>_responsibleAgentId</code> address refers to address responsible of the provenance record <code>_activityId</code> bytes32 refers to activity <code>_signatureDelegate</code> bytes refers to the digital signature provided by the did delegate. <code>_attributes</code> string refers to the provenance attributes"},{"location":"contracts/registry/ProvenanceRegistry/#return-values_4","title":"Return Values:","text":"Name Type Description <code>success</code> bytes32 true if the action was properly registered ## Events ### ProvenanceAttributeRegistered <pre><code>  event ProvenanceAttributeRegistered(\n  )\n</code></pre> Provenance Events"},{"location":"contracts/registry/ProvenanceRegistry/#wasgeneratedby","title":"WasGeneratedBy","text":"<pre><code>  event WasGeneratedBy(\n  )\n</code></pre>"},{"location":"contracts/registry/ProvenanceRegistry/#used","title":"Used","text":"<pre><code>  event Used(\n  )\n</code></pre>"},{"location":"contracts/registry/ProvenanceRegistry/#wasderivedfrom","title":"WasDerivedFrom","text":"<pre><code>  event WasDerivedFrom(\n  )\n</code></pre>"},{"location":"contracts/registry/ProvenanceRegistry/#wasassociatedwith","title":"WasAssociatedWith","text":"<pre><code>  event WasAssociatedWith(\n  )\n</code></pre>"},{"location":"contracts/registry/ProvenanceRegistry/#actedonbehalf","title":"ActedOnBehalf","text":"<pre><code>  event ActedOnBehalf(\n  )\n</code></pre>"},{"location":"contracts/templates/AccessProofTemplate/","title":"AccessProofTemplate","text":"<p>Implementation of Access Agreement Template</p>"},{"location":"contracts/templates/AccessProofTemplate/#functions","title":"Functions","text":""},{"location":"contracts/templates/AccessProofTemplate/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _agreementStoreManagerAddress,\n    address _didRegistryAddress,\n    address _accessConditionAddress,\n    address _lockConditionAddress,\n    address payable _escrowConditionAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access , lock payment and escrow payment conditions.</p>"},{"location":"contracts/templates/AccessProofTemplate/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_agreementStoreManagerAddress</code> address agreement store manager contract address <code>_didRegistryAddress</code> address DID registry contract address <code>_accessConditionAddress</code> address access condition address <code>_lockConditionAddress</code> address lock reward condition contract address <code>_escrowConditionAddress</code> address payable escrow reward contract address"},{"location":"contracts/templates/AccessTemplate/","title":"AccessTemplate","text":"<p>Implementation of Access Agreement Template</p> <pre><code> Access template is use case specific template.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an on-chain SEA. The template is a composite of three basic\n conditions. Once the agreement is created, the consumer will lock an amount\n of tokens (as listed in the DID document - off-chain metadata) to the \n the lock reward contract which in turn will fire an event. ON the other hand \n the provider is listening to all the emitted events, the provider \n will catch the event and grant permissions to the consumer through \n secret store contract, the consumer now is able to download the data set\n by asking the off-chain component of secret store to decrypt the DID and \n encrypt it using the consumer's public key. Then the secret store will \n provide an on-chain proof that the consumer had access to the data set.\n Finally, the provider can call the escrow reward condition in order \n to release the payment. Every condition has a time window (time lock and \n time out). This implies that if the provider didn't grant the access to \n the consumer through secret store within this time window, the consumer \n can ask for refund.\n</code></pre>"},{"location":"contracts/templates/AccessTemplate/#functions","title":"Functions","text":""},{"location":"contracts/templates/AccessTemplate/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _agreementStoreManagerAddress,\n    address _didRegistryAddress,\n    address _accessConditionAddress,\n    address _lockConditionAddress,\n    address payable _escrowConditionAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access , lock payment and escrow payment conditions.</p>"},{"location":"contracts/templates/AccessTemplate/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_agreementStoreManagerAddress</code> address agreement store manager contract address <code>_didRegistryAddress</code> address DID registry contract address <code>_accessConditionAddress</code> address access condition address <code>_lockConditionAddress</code> address lock reward condition contract address <code>_escrowConditionAddress</code> address payable escrow reward contract address"},{"location":"contracts/templates/AgreementTemplate/","title":"AgreementTemplate","text":"<p>Implementation of Agreement Template</p> <pre><code> Agreement template is a reference template where it\n has the ability to create agreements from whitelisted \n template\n</code></pre>"},{"location":"contracts/templates/AgreementTemplate/#functions","title":"Functions","text":""},{"location":"contracts/templates/AgreementTemplate/#createagreement","title":"createAgreement","text":"<p><pre><code>  function createAgreement(\n    bytes32 _id,\n    bytes32 _did,\n    bytes32[] _conditionIds,\n    uint256[] _timeLocks,\n    uint256[] _timeOuts\n  ) public returns (uint256 size)\n</code></pre> createAgreement create new agreement</p>"},{"location":"contracts/templates/AgreementTemplate/#parameters","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 agreement unique identifier <code>_did</code> bytes32 refers to decentralized identifier (a bytes32 length ID). <code>_conditionIds</code> bytes32[] list of condition identifiers <code>_timeLocks</code> uint256[] list of time locks, each time lock will be assigned to the same condition that has the same index <code>_timeOuts</code> uint256[] list of time outs, each time out will be assigned to the same condition that has the same index"},{"location":"contracts/templates/AgreementTemplate/#return-values","title":"Return Values:","text":"Name Type Description <code>size</code> bytes32 the index of the created agreement ### getConditionTypes <pre><code>  function getConditionTypes(\n  ) public returns (address[])\n</code></pre> getConditionTypes gets the conditions addresses list <p>for the current template returns list of condition contracts       addresses</p>"},{"location":"contracts/templates/AgreementTemplate/#return-values_1","title":"Return Values:","text":"Name Type Description <code>list</code> of conditions contract addresses"},{"location":"contracts/templates/BaseEscrowTemplate/","title":"BaseEscrowTemplate","text":""},{"location":"contracts/templates/BaseEscrowTemplate/#functions","title":"Functions","text":""},{"location":"contracts/templates/BaseEscrowTemplate/#createagreement","title":"createAgreement","text":"<p><pre><code>  function createAgreement(\n    bytes32 _id,\n    bytes32 _did,\n    bytes32[] _conditionIds,\n    uint256[] _timeLocks,\n    uint256[] _timeOuts,\n    address _accessConsumer\n  ) public returns (uint256 size)\n</code></pre> createAgreement creates agreements through agreement template</p> <p>this function initializes the agreement by setting the DID,       conditions ID, timeouts, time locks and the consumer address.       The DID provider/owner is automatically detected by the DID       Registry</p>"},{"location":"contracts/templates/BaseEscrowTemplate/#parameters","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 SEA agreement unique identifier <code>_did</code> bytes32 Decentralized Identifier (DID) <code>_conditionIds</code> bytes32[] conditions ID associated with the condition types <code>_timeLocks</code> uint256[] the starting point of the time window ,time lock is in block number not seconds <code>_timeOuts</code> uint256[] the ending point of the time window ,time lock is in block number not seconds <code>_accessConsumer</code> address consumer address"},{"location":"contracts/templates/BaseEscrowTemplate/#return-values","title":"Return Values:","text":"Name Type Description <code>size</code> bytes32 the agreement index ### getAgreementData <pre><code>  function getAgreementData(\n    bytes32 _id\n  ) external returns (address accessConsumer, address accessProvider)\n</code></pre> getAgreementData return the agreement Data"},{"location":"contracts/templates/BaseEscrowTemplate/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_id</code> bytes32 SEA agreement unique identifier"},{"location":"contracts/templates/BaseEscrowTemplate/#return-values_1","title":"Return Values:","text":"Name Type Description <code>accessConsumer</code> bytes32 the agreement consumer <code>accessProvider</code> the provider addresses ## Events ### AgreementCreated <pre><code>  event AgreementCreated(\n  )\n</code></pre>"},{"location":"contracts/templates/DIDSalesTemplate/","title":"DIDSalesTemplate","text":"<p>Implementation of DID Sales Template</p> <pre><code> The DID Sales template supports an scenario where an Asset owner\n can sell that asset to a new Owner.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing an Asset owner to get transfer the asset ownership\n after some payment. \n The template is a composite of 3 basic conditions: \n - Lock Payment Condition\n - Transfer DID Condition\n - Escrow Reward Condition\n\n This scenario takes into account royalties for original creators in the secondary market.\n Once the agreement is created, the consumer after payment can request the ownership transfer of an asset\n from the current owner for a specific DID.\n</code></pre>"},{"location":"contracts/templates/DIDSalesTemplate/#functions","title":"Functions","text":""},{"location":"contracts/templates/DIDSalesTemplate/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _agreementStoreManagerAddress,\n    address _lockConditionAddress,\n    address _transferConditionAddress,\n    address payable _escrowPaymentAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p>"},{"location":"contracts/templates/DIDSalesTemplate/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_agreementStoreManagerAddress</code> address agreement store manager contract address <code>_lockConditionAddress</code> address lock reward condition contract address <code>_transferConditionAddress</code> address transfer ownership condition contract address <code>_escrowPaymentAddress</code> address payable escrow reward condition contract address"},{"location":"contracts/templates/DynamicAccessTemplate/","title":"DynamicAccessTemplate","text":"<p>Implementation of Agreement Template This is a dynamic template that allows to setup flexible conditions depending  on the use case.</p>"},{"location":"contracts/templates/DynamicAccessTemplate/#functions","title":"Functions","text":""},{"location":"contracts/templates/DynamicAccessTemplate/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _agreementStoreManagerAddress,\n    address _didRegistryAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p>"},{"location":"contracts/templates/DynamicAccessTemplate/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_agreementStoreManagerAddress</code> address agreement store manager contract address <code>_didRegistryAddress</code> address DID registry contract address"},{"location":"contracts/templates/DynamicAccessTemplate/#addtemplatecondition","title":"addTemplateCondition","text":"<p><pre><code>  function addTemplateCondition(\n    address _conditionAddress\n  ) external returns (uint256 length)\n</code></pre> addTemplateCondition adds a new condition to the template</p>"},{"location":"contracts/templates/DynamicAccessTemplate/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_conditionAddress</code> address condition contract address"},{"location":"contracts/templates/DynamicAccessTemplate/#return-values","title":"Return Values:","text":"Name Type Description <code>length</code> address conditionTypes array size ### removeLastTemplateCondition <pre><code>  function removeLastTemplateCondition(\n  ) external returns (address[])\n</code></pre> removeLastTemplateCondition removes last condition added to the template"},{"location":"contracts/templates/DynamicAccessTemplate/#return-values_1","title":"Return Values:","text":"Name Type Description <code>conditionTypes</code> existing in the array"},{"location":"contracts/templates/EscrowComputeExecutionTemplate/","title":"EscrowComputeExecutionTemplate","text":"<p>Implementation of a Compute Execution Agreement Template</p> <pre><code> EscrowComputeExecutionTemplate is use case specific template.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an on-chain SEA. The template is a composite of three basic\n conditions. Once the agreement is created, the consumer will lock an amount\n of tokens (as listed in the DID document - off-chain metadata) to the \n the lock reward contract which in turn will fire an event. ON the other hand \n the provider is listening to all the emitted events, the provider \n will catch the event and grant permissions to trigger a computation granting\n the execution via the ComputeExecutionCondition contract. \n The consumer now is able to trigger that computation\n by asking the off-chain gateway to start the execution of a compute workflow.\n Finally, the provider can call the escrow reward condition in order \n to release the payment. Every condition has a time window (time lock and \n time out). This implies that if the provider didn't grant the execution to \n the consumer within this time window, the consumer \n can ask for refund.\n</code></pre>"},{"location":"contracts/templates/EscrowComputeExecutionTemplate/#functions","title":"Functions","text":""},{"location":"contracts/templates/EscrowComputeExecutionTemplate/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _agreementStoreManagerAddress,\n    address _didRegistryAddress,\n    address _computeExecutionConditionAddress,\n    address _lockPaymentConditionAddress,\n    address payable _escrowPaymentAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        service executor condition, lock reward and escrow reward conditions.</p>"},{"location":"contracts/templates/EscrowComputeExecutionTemplate/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_agreementStoreManagerAddress</code> address agreement store manager contract address <code>_didRegistryAddress</code> address DID registry contract address <code>_computeExecutionConditionAddress</code> address service executor condition contract address <code>_lockPaymentConditionAddress</code> address lock reward condition contract address <code>_escrowPaymentAddress</code> address payable escrow reward contract address"},{"location":"contracts/templates/NFTAccessTemplate/","title":"NFTAccessTemplate","text":"<p>Implementation of NFT Access Template</p> <pre><code> The NFT Access template is use case specific template.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing NFT holders to get access to Nevermined services. \n The template is a composite of 2 basic conditions: \n - NFT Holding Condition\n - Access Condition\n\n Once the agreement is created, the consumer can demonstrate is holding a NFT\n for a specific DID. If that's the case the Access condition can be fulfilled\n by the asset owner or provider and all the agreement is fulfilled.\n This can be used in scenarios where a data or services owner, can allow \n users to get access to exclusive services only when they demonstrate the \n are holding a specific number of NFTs of a DID.\n This is very useful in use cases like arts.\n</code></pre>"},{"location":"contracts/templates/NFTAccessTemplate/#functions","title":"Functions","text":""},{"location":"contracts/templates/NFTAccessTemplate/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _agreementStoreManagerAddress,\n    address _nftHolderConditionAddress,\n    address _accessConditionAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p>"},{"location":"contracts/templates/NFTAccessTemplate/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_agreementStoreManagerAddress</code> address agreement store manager contract address <code>_nftHolderConditionAddress</code> address lock reward condition contract address <code>_accessConditionAddress</code> address access condition contract address"},{"location":"contracts/templates/NFTSalesTemplate/","title":"NFTSalesTemplate","text":"<p>Implementation of NFT Sales Template</p> <pre><code> The NFT Sales template supports an scenario where a NFT owner\n can sell that asset to a new Owner.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing a NFT owner to transfer the asset ownership\n after some payment. \n The template is a composite of 3 basic conditions: \n - Lock Payment Condition\n - Transfer NFT Condition\n - Escrow Reward Condition\n\n This scenario takes into account royalties for original creators in the secondary market.\n Once the agreement is created, the consumer after payment can request the transfer of the NFT\n from the current owner for a specific DID.\n</code></pre>"},{"location":"contracts/templates/NFTSalesTemplate/#functions","title":"Functions","text":""},{"location":"contracts/templates/NFTSalesTemplate/#initialize","title":"initialize","text":"<p><pre><code>  function initialize(\n    address _owner,\n    address _agreementStoreManagerAddress,\n    address _lockPaymentConditionAddress,\n    address _transferConditionAddress,\n    address payable _escrowPaymentAddress\n  ) external\n</code></pre> initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p>"},{"location":"contracts/templates/NFTSalesTemplate/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address contract's owner account address <code>_agreementStoreManagerAddress</code> address agreement store manager contract address <code>_lockPaymentConditionAddress</code> address lock reward condition contract address <code>_transferConditionAddress</code> address transfer NFT condition contract address <code>_escrowPaymentAddress</code> address payable escrow reward condition contract address"},{"location":"contracts/templates/TemplateStoreLibrary/","title":"TemplateStoreLibrary","text":"<p>Implementation of the Template Store Library.</p> <pre><code> Templates are blueprints for modular SEAs. When \n creating an Agreement, a templateId defines the condition \n and reward types that are instantiated in the ConditionStore.\n</code></pre>"},{"location":"contracts/templates/TemplateStoreLibrary/#functions","title":"Functions","text":""},{"location":"contracts/templates/TemplateStoreLibrary/#propose","title":"propose","text":"<p><pre><code>  function propose(\n    struct TemplateStoreLibrary.TemplateList _self,\n    address _id\n  ) internal returns (uint256 size)\n</code></pre> propose new template</p>"},{"location":"contracts/templates/TemplateStoreLibrary/#parameters","title":"Parameters:","text":"Name Type Description <code>_self</code> struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer <code>_id</code> address proposed template contract address"},{"location":"contracts/templates/TemplateStoreLibrary/#return-values","title":"Return Values:","text":"Name Type Description <code>size</code> struct TemplateStoreLibrary.TemplateList which is the index of the proposed template ### approve <pre><code>  function approve(\n    struct TemplateStoreLibrary.TemplateList _self,\n    address _id\n  ) internal\n</code></pre> approve new template"},{"location":"contracts/templates/TemplateStoreLibrary/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_self</code> struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer <code>_id</code> address proposed template contract address"},{"location":"contracts/templates/TemplateStoreLibrary/#revoke","title":"revoke","text":"<p><pre><code>  function revoke(\n    struct TemplateStoreLibrary.TemplateList _self,\n    address _id\n  ) internal\n</code></pre> revoke new template</p>"},{"location":"contracts/templates/TemplateStoreLibrary/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_self</code> struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer <code>_id</code> address approved template contract address"},{"location":"contracts/templates/TemplateStoreManager/","title":"TemplateStoreManager","text":"<p>Implementation of the Template Store Manager.      Templates are blueprints for modular SEAs. When creating an Agreement,       a templateId defines the condition and reward types that are instantiated       in the ConditionStore. This contract manages the life cycle       of the template ( Propose \u2192 Approve \u2192 Revoke ).</p>"},{"location":"contracts/templates/TemplateStoreManager/#functions","title":"Functions","text":""},{"location":"contracts/templates/TemplateStoreManager/#initialize","title":"initialize","text":"<pre><code>  function initialize(\n    address _owner\n  ) public\n</code></pre> <p>initialize TemplateStoreManager Initializer      Initializes Ownable. Only on contract creation.</p>"},{"location":"contracts/templates/TemplateStoreManager/#parameters","title":"Parameters:","text":"Name Type Description <code>_owner</code> address refers to the owner of the contract"},{"location":"contracts/templates/TemplateStoreManager/#proposetemplate","title":"proposeTemplate","text":"<p><pre><code>  function proposeTemplate(\n    address _id\n  ) external returns (uint256 size)\n</code></pre> proposeTemplate proposes a new template</p>"},{"location":"contracts/templates/TemplateStoreManager/#parameters_1","title":"Parameters:","text":"Name Type Description <code>_id</code> address unique template identifier which is basically the template contract address"},{"location":"contracts/templates/TemplateStoreManager/#approvetemplate","title":"approveTemplate","text":"<p><pre><code>  function approveTemplate(\n    address _id\n  ) external\n</code></pre> approveTemplate approves a template</p>"},{"location":"contracts/templates/TemplateStoreManager/#parameters_2","title":"Parameters:","text":"Name Type Description <code>_id</code> address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) can approve this template."},{"location":"contracts/templates/TemplateStoreManager/#revoketemplate","title":"revokeTemplate","text":"<p><pre><code>  function revokeTemplate(\n    address _id\n  ) external\n</code></pre> revokeTemplate revoke a template</p>"},{"location":"contracts/templates/TemplateStoreManager/#parameters_3","title":"Parameters:","text":"Name Type Description <code>_id</code> address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) or template owner can revoke this template."},{"location":"contracts/templates/TemplateStoreManager/#gettemplate","title":"getTemplate","text":"<p><pre><code>  function getTemplate(\n    address _id\n  ) external returns (enum TemplateStoreLibrary.TemplateState state, address owner, address lastUpdatedBy, uint256 blockNumberUpdated)\n</code></pre> getTemplate get more information about a template</p>"},{"location":"contracts/templates/TemplateStoreManager/#parameters_4","title":"Parameters:","text":"Name Type Description <code>_id</code> address unique template identifier which is basically the template contract address."},{"location":"contracts/templates/TemplateStoreManager/#return-values","title":"Return Values:","text":"Name Type Description <code>state</code> address template status <code>owner</code> template owner <code>lastUpdatedBy</code> last updated by <code>blockNumberUpdated</code> last updated at. ### getTemplateListSize <pre><code>  function getTemplateListSize(\n  ) external returns (uint256 size)\n</code></pre> getTemplateListSize number of templates"},{"location":"contracts/templates/TemplateStoreManager/#return-values_1","title":"Return Values:","text":"Name Type Description <code>size</code> number of templates ### isTemplateApproved <pre><code>  function isTemplateApproved(\n    address _id\n  ) external returns (bool)\n</code></pre> isTemplateApproved check whether the template is approved"},{"location":"contracts/templates/TemplateStoreManager/#parameters_5","title":"Parameters:","text":"Name Type Description <code>_id</code> address unique template identifier which is basically the template contract address."},{"location":"contracts/templates/TemplateStoreManager/#return-values_2","title":"Return Values:","text":"Name Type Description <code>true</code> address if the template is approved"},{"location":"contracts/test/IPNFT/","title":"IPNFT","text":""},{"location":"contracts/test/IPNFT/#functions","title":"Functions","text":""},{"location":"contracts/test/IPNFT/#initialize","title":"initialize","text":"<pre><code>  function initialize(\n  ) public\n</code></pre>"},{"location":"contracts/test/IPNFT/#settokenuri","title":"setTokenURI","text":"<pre><code>  function setTokenURI(\n  ) public\n</code></pre>"},{"location":"contracts/test/IPNFT/#mint","title":"mint","text":"<pre><code>  function mint(\n  ) public returns (bool)\n</code></pre>"},{"location":"contracts/test/IPNFT/#mintwithouttokenuri","title":"mintWithoutTokenURI","text":"<pre><code>  function mintWithoutTokenURI(\n  ) external\n</code></pre>"},{"location":"contracts/test/IPNFT/#transfer","title":"transfer","text":"<pre><code>  function transfer(\n  ) public\n</code></pre>"},{"location":"contracts/test/IPNFT/#events","title":"Events","text":""},{"location":"contracts/test/IPNFT/#tokenurichanged","title":"TokenURIChanged","text":"<pre><code>  event TokenURIChanged(\n  )\n</code></pre>"},{"location":"contracts/test/TestDisputeManager/","title":"TestDisputeManager","text":""},{"location":"contracts/test/TestDisputeManager/#functions","title":"Functions","text":""},{"location":"contracts/test/TestDisputeManager/#accepted","title":"accepted","text":"<pre><code>  function accepted(\n  ) public returns (bool)\n</code></pre>"},{"location":"contracts/test/TestDisputeManager/#setaccepted","title":"setAccepted","text":"<pre><code>  function setAccepted(\n  ) public\n</code></pre>"},{"location":"contracts/test/TestERC721/","title":"TestERC721","text":""},{"location":"contracts/test/TestERC721/#functions","title":"Functions","text":""},{"location":"contracts/test/TestERC721/#initialize","title":"initialize","text":"<pre><code>  function initialize(\n  ) public\n</code></pre>"},{"location":"contracts/test/TestERC721/#mint","title":"mint","text":"<pre><code>  function mint(\n  ) public\n</code></pre>"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerChangeFunctionSignature/","title":"AgreementStoreManagerChangeFunctionSignature","text":""},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerChangeFunctionSignature/#functions","title":"Functions","text":""},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerChangeFunctionSignature/#createagreement","title":"createAgreement","text":"<pre><code>  function createAgreement(\n  ) public returns (uint256 size)\n</code></pre>"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerExtraFunctionality/","title":"AgreementStoreManagerExtraFunctionality","text":""},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerExtraFunctionality/#functions","title":"Functions","text":""},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerExtraFunctionality/#dummyfunction","title":"dummyFunction","text":"<pre><code>  function dummyFunction(\n  ) public returns (bool)\n</code></pre>"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerWithBug/","title":"AgreementStoreManagerWithBug","text":""},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerWithBug/#functions","title":"Functions","text":""},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerWithBug/#getagreementlistsize","title":"getAgreementListSize","text":"<pre><code>  function getAgreementListSize(\n  ) public returns (uint256 size)\n</code></pre>"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreChangeFunctionSignature/","title":"ConditionStoreChangeFunctionSignature","text":""},{"location":"contracts/test/ConditionStoreManager/ConditionStoreChangeFunctionSignature/#functions","title":"Functions","text":""},{"location":"contracts/test/ConditionStoreManager/ConditionStoreChangeFunctionSignature/#createcondition","title":"createCondition","text":"<pre><code>  function createCondition(\n  ) public returns (uint256 size)\n</code></pre>"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreExtraFunctionality/","title":"ConditionStoreExtraFunctionality","text":""},{"location":"contracts/test/ConditionStoreManager/ConditionStoreExtraFunctionality/#functions","title":"Functions","text":""},{"location":"contracts/test/ConditionStoreManager/ConditionStoreExtraFunctionality/#dummyfunction","title":"dummyFunction","text":"<pre><code>  function dummyFunction(\n  ) public returns (bool)\n</code></pre>"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreWithBug/","title":"ConditionStoreWithBug","text":""},{"location":"contracts/test/ConditionStoreManager/ConditionStoreWithBug/#functions","title":"Functions","text":""},{"location":"contracts/test/ConditionStoreManager/ConditionStoreWithBug/#getconditionstate","title":"getConditionState","text":"<pre><code>  function getConditionState(\n  ) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"contracts/test/DIDRegistry/DIDRegistryChangeFunctionSignature/","title":"DIDRegistryChangeFunctionSignature","text":""},{"location":"contracts/test/DIDRegistry/DIDRegistryChangeFunctionSignature/#functions","title":"Functions","text":""},{"location":"contracts/test/DIDRegistry/DIDRegistryChangeFunctionSignature/#registerattribute","title":"registerAttribute","text":"<pre><code>  function registerAttribute(\n  ) public returns (uint256 size)\n</code></pre>"},{"location":"contracts/test/DIDRegistry/DIDRegistryExtraFunctionality/","title":"DIDRegistryExtraFunctionality","text":""},{"location":"contracts/test/DIDRegistry/DIDRegistryExtraFunctionality/#functions","title":"Functions","text":""},{"location":"contracts/test/DIDRegistry/DIDRegistryExtraFunctionality/#getnumber","title":"getNumber","text":"<pre><code>  function getNumber(\n  ) public returns (uint256)\n</code></pre>"},{"location":"contracts/test/DIDRegistry/DIDRegistryWithBug/","title":"DIDRegistryWithBug","text":""},{"location":"contracts/test/DIDRegistry/DIDRegistryWithBug/#functions","title":"Functions","text":""},{"location":"contracts/test/DIDRegistry/DIDRegistryWithBug/#registerattribute","title":"registerAttribute","text":"<p><pre><code>  function registerAttribute(\n    bytes32 _didSeed,\n    bytes32 _checksum,\n    address[] _url\n  ) public returns (uint256 size)\n</code></pre> registerAttribute is called only by DID owner.</p> <p>this function registers DID attributes</p>"},{"location":"contracts/test/DIDRegistry/DIDRegistryWithBug/#parameters","title":"Parameters:","text":"Name Type Description <code>_didSeed</code> bytes32 refers to decentralized identifier (a byte32 length ID) <code>_checksum</code> bytes32 includes a one-way HASH calculated using the DDO content <code>_url</code> address[] refers to the attribute value"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreChangeFunctionSignature/","title":"TemplateStoreChangeFunctionSignature","text":""},{"location":"contracts/test/TemplateStoreManager/TemplateStoreChangeFunctionSignature/#functions","title":"Functions","text":""},{"location":"contracts/test/TemplateStoreManager/TemplateStoreChangeFunctionSignature/#proposetemplate","title":"proposeTemplate","text":"<pre><code>  function proposeTemplate(\n  ) external returns (uint256 size)\n</code></pre>"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreExtraFunctionality/","title":"TemplateStoreExtraFunctionality","text":""},{"location":"contracts/test/TemplateStoreManager/TemplateStoreExtraFunctionality/#functions","title":"Functions","text":""},{"location":"contracts/test/TemplateStoreManager/TemplateStoreExtraFunctionality/#dummyfunction","title":"dummyFunction","text":"<pre><code>  function dummyFunction(\n  ) public returns (bool)\n</code></pre>"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreWithBug/","title":"TemplateStoreWithBug","text":""},{"location":"contracts/test/TemplateStoreManager/TemplateStoreWithBug/#functions","title":"Functions","text":""},{"location":"contracts/test/TemplateStoreManager/TemplateStoreWithBug/#gettemplatelistsize","title":"getTemplateListSize","text":"<pre><code>  function getTemplateListSize(\n  ) external returns (uint256 size)\n</code></pre>"},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/","title":"DIDRegistryLibraryProxy","text":""},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/#functions","title":"Functions","text":""},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/#areroyaltiesvalid","title":"areRoyaltiesValid","text":"<pre><code>  function areRoyaltiesValid(\n  ) public returns (bool)\n</code></pre>"},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/#updatedidowner","title":"updateDIDOwner","text":"<pre><code>  function updateDIDOwner(\n  ) public\n</code></pre>"},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/#update","title":"update","text":"<pre><code>  function update(\n  ) public returns (uint256 size)\n</code></pre>"},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/#initializenftconfig","title":"initializeNftConfig","text":"<pre><code>  function initializeNftConfig(\n  ) public\n</code></pre>"},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/#getdidinfo","title":"getDIDInfo","text":"<pre><code>  function getDIDInfo(\n  ) public returns (address owner, address creator, uint256 royalties)\n</code></pre>"},{"location":"contracts/test/libraries/EpochLibraryProxy/","title":"EpochLibraryProxy","text":""},{"location":"contracts/test/libraries/EpochLibraryProxy/#functions","title":"Functions","text":""},{"location":"contracts/test/libraries/EpochLibraryProxy/#create","title":"create","text":"<pre><code>  function create(\n  ) external\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/","title":"HashListLibraryProxy","text":""},{"location":"contracts/test/libraries/HashListLibraryProxy/#functions","title":"Functions","text":""},{"location":"contracts/test/libraries/HashListLibraryProxy/#initialize","title":"initialize","text":"<pre><code>  function initialize(\n  ) public\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/#hash","title":"hash","text":"<pre><code>  function hash(\n  ) public returns (bytes32)\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/#add","title":"add","text":"<pre><code>  function add(\n  ) external returns (bool)\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/#add_1","title":"add","text":"<pre><code>  function add(\n  ) external returns (bool)\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/#update","title":"update","text":"<pre><code>  function update(\n  ) external returns (bool)\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/#index","title":"index","text":"<pre><code>  function index(\n  ) external returns (bool)\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/#has","title":"has","text":"<pre><code>  function has(\n  ) external returns (bool)\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/#remove","title":"remove","text":"<pre><code>  function remove(\n  ) external returns (bool)\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/#get","title":"get","text":"<pre><code>  function get(\n  ) external returns (bytes32)\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/#size","title":"size","text":"<pre><code>  function size(\n  ) external returns (uint256)\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/#all","title":"all","text":"<pre><code>  function all(\n  ) external returns (bytes32[])\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/#indexof","title":"indexOf","text":"<pre><code>  function indexOf(\n  ) external returns (uint256)\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/#ownedby","title":"ownedBy","text":"<pre><code>  function ownedBy(\n  ) external returns (address)\n</code></pre>"},{"location":"contracts/test/libraries/HashListLibraryProxy/#isindexed","title":"isIndexed","text":"<pre><code>  function isIndexed(\n  ) external returns (bool)\n</code></pre>"},{"location":"contracts/token/erc1155/NFTUpgradeable/","title":"NFTUpgradeable","text":"<p>Implementation of the basic standard multi-token. See https://eips.ethereum.org/EIPS/eip-1155 Originally based on code by Enjin: https://github.com/enjin/erc-1155</p> <p>Available since v3.1.</p>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#functions","title":"Functions","text":""},{"location":"contracts/token/erc1155/NFTUpgradeable/#__nftupgradeable_init","title":"__NFTUpgradeable_init","text":"<pre><code>  function __NFTUpgradeable_init(\n  ) internal\n</code></pre> <p>See {_setURI}.</p>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#__erc1155_init_unchained","title":"__ERC1155_init_unchained","text":"<pre><code>  function __ERC1155_init_unchained(\n  ) internal\n</code></pre>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#uri","title":"uri","text":"<pre><code>  function uri(\n  ) external returns (string)\n</code></pre> <p>See {IERC1155MetadataURI-uri}.</p> <p>This implementation returns the same URI for all token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].</p> <p>Clients calling this function must replace the <code>\\{id\\}</code> substring with the actual token type ID.</p>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#burn","title":"burn","text":"<pre><code>  function burn(\n  ) public\n</code></pre>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#burnbatch","title":"burnBatch","text":"<pre><code>  function burnBatch(\n  ) public\n</code></pre>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#balanceof","title":"balanceOf","text":"<pre><code>  function balanceOf(\n  ) public returns (uint256)\n</code></pre> <p>See {IERC1155-balanceOf}.</p> <p>Requirements:</p> <ul> <li><code>account</code> cannot be the zero address.</li> </ul>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#balanceof_1","title":"balanceOf","text":"<pre><code>  function balanceOf(\n  ) external returns (uint256)\n</code></pre> <p>Returns the amount of tokens of token type <code>id</code> owned by <code>account</code>.</p> <p>Requirements:</p> <ul> <li><code>account</code> cannot be the zero address.</li> </ul>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#balanceofbatch","title":"balanceOfBatch","text":"<pre><code>  function balanceOfBatch(\n  ) public returns (uint256[])\n</code></pre> <p>See {IERC1155-balanceOfBatch}.</p> <p>Requirements:</p> <ul> <li><code>accounts</code> and <code>ids</code> must have the same length.</li> </ul>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#setapprovalforall","title":"setApprovalForAll","text":"<pre><code>  function setApprovalForAll(\n  ) public\n</code></pre> <p>See {IERC1155-setApprovalForAll}.</p>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#setproxyapproval","title":"setProxyApproval","text":"<pre><code>  function setProxyApproval(\n  ) public\n</code></pre>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#isapprovedforall","title":"isApprovedForAll","text":"<pre><code>  function isApprovedForAll(\n  ) public returns (bool)\n</code></pre> <p>See {IERC1155-isApprovedForAll}.</p>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#isholder","title":"isHolder","text":"<pre><code>  function isHolder(\n  ) public returns (bool)\n</code></pre>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#safetransferfrom","title":"safeTransferFrom","text":"<pre><code>  function safeTransferFrom(\n  ) public\n</code></pre> <p>See {IERC1155-safeTransferFrom}.</p>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#safebatchtransferfrom","title":"safeBatchTransferFrom","text":"<pre><code>  function safeBatchTransferFrom(\n  ) public\n</code></pre> <p>See {IERC1155-safeBatchTransferFrom}.</p>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#_mint","title":"_mint","text":"<pre><code>  function _mint(\n  ) internal\n</code></pre> <p>Creates <code>amount</code> tokens of token type <code>id</code>, and assigns them to <code>account</code>.</p> <p>Emits a {TransferSingle} event.</p> <p>Requirements:</p> <ul> <li><code>account</code> cannot be the zero address.</li> <li>If <code>to</code> refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value.</li> </ul>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#_mintbatch","title":"_mintBatch","text":"<pre><code>  function _mintBatch(\n  ) internal\n</code></pre> <p>xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.</p> <p>Requirements:</p> <ul> <li><code>ids</code> and <code>amounts</code> must have the same length.</li> <li>If <code>to</code> refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.</li> </ul>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#_burn","title":"_burn","text":"<pre><code>  function _burn(\n  ) internal\n</code></pre> <p>Destroys <code>amount</code> tokens of token type <code>id</code> from <code>account</code></p> <p>Requirements:</p> <ul> <li><code>account</code> cannot be the zero address.</li> <li><code>account</code> must have at least <code>amount</code> tokens of token type <code>id</code>.</li> </ul>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#_burnbatch","title":"_burnBatch","text":"<pre><code>  function _burnBatch(\n  ) internal\n</code></pre> <p>xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.</p> <p>Requirements:</p> <ul> <li><code>ids</code> and <code>amounts</code> must have the same length.</li> </ul>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#_beforetokentransfer","title":"_beforeTokenTransfer","text":"<pre><code>  function _beforeTokenTransfer(\n  ) internal\n</code></pre> <p>Hook that is called before any token transfer. This includes minting and burning, as well as batched variants.</p> <p>The same hook is called on both single and batched variants. For single transfers, the length of the <code>id</code> and <code>amount</code> arrays will be 1.</p> <p>Calling conditions (for each <code>id</code> and <code>amount</code> pair):</p> <ul> <li>When <code>from</code> and <code>to</code> are both non-zero, <code>amount</code> of <code>from</code>'s tokens of token type <code>id</code> will be  transferred to <code>to</code>.</li> <li>When <code>from</code> is zero, <code>amount</code> tokens of token type <code>id</code> will be minted for <code>to</code>.</li> <li>when <code>to</code> is zero, <code>amount</code> of <code>from</code>'s tokens of token type <code>id</code> will be burned.</li> <li><code>from</code> and <code>to</code> are never both zero.</li> <li><code>ids</code> and <code>amounts</code> have the same, non-zero length.</li> </ul> <p>To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</p>"},{"location":"contracts/token/erc1155/NFTUpgradeable/#events","title":"Events","text":""},{"location":"contracts/token/erc1155/NFTUpgradeable/#proxyapproval","title":"ProxyApproval","text":"<p><pre><code>  event ProxyApproval(\n  )\n</code></pre> Event for recording proxy approvals.</p>"},{"location":"generated/solidity-api/","title":"Solidity API","text":""},{"location":"generated/solidity-api/#testdisputemanager","title":"TestDisputeManager","text":""},{"location":"generated/solidity-api/#accept","title":"accept","text":"<pre><code>mapping(bytes32 =&gt; bool) accept\n</code></pre>"},{"location":"generated/solidity-api/#accepted","title":"accepted","text":"<pre><code>function accepted(address provider, address buyer, bytes32 orig, bytes32 crypted) public view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#setaccepted","title":"setAccepted","text":"<pre><code>function setAccepted(bytes32 orig, bytes32 crypted, address provider, address buyer) public\n</code></pre>"},{"location":"generated/solidity-api/#common","title":"Common","text":""},{"location":"generated/solidity-api/#getcurrentblocknumber","title":"getCurrentBlockNumber","text":"<pre><code>function getCurrentBlockNumber() external view returns (uint256)\n</code></pre> <p>getCurrentBlockNumber get block number</p> Name Type Description [0] uint256 the current block number"},{"location":"generated/solidity-api/#iscontract","title":"isContract","text":"<pre><code>function isContract(address addr) public view returns (bool)\n</code></pre> <p>isContract detect whether the address is           is a contract address or externally owned account</p> Name Type Description [0] bool true if it is a contract address"},{"location":"generated/solidity-api/#provenancesignatureiscorrect","title":"provenanceSignatureIsCorrect","text":"<pre><code>function provenanceSignatureIsCorrect(address _agentId, bytes32 _hash, bytes _signature) public pure returns (bool)\n</code></pre> Name Type Description _agentId address The address of the agent _hash bytes32 bytes32 message, the hash is the signed message. What is recovered is the signer address. _signature bytes Signatures provided by the agent Name Type Description [0] bool true if the signature correspond to the agent address"},{"location":"generated/solidity-api/#calculatetotalamount","title":"calculateTotalAmount","text":"<pre><code>function calculateTotalAmount(uint256[] _amounts) public pure returns (uint256)\n</code></pre> <p>Sum the total amount given an uint array</p> Name Type Description [0] uint256 the total amount"},{"location":"generated/solidity-api/#addresstobytes32","title":"addressToBytes32","text":"<pre><code>function addressToBytes32(address _addr) public pure returns (bytes32)\n</code></pre>"},{"location":"generated/solidity-api/#bytes32toaddress","title":"bytes32ToAddress","text":"<pre><code>function bytes32ToAddress(bytes32 _b32) public pure returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#dispenser","title":"Dispenser","text":""},{"location":"generated/solidity-api/#tokenrequests","title":"tokenRequests","text":"<pre><code>mapping(address =&gt; uint256) tokenRequests\n</code></pre>"},{"location":"generated/solidity-api/#totalmintamount","title":"totalMintAmount","text":"<pre><code>uint256 totalMintAmount\n</code></pre>"},{"location":"generated/solidity-api/#maxamount","title":"maxAmount","text":"<pre><code>uint256 maxAmount\n</code></pre>"},{"location":"generated/solidity-api/#maxmintamount","title":"maxMintAmount","text":"<pre><code>uint256 maxMintAmount\n</code></pre>"},{"location":"generated/solidity-api/#minperiod","title":"minPeriod","text":"<pre><code>uint256 minPeriod\n</code></pre>"},{"location":"generated/solidity-api/#scale","title":"scale","text":"<pre><code>uint256 scale\n</code></pre>"},{"location":"generated/solidity-api/#token","title":"token","text":"<pre><code>contract NeverminedToken token\n</code></pre>"},{"location":"generated/solidity-api/#requestfrequencyexceeded","title":"RequestFrequencyExceeded","text":"<pre><code>event RequestFrequencyExceeded(address requester, uint256 minPeriod)\n</code></pre>"},{"location":"generated/solidity-api/#requestlimitexceeded","title":"RequestLimitExceeded","text":"<pre><code>event RequestLimitExceeded(address requester, uint256 amount, uint256 maxAmount)\n</code></pre>"},{"location":"generated/solidity-api/#isvalidaddress","title":"isValidAddress","text":"<pre><code>modifier isValidAddress(address _address)\n</code></pre>"},{"location":"generated/solidity-api/#initialize","title":"initialize","text":"<pre><code>function initialize(address _tokenAddress, address _owner) external\n</code></pre> <p>Dispenser Initializer</p> Name Type Description _tokenAddress address The deployed contract address of an ERC20 _owner address The owner of the Dispenser Runs only on initial contract creation."},{"location":"generated/solidity-api/#requesttokens","title":"requestTokens","text":"<pre><code>function requestTokens(uint256 amount) external returns (bool tokensTransferred)\n</code></pre> <p>user can request some tokens for testing</p> Name Type Description amount uint256 the amount of tokens to be requested Name Type Description tokensTransferred bool Boolean indication of tokens are requested"},{"location":"generated/solidity-api/#setminperiod","title":"setMinPeriod","text":"<pre><code>function setMinPeriod(uint256 period) external\n</code></pre> <p>the Owner can set the min period for token requests</p> Name Type Description period uint256 the min amount of time before next request"},{"location":"generated/solidity-api/#setmaxamount","title":"setMaxAmount","text":"<pre><code>function setMaxAmount(uint256 amount) external\n</code></pre> <p>the Owner can set the max amount for token requests</p> Name Type Description amount uint256 the max amount of tokens that can be requested"},{"location":"generated/solidity-api/#setmaxmintamount","title":"setMaxMintAmount","text":"<pre><code>function setMaxMintAmount(uint256 amount) external\n</code></pre> <p>the Owner can set the max amount for token requests</p> Name Type Description amount uint256 the max amount of tokens that can be requested"},{"location":"generated/solidity-api/#hashlists","title":"HashLists","text":"<p>Hash lists contract is a sample list contract in which uses       HashListLibrary.sol in order to store, retrieve, remove, and       update bytes32 values in hash lists.      This is a reference implementation for IList interface. It is       used for whitelisting condition. Any entity can have its own       implementation of the interface in which could be used for the      same condition.</p>"},{"location":"generated/solidity-api/#lists","title":"lists","text":"<pre><code>mapping(bytes32 =&gt; struct HashListLibrary.List) lists\n</code></pre>"},{"location":"generated/solidity-api/#initialize_1","title":"initialize","text":"<pre><code>function initialize(address _owner) public\n</code></pre> <p>HashLists Initializer</p> Name Type Description _owner address The owner of the hash list Runs only upon contract creation."},{"location":"generated/solidity-api/#hash","title":"hash","text":"<pre><code>function hash(address account) public pure returns (bytes32)\n</code></pre> <p>hash ethereum accounts</p> Name Type Description account address Ethereum address Name Type Description [0] bytes32 bytes32 hash of the account"},{"location":"generated/solidity-api/#add","title":"add","text":"<pre><code>function add(bytes32[] values) external returns (bool)\n</code></pre> <p>put an array of elements without indexing      this meant to save gas in case of large arrays</p> Name Type Description values bytes32[] is an array of elements value Name Type Description [0] bool true if values are added successfully"},{"location":"generated/solidity-api/#add_1","title":"add","text":"<pre><code>function add(bytes32 value) external returns (bool)\n</code></pre> <p>add indexes an element then adds it to a list</p> Name Type Description value bytes32 is a bytes32 value Name Type Description [0] bool true if value is added successfully"},{"location":"generated/solidity-api/#update","title":"update","text":"<pre><code>function update(bytes32 oldValue, bytes32 newValue) external returns (bool)\n</code></pre> <p>update the value with a new value and maintain indices</p> Name Type Description oldValue bytes32 is an element value in a list newValue bytes32 new value Name Type Description [0] bool true if value is updated successfully"},{"location":"generated/solidity-api/#index","title":"index","text":"<pre><code>function index(uint256 from, uint256 to) external returns (bool)\n</code></pre> <p>index is used to map each element value to its index on the list</p> Name Type Description from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Name Type Description [0] bool true if the sub list is indexed"},{"location":"generated/solidity-api/#has","title":"has","text":"<pre><code>function has(bytes32 id, bytes32 value) external view returns (bool)\n</code></pre> <p>has checks whether a value is exist</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Name Type Description [0] bool true if the value exists"},{"location":"generated/solidity-api/#has_1","title":"has","text":"<pre><code>function has(bytes32 value) external view returns (bool)\n</code></pre> <p>has checks whether a value is exist</p> Name Type Description value bytes32 is element value in list Name Type Description [0] bool true if the value exists"},{"location":"generated/solidity-api/#remove","title":"remove","text":"<pre><code>function remove(bytes32 value) external returns (bool)\n</code></pre> <p>remove value from a list, updates indices, and list size</p> Name Type Description value bytes32 is an element value in a list Name Type Description [0] bool true if value is removed successfully"},{"location":"generated/solidity-api/#get","title":"get","text":"<pre><code>function get(bytes32 id, uint256 _index) external view returns (bytes32)\n</code></pre> <p>has value by index</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) _index uint256 is where is value is stored in the list Name Type Description [0] bytes32 the value if exists"},{"location":"generated/solidity-api/#size","title":"size","text":"<pre><code>function size(bytes32 id) external view returns (uint256)\n</code></pre> <p>size gets the list size</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] uint256 total length of the list"},{"location":"generated/solidity-api/#all","title":"all","text":"<pre><code>function all(bytes32 id) external view returns (bytes32[])\n</code></pre> <p>all returns all list elements</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] bytes32[] all list elements"},{"location":"generated/solidity-api/#indexof","title":"indexOf","text":"<pre><code>function indexOf(bytes32 id, bytes32 value) external view returns (uint256)\n</code></pre> <p>indexOf gets the index of a value in a list</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Name Type Description [0] uint256 value index in list"},{"location":"generated/solidity-api/#ownedby","title":"ownedBy","text":"<pre><code>function ownedBy(bytes32 id) external view returns (address)\n</code></pre> <p>ownedBy gets the list owner</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] address list owner"},{"location":"generated/solidity-api/#isindexed","title":"isIndexed","text":"<pre><code>function isIndexed(bytes32 id) external view returns (bool)\n</code></pre> <p>isIndexed checks if the list is indexed</p> Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] bool true if the list is indexed"},{"location":"generated/solidity-api/#neverminedtoken","title":"NeverminedToken","text":"<p>Implementation of a Test Token.      Test Token is an ERC20 token only for testing purposes</p>"},{"location":"generated/solidity-api/#initialize_2","title":"initialize","text":"<pre><code>function initialize(address _owner, address payable _initialMinter) public\n</code></pre> <p>NeverminedToken Initializer      Runs only on initial contract creation.</p> Name Type Description _owner address refers to the owner of the contract _initialMinter address payable is the first token minter added"},{"location":"generated/solidity-api/#_beforetokentransfer","title":"_beforeTokenTransfer","text":"<pre><code>function _beforeTokenTransfer(address from, address to, uint256 amount) internal\n</code></pre> <p>_See {ERC20-_beforeTokenTransfer}.</p> <p>Requirements:</p> <ul> <li>minted tokens must not cause the total supply to go over the cap._</li> </ul>"},{"location":"generated/solidity-api/#mint","title":"mint","text":"<pre><code>function mint(address account, uint256 amount) external returns (bool)\n</code></pre> <p>_Creates <code>amount</code> tokens and assigns them to <code>account</code>, increasing the total supply.</p> <p>Emits a {Transfer} event with <code>from</code> set to the zero address.</p> <p>Requirements:</p> <ul> <li><code>to</code> cannot be the zero address._</li> </ul>"},{"location":"generated/solidity-api/#agreementstorelibrary","title":"AgreementStoreLibrary","text":"<p>Implementation of the Agreement Store Library.      The agreement store library holds the business logic      in which manages the life cycle of SEA agreement, each       agreement is linked to the DID of an asset, template, and      condition IDs.</p>"},{"location":"generated/solidity-api/#agreement","title":"Agreement","text":"<pre><code>struct Agreement {\n  bytes32 did;\n  address templateId;\n  bytes32[] conditionIds;\n  address lastUpdatedBy;\n  uint256 blockNumberUpdated;\n}\n</code></pre>"},{"location":"generated/solidity-api/#agreementlist","title":"AgreementList","text":"<pre><code>struct AgreementList {\n  mapping(bytes32 &amp;#x3D;&amp;gt; struct AgreementStoreLibrary.Agreement) agreements;\n  mapping(bytes32 &amp;#x3D;&amp;gt; bytes32[]) didToAgreementIds;\n  mapping(address &amp;#x3D;&amp;gt; bytes32[]) templateIdToAgreementIds;\n  bytes32[] agreementIds;\n}\n</code></pre>"},{"location":"generated/solidity-api/#create","title":"create","text":"<pre><code>function create(struct AgreementStoreLibrary.AgreementList _self, bytes32 _id, bytes32, address _templateId, bytes32[]) internal\n</code></pre> <p>create new agreement      checks whether the agreement Id exists, creates new agreement       instance, including the template, conditions and DID.</p> Name Type Description _self struct AgreementStoreLibrary.AgreementList is AgreementList storage pointer _id bytes32 agreement identifier bytes32 _templateId address template identifier bytes32[]"},{"location":"generated/solidity-api/#template","title":"Template","text":""},{"location":"generated/solidity-api/#getconditiontypes","title":"getConditionTypes","text":"<pre><code>function getConditionTypes() external view returns (address[])\n</code></pre>"},{"location":"generated/solidity-api/#agreementstoremanager","title":"AgreementStoreManager","text":"<p>_Implementation of the Agreement Store.</p> <pre><code> The agreement store generates conditions for an agreement template.\n Agreement templates must to be approved in the Template Store\n Each agreement is linked to the DID of an asset._\n</code></pre>"},{"location":"generated/solidity-api/#proxy_role","title":"PROXY_ROLE","text":"<pre><code>bytes32 PROXY_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#grantproxyrole","title":"grantProxyRole","text":"<pre><code>function grantProxyRole(address _address) public\n</code></pre>"},{"location":"generated/solidity-api/#revokeproxyrole","title":"revokeProxyRole","text":"<pre><code>function revokeProxyRole(address _address) public\n</code></pre>"},{"location":"generated/solidity-api/#agreementlist_1","title":"agreementList","text":"<pre><code>struct AgreementStoreLibrary.AgreementList agreementList\n</code></pre> <p>state storage for the agreements</p>"},{"location":"generated/solidity-api/#conditionstoremanager","title":"conditionStoreManager","text":"<pre><code>contract ConditionStoreManager conditionStoreManager\n</code></pre>"},{"location":"generated/solidity-api/#templatestoremanager","title":"templateStoreManager","text":"<pre><code>contract TemplateStoreManager templateStoreManager\n</code></pre>"},{"location":"generated/solidity-api/#didregistry","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#initialize_3","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _templateStoreManagerAddress, address _didRegistryAddress) public\n</code></pre> <p>initialize AgreementStoreManager Initializer      Initializes Ownable. Only on contract creation.</p> Name Type Description _owner address refers to the owner of the contract _conditionStoreManagerAddress address is the address of the connected condition store _templateStoreManagerAddress address is the address of the connected template store _didRegistryAddress address is the address of the connected DID Registry"},{"location":"generated/solidity-api/#fullconditionid","title":"fullConditionId","text":"<pre><code>function fullConditionId(bytes32 _agreementId, address _condType, bytes32 _valueHash) public pure returns (bytes32)\n</code></pre>"},{"location":"generated/solidity-api/#agreementid","title":"agreementId","text":"<pre><code>function agreementId(bytes32 _agreementId, address _creator) public pure returns (bytes32)\n</code></pre>"},{"location":"generated/solidity-api/#createagreement","title":"createAgreement","text":"<pre><code>function createAgreement(bytes32 _id, bytes32 _did, address[] _conditionTypes, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts) public\n</code></pre> <p>Create a new agreement.      The agreement will create conditions of conditionType with conditionId.      Only \"approved\" templates can access this function.</p> Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition"},{"location":"generated/solidity-api/#createagreementargs","title":"CreateAgreementArgs","text":"<pre><code>struct CreateAgreementArgs {\n  bytes32 _id;\n  bytes32 _did;\n  address[] _conditionTypes;\n  bytes32[] _conditionIds;\n  uint256[] _timeLocks;\n  uint256[] _timeOuts;\n  address _creator;\n  uint256 _idx;\n  address payable _rewardAddress;\n  address _tokenAddress;\n  uint256[] _amounts;\n  address[] _receivers;\n}\n</code></pre>"},{"location":"generated/solidity-api/#createagreementandpay","title":"createAgreementAndPay","text":"<pre><code>function createAgreementAndPay(struct AgreementStoreManager.CreateAgreementArgs args) public payable\n</code></pre>"},{"location":"generated/solidity-api/#createagreementandfulfill","title":"createAgreementAndFulfill","text":"<pre><code>function createAgreementAndFulfill(bytes32 _id, bytes32 _did, address[] _conditionTypes, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address[] _account, uint256[] _idx, bytes[] params) public payable\n</code></pre>"},{"location":"generated/solidity-api/#getagreementtemplate","title":"getAgreementTemplate","text":"<pre><code>function getAgreementTemplate(bytes32 _id) external view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#getdidregistryaddress","title":"getDIDRegistryAddress","text":"<pre><code>function getDIDRegistryAddress() public view virtual returns (address)\n</code></pre> <p>getDIDRegistryAddress utility function  used by other contracts or any EOA.</p> Name Type Description [0] address the DIDRegistry address"},{"location":"generated/solidity-api/#accesscondition","title":"AccessCondition","text":"<p>_Implementation of the Access Condition</p> <pre><code> Access Secret Store Condition is special condition\n where a client or Parity secret store can encrypt/decrypt documents \n based on the on-chain granted permissions. For a given DID \n document, and agreement ID, the owner/provider of the DID \n will fulfill the condition. Consequently secret store \n will check whether the permission is granted for the consumer\n in order to encrypt/decrypt the document._\n</code></pre>"},{"location":"generated/solidity-api/#condition_type","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#documentpermission","title":"DocumentPermission","text":"<pre><code>struct DocumentPermission {\n  bytes32 agreementIdDeprecated;\n  mapping(address &amp;#x3D;&amp;gt; bool) permission;\n}\n</code></pre>"},{"location":"generated/solidity-api/#documentpermissions","title":"documentPermissions","text":"<pre><code>mapping(bytes32 =&gt; struct AccessCondition.DocumentPermission) documentPermissions\n</code></pre>"},{"location":"generated/solidity-api/#agreementstoremanager_1","title":"agreementStoreManager","text":"<pre><code>contract AgreementStoreManager agreementStoreManager\n</code></pre>"},{"location":"generated/solidity-api/#didregistry_1","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#fulfilled","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _documentId, address _grantee, bytes32 _conditionId)\n</code></pre>"},{"location":"generated/solidity-api/#onlydidownerorprovider","title":"onlyDIDOwnerOrProvider","text":"<pre><code>modifier onlyDIDOwnerOrProvider(bytes32 _documentId)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_4","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _agreementStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address"},{"location":"generated/solidity-api/#reinitialize","title":"reinitialize","text":"<pre><code>function reinitialize() external\n</code></pre> <p>Should be called when the contract has been upgraded.</p>"},{"location":"generated/solidity-api/#hashvalues","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _documentId, address _grantee) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _documentId, address _grantee) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill access secret store condition</p> <p>only DID owner or DID provider can call this       method. Fulfill method sets the permissions        for the granted consumer's address to true then       fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#grantpermission","title":"grantPermission","text":"<pre><code>function grantPermission(address _grantee, bytes32 _documentId) public\n</code></pre> <p>grantPermission is called only by DID owner or provider</p> Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys"},{"location":"generated/solidity-api/#renouncepermission","title":"renouncePermission","text":"<pre><code>function renouncePermission(address _grantee, bytes32 _documentId) public\n</code></pre> <p>renouncePermission is called only by DID owner or provider</p> Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys"},{"location":"generated/solidity-api/#checkpermissions","title":"checkPermissions","text":"<pre><code>function checkPermissions(address _grantee, bytes32 _documentId) external view returns (bool permissionGranted)\n</code></pre> <p>checkPermissions is called by Parity secret store</p> Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys Name Type Description permissionGranted bool true if the access was granted"},{"location":"generated/solidity-api/#idisputemanager","title":"IDisputeManager","text":""},{"location":"generated/solidity-api/#verifyproof","title":"verifyProof","text":"<pre><code>function verifyProof(bytes proof, uint256[] pubSignals) external view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#accessproofcondition","title":"AccessProofCondition","text":"<p>Implementation of the Access Condition with transfer proof. The idea is that the hash of the decryption key is known before hand, and the key matching this hash is passed from data provider to the buyer using this smart contract. Using ZK proof the key is kept hidden from outsiders. For the protocol to work, both the provider and buyer need to have public keys in the babyjub curve. To initiate the deal, buyer will pass the key hash and the public keys of participants. The provider needs to pass the cipher text encrypted using MIMC (symmetric encryption). The secret key for MIMC is computed using ECDH (requires one public key and one secret key for the curve). The hash function that is used is Poseidon.</p>"},{"location":"generated/solidity-api/#condition_type_1","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#agreementstoremanager_2","title":"agreementStoreManager","text":"<pre><code>contract AgreementStoreManager agreementStoreManager\n</code></pre>"},{"location":"generated/solidity-api/#disputemanager","title":"disputeManager","text":"<pre><code>contract IDisputeManager disputeManager\n</code></pre>"},{"location":"generated/solidity-api/#fulfilled_1","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, uint256 _origHash, uint256[2] _buyer, uint256[2] _provider, uint256[2] _cipher, bytes _proof, bytes32 _conditionId)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_5","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _agreementStoreManagerAddress, address _disputeManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address _disputeManagerAddress address dispute manager address"},{"location":"generated/solidity-api/#changedisputemanager","title":"changeDisputeManager","text":"<pre><code>function changeDisputeManager(address _disputeManagerAddress) external\n</code></pre>"},{"location":"generated/solidity-api/#hashvalues_1","title":"hashValues","text":"<pre><code>function hashValues(uint256 _origHash, uint256[2] _buyer, uint256[2] _provider) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _origHash uint256 is the hash of the key _buyer uint256[2] buyer public key _provider uint256[2] provider public key Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_1","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, uint256 _origHash, uint256[2] _buyer, uint256[2] _provider, uint256[2] _cipher, bytes _proof) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill key transfer</p> <p>The key with hash _origHash is transferred to the _buyer from _provider.</p> Name Type Description _agreementId bytes32 associated agreement _origHash uint256 is the hash of data to access _buyer uint256[2] buyer public key _provider uint256[2] provider public key _cipher uint256[2] encrypted version of the key _proof bytes SNARK proof that the cipher text can be decrypted by buyer to give the key with hash _origHash Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#computeexecutioncondition","title":"ComputeExecutionCondition","text":"<p>Implementation of the Compute Execution Condition      This condition is meant to be a signal in which triggers      the execution of a compute service. The compute service is fully described      in the associated DID document. The provider of the compute service will      send this signal to its workers by fulfilling the condition where      they are listening to the fulfilled event.</p>"},{"location":"generated/solidity-api/#condition_type_2","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#computeexecutionstatus","title":"computeExecutionStatus","text":"<pre><code>mapping(bytes32 =&gt; mapping(address =&gt; bool)) computeExecutionStatus\n</code></pre>"},{"location":"generated/solidity-api/#agreementstoremanager_3","title":"agreementStoreManager","text":"<pre><code>contract AgreementStoreManager agreementStoreManager\n</code></pre>"},{"location":"generated/solidity-api/#fulfilled_2","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, address _computeConsumer, bytes32 _conditionId)\n</code></pre>"},{"location":"generated/solidity-api/#onlydidownerorprovider_1","title":"onlyDIDOwnerOrProvider","text":"<pre><code>modifier onlyDIDOwnerOrProvider(bytes32 _did)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_6","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _agreementStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address"},{"location":"generated/solidity-api/#hashvalues_2","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _computeConsumer) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_2","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _computeConsumer) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill compute execution condition</p> <p>only the compute provider can fulfill this condition. By fulfilling this  condition the compute provider will trigger the execution of  the offered job/compute. The compute service is described in a DID document.</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#wascomputetriggered","title":"wasComputeTriggered","text":"<pre><code>function wasComputeTriggered(bytes32 _did, address _computeConsumer) public view returns (bool)\n</code></pre> <p>wasComputeTriggered checks whether the compute is triggered or not.</p> Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the compute consumer's address Name Type Description [0] bool true if the compute is triggered"},{"location":"generated/solidity-api/#condition","title":"Condition","text":"<p>_Implementation of the Condition</p> <pre><code> Each condition has a validation function that returns either FULFILLED, \n ABORTED or UNFULFILLED. When a condition is successfully solved, we call \n it FULFILLED. If a condition cannot be FULFILLED anymore due to a timeout \n or other types of counter-proofs, the condition is ABORTED. UNFULFILLED \n values imply that a condition has not been provably FULFILLED or ABORTED. \n All initialized conditions start out as UNFULFILLED._\n</code></pre>"},{"location":"generated/solidity-api/#conditionstoremanager_1","title":"conditionStoreManager","text":"<pre><code>contract ConditionStoreManager conditionStoreManager\n</code></pre>"},{"location":"generated/solidity-api/#generateid","title":"generateId","text":"<pre><code>function generateId(bytes32 _agreementId, bytes32 _valueHash) public view returns (bytes32)\n</code></pre> <p>generateId condition Id from the following        parameters</p> Name Type Description _agreementId bytes32 SEA agreement ID _valueHash bytes32 hash of all the condition input values"},{"location":"generated/solidity-api/#fulfill_3","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _id, enum ConditionStoreLibrary.ConditionState _newState) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill set the condition state to Fulfill | Abort</p> Name Type Description _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState new condition state (Fulfill/Abort) Name Type Description [0] enum ConditionStoreLibrary.ConditionState the updated condition state"},{"location":"generated/solidity-api/#abortbytimeout","title":"abortByTimeOut","text":"<pre><code>function abortByTimeOut(bytes32 _id) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>abortByTimeOut set condition state to Aborted          if the condition is timed out</p> Name Type Description _id bytes32 condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState the updated condition state"},{"location":"generated/solidity-api/#conditionstorelibrary","title":"ConditionStoreLibrary","text":"<p>_Implementation of the Condition Store Library.</p> <pre><code> Condition is a key component in the service execution agreement. \n This library holds the logic for creating and updating condition \n Any Condition has only four state transitions starts with Uninitialized,\n Unfulfilled, Fulfilled, and Aborted. Condition state transition goes only \n forward from Unintialized -&gt; Unfulfilled -&gt; {Fulfilled || Aborted}_\n</code></pre>"},{"location":"generated/solidity-api/#conditionstate","title":"ConditionState","text":"<pre><code>enum ConditionState {\n  Uninitialized,\n  Unfulfilled,\n  Fulfilled,\n  Aborted\n}\n</code></pre>"},{"location":"generated/solidity-api/#condition_1","title":"Condition","text":"<pre><code>struct Condition {\n  address typeRef;\n  enum ConditionStoreLibrary.ConditionState state;\n  address createdBy;\n  address lastUpdatedBy;\n  uint256 blockNumberUpdated;\n}\n</code></pre>"},{"location":"generated/solidity-api/#conditionlist","title":"ConditionList","text":"<pre><code>struct ConditionList {\n  mapping(bytes32 &amp;#x3D;&amp;gt; struct ConditionStoreLibrary.Condition) conditions;\n  mapping(bytes32 &amp;#x3D;&amp;gt; mapping(bytes32 &amp;#x3D;&amp;gt; bytes32)) map;\n  bytes32[] conditionIds;\n}\n</code></pre>"},{"location":"generated/solidity-api/#create_1","title":"create","text":"<pre><code>function create(struct ConditionStoreLibrary.ConditionList _self, bytes32 _id, address _typeRef) internal\n</code></pre> <p>create new condition</p> <p>check whether the condition exists, assigns        condition type, condition state, last updated by,        and update at (which is the current block number)</p> Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 valid condition identifier _typeRef address condition contract address"},{"location":"generated/solidity-api/#updatestate","title":"updateState","text":"<pre><code>function updateState(struct ConditionStoreLibrary.ConditionList _self, bytes32 _id, enum ConditionStoreLibrary.ConditionState _newState) internal\n</code></pre> <p>updateState update the condition state</p> <p>check whether the condition state transition is right,       assign the new state, update last updated by and       updated at.</p> Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState the new state of the condition"},{"location":"generated/solidity-api/#updatekeyvalue","title":"updateKeyValue","text":"<pre><code>function updateKeyValue(struct ConditionStoreLibrary.ConditionList _self, bytes32 _id, bytes32 _key, bytes32 _value) internal\n</code></pre>"},{"location":"generated/solidity-api/#conditionstoremanager_2","title":"ConditionStoreManager","text":"<p>_Implementation of the Condition Store Manager.</p> <pre><code> Condition store manager is responsible for enforcing the \n the business logic behind creating/updating the condition state\n based on the assigned role to each party. Only specific type of\n contracts are allowed to call this contract, therefore there are \n two types of roles, create role that in which is able to create conditions.\n The second role is the update role, which is can update the condition state.\n Also, it support delegating the roles to other contract(s)/account(s)._\n</code></pre>"},{"location":"generated/solidity-api/#proxy_role_1","title":"PROXY_ROLE","text":"<pre><code>bytes32 PROXY_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#roletype","title":"RoleType","text":"<pre><code>enum RoleType {\n  Create,\n  Update\n}\n</code></pre>"},{"location":"generated/solidity-api/#createrole","title":"createRole","text":"<pre><code>address createRole\n</code></pre>"},{"location":"generated/solidity-api/#conditionlist_1","title":"conditionList","text":"<pre><code>struct ConditionStoreLibrary.ConditionList conditionList\n</code></pre>"},{"location":"generated/solidity-api/#epochlist","title":"epochList","text":"<pre><code>struct EpochLibrary.EpochList epochList\n</code></pre>"},{"location":"generated/solidity-api/#nvmconfigaddress","title":"nvmConfigAddress","text":"<pre><code>address nvmConfigAddress\n</code></pre>"},{"location":"generated/solidity-api/#conditioncreated","title":"ConditionCreated","text":"<pre><code>event ConditionCreated(bytes32 _id, address _typeRef, address _who)\n</code></pre>"},{"location":"generated/solidity-api/#conditionupdated","title":"ConditionUpdated","text":"<pre><code>event ConditionUpdated(bytes32 _id, address _typeRef, enum ConditionStoreLibrary.ConditionState _state, address _who)\n</code></pre>"},{"location":"generated/solidity-api/#onlycreaterole","title":"onlyCreateRole","text":"<pre><code>modifier onlyCreateRole()\n</code></pre>"},{"location":"generated/solidity-api/#onlyupdaterole","title":"onlyUpdateRole","text":"<pre><code>modifier onlyUpdateRole(bytes32 _id)\n</code></pre>"},{"location":"generated/solidity-api/#onlyvalidtype","title":"onlyValidType","text":"<pre><code>modifier onlyValidType(address typeRef)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_7","title":"initialize","text":"<pre><code>function initialize(address _creator, address _owner, address _nvmConfigAddress) public\n</code></pre> <p>initialize ConditionStoreManager Initializer      Initialize Ownable. Only on contract creation,</p> Name Type Description _creator address refers to the creator of the contract _owner address refers to the owner of the contract _nvmConfigAddress address refers to the contract address of <code>NeverminedConfig</code>"},{"location":"generated/solidity-api/#getcreaterole","title":"getCreateRole","text":"<pre><code>function getCreateRole() external view returns (address)\n</code></pre> <p>getCreateRole get the address of contract      which has the create role</p> Name Type Description [0] address create condition role address"},{"location":"generated/solidity-api/#getnvmconfigaddress","title":"getNvmConfigAddress","text":"<pre><code>function getNvmConfigAddress() external view returns (address)\n</code></pre> <p>getNvmConfigAddress get the address of the NeverminedConfig contract</p> Name Type Description [0] address NeverminedConfig contract address"},{"location":"generated/solidity-api/#setnvmconfigaddress","title":"setNvmConfigAddress","text":"<pre><code>function setNvmConfigAddress(address _addr) external\n</code></pre>"},{"location":"generated/solidity-api/#delegatecreaterole","title":"delegateCreateRole","text":"<pre><code>function delegateCreateRole(address delegatee) external\n</code></pre> <p>delegateCreateRole only owner can delegate the       create condition role to a different address</p> Name Type Description delegatee address delegatee address"},{"location":"generated/solidity-api/#delegateupdaterole","title":"delegateUpdateRole","text":"<pre><code>function delegateUpdateRole(bytes32 _id, address delegatee) external\n</code></pre> <p>delegateUpdateRole only owner can delegate       the update role to a different address for       specific condition Id which has the create role</p> Name Type Description _id bytes32 delegatee address delegatee address"},{"location":"generated/solidity-api/#grantproxyrole_1","title":"grantProxyRole","text":"<pre><code>function grantProxyRole(address _address) public\n</code></pre>"},{"location":"generated/solidity-api/#revokeproxyrole_1","title":"revokeProxyRole","text":"<pre><code>function revokeProxyRole(address _address) public\n</code></pre>"},{"location":"generated/solidity-api/#createcondition","title":"createCondition","text":"<pre><code>function createCondition(bytes32 _id, address _typeRef) external\n</code></pre> <p>createCondition only called by create role address       the condition should use a valid condition contract       address, valid time lock and timeout. Moreover, it       enforce the condition state transition from       Uninitialized to Unfulfilled.</p> Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address"},{"location":"generated/solidity-api/#createcondition2","title":"createCondition2","text":"<pre><code>function createCondition2(bytes32 _id, address _typeRef) external\n</code></pre>"},{"location":"generated/solidity-api/#createcondition_1","title":"createCondition","text":"<pre><code>function createCondition(bytes32 _id, address _typeRef, uint256 _timeLock, uint256 _timeOut) public\n</code></pre> <p>createCondition only called by create role address       the condition should use a valid condition contract       address, valid time lock and timeout. Moreover, it       enforce the condition state transition from       Uninitialized to Unfulfilled.</p> Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _timeLock uint256 start of the time window _timeOut uint256 end of the time window"},{"location":"generated/solidity-api/#updateconditionstate","title":"updateConditionState","text":"<pre><code>function updateConditionState(bytes32 _id, enum ConditionStoreLibrary.ConditionState _newState) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>updateConditionState only called by update role address.       It enforce the condition state transition to either       Fulfill or Aborted state</p> Name Type Description _id bytes32 unique condition identifier _newState enum ConditionStoreLibrary.ConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState the current condition state"},{"location":"generated/solidity-api/#updateconditionmapping","title":"updateConditionMapping","text":"<pre><code>function updateConditionMapping(bytes32 _id, bytes32 _key, bytes32 _value) external\n</code></pre>"},{"location":"generated/solidity-api/#updateconditionmappingproxy","title":"updateConditionMappingProxy","text":"<pre><code>function updateConditionMappingProxy(bytes32 _id, bytes32 _key, bytes32 _value) external\n</code></pre>"},{"location":"generated/solidity-api/#getcondition","title":"getCondition","text":"<pre><code>function getCondition(bytes32 _id) external view returns (address typeRef, enum ConditionStoreLibrary.ConditionState state, uint256 timeLock, uint256 timeOut, uint256 blockNumber)\n</code></pre> <p>getCondition</p> Name Type Description typeRef address the type reference state enum ConditionStoreLibrary.ConditionState condition state timeLock uint256 the time lock timeOut uint256 time out blockNumber uint256 block number"},{"location":"generated/solidity-api/#getconditionstate","title":"getConditionState","text":"<pre><code>function getConditionState(bytes32 _id) external view virtual returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>getConditionState</p> Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#getconditiontyperef","title":"getConditionTypeRef","text":"<pre><code>function getConditionTypeRef(bytes32 _id) external view virtual returns (address)\n</code></pre> <p>getConditionTypeRef</p> Name Type Description [0] address condition typeRef"},{"location":"generated/solidity-api/#getmappingvalue","title":"getMappingValue","text":"<pre><code>function getMappingValue(bytes32 _id, bytes32 _key) external view virtual returns (bytes32)\n</code></pre> <p>getConditionState</p> Name Type Description [0] bytes32 condition state"},{"location":"generated/solidity-api/#isconditiontimelocked","title":"isConditionTimeLocked","text":"<pre><code>function isConditionTimeLocked(bytes32 _id) public view returns (bool)\n</code></pre> <p>isConditionTimeLocked</p> Name Type Description [0] bool whether the condition is timedLock ended"},{"location":"generated/solidity-api/#isconditiontimedout","title":"isConditionTimedOut","text":"<pre><code>function isConditionTimedOut(bytes32 _id) public view returns (bool)\n</code></pre> <p>isConditionTimedOut</p> Name Type Description [0] bool whether the condition is timed out"},{"location":"generated/solidity-api/#hashlockcondition","title":"HashLockCondition","text":"<p>Implementation of the Hash Lock Condition</p>"},{"location":"generated/solidity-api/#condition_type_3","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#initialize_8","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"generated/solidity-api/#hashvalues_3","title":"hashValues","text":"<pre><code>function hashValues(uint256 _preimage) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _preimage uint256 refers uint value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#hashvalues_4","title":"hashValues","text":"<pre><code>function hashValues(string _preimage) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _preimage string refers string value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#hashvalues_5","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _preimage) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _preimage bytes32 refers bytes32 value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_4","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, uint256 _preimage) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the condition by calling check the        the hash and the pre-image uint value</p> Name Type Description _agreementId bytes32 SEA agreement identifier _preimage uint256 Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#fulfill_5","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, string _preimage) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the condition by calling check the        the hash and the pre-image string value</p> Name Type Description _agreementId bytes32 SEA agreement identifier _preimage string Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#fulfill_6","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _preimage) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the condition by calling check the        the hash and the pre-image bytes32 value</p> Name Type Description _agreementId bytes32 SEA agreement identifier _preimage bytes32 Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#_fulfill","title":"_fulfill","text":"<pre><code>function _fulfill(bytes32 _generatedId) private returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>_fulfill calls super fulfil method</p> Name Type Description _generatedId bytes32 SEA agreement identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#icondition","title":"ICondition","text":""},{"location":"generated/solidity-api/#fulfillproxy","title":"fulfillProxy","text":"<pre><code>function fulfillProxy(address _account, bytes32 _agreementId, bytes params) external payable\n</code></pre>"},{"location":"generated/solidity-api/#ilockpayment","title":"ILockPayment","text":""},{"location":"generated/solidity-api/#fulfilled_3","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, bytes32 _conditionId, address _rewardAddress, address _tokenAddress, address[] _receivers, uint256[] _amounts)\n</code></pre>"},{"location":"generated/solidity-api/#hashvalues_6","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) external pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment.         If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_7","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address payable _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) external payable returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill requires valid token transfer in order            to lock the amount of tokens based on the SEA</p> Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#lockpaymentcondition","title":"LockPaymentCondition","text":"<p>Implementation of the Lock Payment Condition This condition allows to lock payment for multiple receivers taking into account the royalties to be paid to the original creators in a secondary market.</p>"},{"location":"generated/solidity-api/#didregistry_2","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#nvmconfig","title":"nvmConfig","text":"<pre><code>contract INVMConfig nvmConfig\n</code></pre>"},{"location":"generated/solidity-api/#condition_type_4","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#key_asset_receiver","title":"KEY_ASSET_RECEIVER","text":"<pre><code>bytes32 KEY_ASSET_RECEIVER\n</code></pre>"},{"location":"generated/solidity-api/#proxy_role_2","title":"PROXY_ROLE","text":"<pre><code>bytes32 PROXY_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#allowed_external_contract_role","title":"ALLOWED_EXTERNAL_CONTRACT_ROLE","text":"<pre><code>bytes32 ALLOWED_EXTERNAL_CONTRACT_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#grantproxyrole_2","title":"grantProxyRole","text":"<pre><code>function grantProxyRole(address _address) public\n</code></pre>"},{"location":"generated/solidity-api/#revokeproxyrole_2","title":"revokeProxyRole","text":"<pre><code>function revokeProxyRole(address _address) public\n</code></pre>"},{"location":"generated/solidity-api/#grantexternalcontractrole","title":"grantExternalContractRole","text":"<pre><code>function grantExternalContractRole(address _address) public\n</code></pre>"},{"location":"generated/solidity-api/#revokeexternalcontractrole","title":"revokeExternalContractRole","text":"<pre><code>function revokeExternalContractRole(address _address) public\n</code></pre>"},{"location":"generated/solidity-api/#initialize_9","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _didRegistryAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address"},{"location":"generated/solidity-api/#reinitialize_1","title":"reinitialize","text":"<pre><code>function reinitialize() external\n</code></pre> <p>Should be called when the contract has been upgraded.</p>"},{"location":"generated/solidity-api/#hashvalues_7","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment.         If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_8","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address payable _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) external payable returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill requires valid token transfer in order            to lock the amount of tokens based on the SEA</p> Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#fulfillexternal","title":"fulfillExternal","text":"<pre><code>function fulfillExternal(bytes32 _agreementId, bytes32 _did, address payable _rewardAddress, address _externalContract, bytes32 _remoteId, uint256[] _amounts, address[] _receivers) external payable returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill lock condition using the funds locked in an external contract           (auction, bonding curve, lottery, etc)</p> Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _externalContract address the address of the contract with the lock funds are locked _remoteId bytes32 the id used to identify into the external contract _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#encodeparams","title":"encodeParams","text":"<pre><code>function encodeParams(bytes32 _did, address payable _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) external pure returns (bytes)\n</code></pre>"},{"location":"generated/solidity-api/#fulfillinternal","title":"fulfillInternal","text":"<pre><code>function fulfillInternal(address _account, bytes32 _agreementId, bytes32 _did, address payable _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"generated/solidity-api/#fulfillproxy_1","title":"fulfillProxy","text":"<pre><code>function fulfillProxy(address _account, bytes32 _agreementId, bytes params) external payable\n</code></pre>"},{"location":"generated/solidity-api/#_transfererc20proxy","title":"_transferERC20Proxy","text":"<pre><code>function _transferERC20Proxy(address _senderAddress, address _rewardAddress, address _tokenAddress, uint256 _amount) internal\n</code></pre> <p>_transferERC20Proxy transfer ERC20 tokens</p> <p>Will throw if transfer fails</p> Name Type Description _senderAddress address the address to send the tokens from _rewardAddress address the address to receive the tokens _tokenAddress address the ERC20 contract address to use during the payment _amount uint256 token amount to be locked/released"},{"location":"generated/solidity-api/#_transfereth","title":"_transferETH","text":"<pre><code>function _transferETH(address payable _rewardAddress, uint256 _amount) internal\n</code></pre> <p>_transferETH transfer ETH</p> Name Type Description _rewardAddress address payable the address to receive the ETH _amount uint256 ETH amount to be locked/released"},{"location":"generated/solidity-api/#allowedexternalcontract","title":"allowedExternalContract","text":"<pre><code>modifier allowedExternalContract(address _externalContractAddress)\n</code></pre>"},{"location":"generated/solidity-api/#aremarketplacefeesincluded","title":"areMarketplaceFeesIncluded","text":"<pre><code>function areMarketplaceFeesIncluded(uint256[] _amounts, address[] _receivers) internal view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#distributenftcollateralcondition","title":"DistributeNFTCollateralCondition","text":"<p>Implementation of a condition allowing to transfer a NFT      to an account or another depending on the final state of a lock condition</p>"},{"location":"generated/solidity-api/#condition_type_5","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#aavecreditvault","title":"aaveCreditVault","text":"<pre><code>contract AaveCreditVault aaveCreditVault\n</code></pre>"},{"location":"generated/solidity-api/#_lockconditionaddress","title":"_lockConditionAddress","text":"<pre><code>address _lockConditionAddress\n</code></pre>"},{"location":"generated/solidity-api/#fulfilled_4","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, address _receiver, bytes32 _conditionId, address _contract)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_10","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _lockNFTConditionAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _lockNFTConditionAddress address Lock NFT Condition address"},{"location":"generated/solidity-api/#hashvalues_8","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _vaultAddress, address _nftContractAddress) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _vaultAddress address The contract address of the vault _nftContractAddress address NFT contract to use Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_9","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _vaultAddress, address _nftContractAddress) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _vaultAddress address The contract address of the vault _nftContractAddress address NFT contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#inftaccess","title":"INFTAccess","text":""},{"location":"generated/solidity-api/#fulfilled_5","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _documentId, address _grantee, bytes32 _conditionId)\n</code></pre>"},{"location":"generated/solidity-api/#hashvalues_9","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _documentId, address _grantee, address _contractAddress) external pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_10","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _documentId, address _grantee, address _contractAddress) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill NFT Access conditions</p> <p>only DID owner or DID provider can call this       method. Fulfill method sets the permissions        for the granted consumer's address to true then       fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#inftholder","title":"INFTHolder","text":""},{"location":"generated/solidity-api/#fulfilled_6","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, address _address, bytes32 _conditionId, uint256 _amount)\n</code></pre>"},{"location":"generated/solidity-api/#hashvalues_10","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _holderAddress, uint256 _amount, address _contractAddress) external pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_11","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _holderAddress, uint256 _amount, address _contractAddress) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill requires a validation that holder has enough       NFTs for a specific DID</p> Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#inftlock","title":"INFTLock","text":""},{"location":"generated/solidity-api/#fulfilled_7","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, address _lockAddress, bytes32 _conditionId, uint256 _amount, address _receiver, address _nftContractAddress)\n</code></pre>"},{"location":"generated/solidity-api/#hashvalues_11","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _lockAddress, uint256 _amount, address _nftContractAddress) external pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the NFTs locked _nftContractAddress address Is the address of the NFT (ERC-721, ERC-1155) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#hashvaluesmarked","title":"hashValuesMarked","text":"<pre><code>function hashValuesMarked(bytes32 _did, address _lockAddress, uint256 _amount, address _receiver, address _nftContractAddress) external pure returns (bytes32)\n</code></pre>"},{"location":"generated/solidity-api/#fulfill_12","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount, address _nftContractAddress) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#fulfillmarked","title":"fulfillMarked","text":"<pre><code>function fulfillMarked(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount, address _receiver, address _nftContractAddress) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"generated/solidity-api/#itransfernft","title":"ITransferNFT","text":""},{"location":"generated/solidity-api/#fulfilled_8","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, address _receiver, uint256 _amount, bytes32 _conditionId, address _contract)\n</code></pre>"},{"location":"generated/solidity-api/#hashvalues_12","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockCondition, address _contract, bool _transfer) external pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _contract address _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_13","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _contract, bool _transfer) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#getnftdefaultaddress","title":"getNFTDefaultAddress","text":"<pre><code>function getNFTDefaultAddress() external view returns (address)\n</code></pre> <p>returns if the default NFT contract address</p> <p>The default NFT contract address was given to the Transfer Condition during the contract initialization</p> Name Type Description [0] address the NFT contract address used by default in the transfer condition"},{"location":"generated/solidity-api/#nft721holdercondition","title":"NFT721HolderCondition","text":"<p>Implementation of the Nft Holder Condition</p>"},{"location":"generated/solidity-api/#condition_type_6","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#initialize_11","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"generated/solidity-api/#hashvalues_13","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _holderAddress, uint256 _amount, address _contractAddress) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_14","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _holderAddress, uint256 _amount, address _contractAddress) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill requires a validation that holder has enough       NFTs for a specific DID</p> Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#nft721lockcondition","title":"NFT721LockCondition","text":"<p>Implementation of the NFT Lock Condition for ERC-721 based NFTs</p>"},{"location":"generated/solidity-api/#condition_type_7","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#initialize_12","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the  contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"generated/solidity-api/#hashvalues_14","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _lockAddress, uint256 _amount, address _nftContractAddress) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#hashvaluesmarked_1","title":"hashValuesMarked","text":"<pre><code>function hashValuesMarked(bytes32 _did, address _lockAddress, uint256 _amount, address _receiver, address _nftContractAddress) public pure returns (bytes32)\n</code></pre>"},{"location":"generated/solidity-api/#fulfillmarked_1","title":"fulfillMarked","text":"<pre><code>function fulfillMarked(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount, address _receiver, address _nftContractAddress) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method lock a NFT into the <code>_lockAddress</code>.</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens (1) _receiver address _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#fulfill_15","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount, address _nftContractAddress) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#onerc721received","title":"onERC721Received","text":"<pre><code>function onERC721Received(address, address, uint256, bytes) public virtual returns (bytes4)\n</code></pre> <p>Always returns <code>IERC721Receiver.onERC721Received.selector</code>.</p>"},{"location":"generated/solidity-api/#nftaccesscondition","title":"NFTAccessCondition","text":"<p>_Implementation of the Access Condition specific for NFTs</p> <pre><code> NFT Access Condition is special condition used to give access \n to a specific NFT related to a DID._\n</code></pre>"},{"location":"generated/solidity-api/#condition_type_8","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#documentpermission_1","title":"DocumentPermission","text":"<pre><code>struct DocumentPermission {\n  bytes32 agreementIdDeprecated;\n  mapping(address &amp;#x3D;&amp;gt; bool) permission;\n}\n</code></pre>"},{"location":"generated/solidity-api/#nftpermissions","title":"nftPermissions","text":"<pre><code>mapping(bytes32 =&gt; struct NFTAccessCondition.DocumentPermission) nftPermissions\n</code></pre>"},{"location":"generated/solidity-api/#didregistry_3","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#onlydidownerorprovider_2","title":"onlyDIDOwnerOrProvider","text":"<pre><code>modifier onlyDIDOwnerOrProvider(bytes32 _documentId)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_13","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _didRegistryAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID registry address"},{"location":"generated/solidity-api/#hashvalues_15","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _documentId, address _grantee) public view returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#hashvalues_16","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _documentId, address _grantee, address _contractAddress) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_16","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _documentId, address _grantee) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill NFT Access condition</p> <p>only DID owner or DID provider can call this       method. Fulfill method sets the permissions        for the granted consumer's address to true then       fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#fulfill_17","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _documentId, address _grantee, address _contractAddress) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill NFT Access condition</p> <p>only DID owner or DID provider can call this       method. Fulfill method sets the permissions        for the granted consumer's address to true then       fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address is the contract address of the NFT implementation (ERC-1155 or ERC-721) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#grantpermission_1","title":"grantPermission","text":"<pre><code>function grantPermission(address _grantee, bytes32 _documentId) public\n</code></pre> <p>grantPermission is called only by DID owner or provider</p> Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys"},{"location":"generated/solidity-api/#checkpermissions_1","title":"checkPermissions","text":"<pre><code>function checkPermissions(address _grantee, bytes32 _documentId) external view returns (bool permissionGranted)\n</code></pre> <p>checkPermissions is called to validate the permissions of user related to the NFT attached to an asset</p> Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID Name Type Description permissionGranted bool true if the access was granted"},{"location":"generated/solidity-api/#nftholdercondition","title":"NFTHolderCondition","text":"<p>Implementation of the Nft Holder Condition</p>"},{"location":"generated/solidity-api/#erc1155","title":"erc1155","text":"<pre><code>contract ERC1155BurnableUpgradeable erc1155\n</code></pre>"},{"location":"generated/solidity-api/#condition_type_9","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#initialize_14","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _ercAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _ercAddress address Nevermined ERC-1155 address"},{"location":"generated/solidity-api/#hashvalues_17","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _holderAddress, uint256 _amount) public view returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#hashvalues_18","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _holderAddress, uint256 _amount, address _contractAddress) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_18","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _holderAddress, uint256 _amount) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill requires a validation that holder has enough       NFTs for a specific DID</p> Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#fulfill_19","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _holderAddress, uint256 _amount, address _contractAddress) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill requires a validation that holder has enough       NFTs for a specific DID</p> Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#nftlockcondition","title":"NFTLockCondition","text":"<p>Implementation of the NFT Lock Condition</p>"},{"location":"generated/solidity-api/#erc1155_1","title":"erc1155","text":"<pre><code>contract IERC1155Upgradeable erc1155\n</code></pre>"},{"location":"generated/solidity-api/#condition_type_10","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#erc1155_accepted","title":"ERC1155_ACCEPTED","text":"<pre><code>bytes4 ERC1155_ACCEPTED\n</code></pre>"},{"location":"generated/solidity-api/#erc1155_batch_accepted","title":"ERC1155_BATCH_ACCEPTED","text":"<pre><code>bytes4 ERC1155_BATCH_ACCEPTED\n</code></pre>"},{"location":"generated/solidity-api/#initialize_15","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _ercAddress) external\n</code></pre> <p>initialize init the  contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _ercAddress address Nevermined ERC-1155 address"},{"location":"generated/solidity-api/#hashvalues_19","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _lockAddress, uint256 _amount) public view returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#hashvalues_20","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _lockAddress, uint256 _amount, address _nftContractAddress) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-1155) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#hashvaluesmarked_2","title":"hashValuesMarked","text":"<pre><code>function hashValuesMarked(bytes32 _did, address _lockAddress, uint256 _amount, address _receiver, address _nftContractAddress) public pure returns (bytes32)\n</code></pre>"},{"location":"generated/solidity-api/#fulfill_20","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#fulfill_21","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount, address _nft) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"generated/solidity-api/#fulfillmarked_2","title":"fulfillMarked","text":"<pre><code>function fulfillMarked(bytes32 _agreementId, bytes32 _did, address _lockAddress, uint256 _amount, address _receiver, address _nftContractAddress) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _receiver address _nftContractAddress address Is the address of the NFT (ERC-1155) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#onerc1155received","title":"onERC1155Received","text":"<pre><code>function onERC1155Received(address, address, uint256, uint256, bytes) external pure returns (bytes4)\n</code></pre>"},{"location":"generated/solidity-api/#onerc1155batchreceived","title":"onERC1155BatchReceived","text":"<pre><code>function onERC1155BatchReceived(address, address, uint256[], uint256[], bytes) external pure returns (bytes4)\n</code></pre>"},{"location":"generated/solidity-api/#supportsinterface","title":"supportsInterface","text":"<pre><code>function supportsInterface(bytes4 interfaceId) external pure returns (bool)\n</code></pre> <p>_Returns true if this contract implements the interface defined by <code>interfaceId</code>. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created.</p> <p>This function call must use less than 30 000 gas._</p>"},{"location":"generated/solidity-api/#transfernft721condition","title":"TransferNFT721Condition","text":"<p>Implementation of condition allowing to transfer an NFT      between the original owner and a receiver</p>"},{"location":"generated/solidity-api/#condition_type_11","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#market_role","title":"MARKET_ROLE","text":"<pre><code>bytes32 MARKET_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#erc721","title":"erc721","text":"<pre><code>contract NFT721Upgradeable erc721\n</code></pre>"},{"location":"generated/solidity-api/#_lockconditionaddress_1","title":"_lockConditionAddress","text":"<pre><code>address _lockConditionAddress\n</code></pre>"},{"location":"generated/solidity-api/#proxy_role_3","title":"PROXY_ROLE","text":"<pre><code>bytes32 PROXY_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#didregistry_4","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#grantproxyrole_3","title":"grantProxyRole","text":"<pre><code>function grantProxyRole(address _address) public\n</code></pre>"},{"location":"generated/solidity-api/#revokeproxyrole_3","title":"revokeProxyRole","text":"<pre><code>function revokeProxyRole(address _address) public\n</code></pre>"},{"location":"generated/solidity-api/#initialize_16","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _didRegistryAddress, address _ercAddress, address _lockNFTConditionAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _ercAddress address Nevermined ERC-721 address _lockNFTConditionAddress address"},{"location":"generated/solidity-api/#getnftdefaultaddress_1","title":"getNFTDefaultAddress","text":"<pre><code>function getNFTDefaultAddress() external view returns (address)\n</code></pre> <p>returns if the default NFT contract address</p> <p>The default NFT contract address was given to the Transfer Condition during the contract initialization</p> Name Type Description [0] address the NFT contract address used by default in the transfer condition"},{"location":"generated/solidity-api/#hashvalues_21","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockCondition, address _contract, bool _transfer) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _contract address NFT contract to use _transfer bool Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#encodeparams_1","title":"encodeParams","text":"<pre><code>function encodeParams(bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _nftContractAddress, bool _transfer) external pure returns (bytes)\n</code></pre> <p>Encodes/serialize all the parameters received</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the NFT contract to use _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] bytes the encoded parameters"},{"location":"generated/solidity-api/#fulfill_22","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _contract, bool _transfer) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#fulfillproxy_2","title":"fulfillProxy","text":"<pre><code>function fulfillProxy(address _account, bytes32 _agreementId, bytes _params) external payable\n</code></pre> <p>fulfill the transfer NFT condition by a proxy</p> <p>Fulfill method transfer a certain amount of NFTs</p> Name Type Description _account address NFT Holder _agreementId bytes32 agreement identifier _params bytes encoded parameters"},{"location":"generated/solidity-api/#fulfillinternal_1","title":"fulfillInternal","text":"<pre><code>function fulfillInternal(address _account, bytes32 _agreementId, bytes32 _did, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _contract, bool _transfer, uint256 _expirationBlock) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"generated/solidity-api/#fulfillfordelegate","title":"fulfillForDelegate","text":"<pre><code>function fulfillForDelegate(bytes32 _agreementId, bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, bool _transfer) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address in the DIDRegistry contract.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#fulfillfordelegate_1","title":"fulfillForDelegate","text":"<pre><code>function fulfillForDelegate(bytes32 _agreementId, bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, bool _transfer, address _nftContractAddress, uint256 _expirationBlock) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address in the DIDRegistry contract.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT _nftContractAddress address the address of the ERC-721 NFT contract _expirationBlock uint256 in which block the nft expires, if 0 it doesn't expire Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#transfernftcondition","title":"TransferNFTCondition","text":"<p>Implementation of condition allowing to transfer an NFT      between the original owner and a receiver</p>"},{"location":"generated/solidity-api/#condition_type_12","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#market_role_1","title":"MARKET_ROLE","text":"<pre><code>bytes32 MARKET_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#erc1155_2","title":"erc1155","text":"<pre><code>contract NFTUpgradeable erc1155\n</code></pre>"},{"location":"generated/solidity-api/#didregistry_5","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#proxy_role_4","title":"PROXY_ROLE","text":"<pre><code>bytes32 PROXY_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#grantproxyrole_4","title":"grantProxyRole","text":"<pre><code>function grantProxyRole(address _address) public\n</code></pre>"},{"location":"generated/solidity-api/#revokeproxyrole_4","title":"revokeProxyRole","text":"<pre><code>function revokeProxyRole(address _address) public\n</code></pre>"},{"location":"generated/solidity-api/#initialize_17","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _didRegistryAddress, address _ercAddress, address _nftContractAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _ercAddress address Nevermined ERC-1155 address _nftContractAddress address Market address"},{"location":"generated/solidity-api/#grantmarketrole","title":"grantMarketRole","text":"<pre><code>function grantMarketRole(address _nftContractAddress) public\n</code></pre>"},{"location":"generated/solidity-api/#revokemarketrole","title":"revokeMarketRole","text":"<pre><code>function revokeMarketRole(address _nftContractAddress) public\n</code></pre>"},{"location":"generated/solidity-api/#getnftdefaultaddress_2","title":"getNFTDefaultAddress","text":"<pre><code>function getNFTDefaultAddress() external view returns (address)\n</code></pre> <p>returns if the default NFT contract address</p> <p>The default NFT contract address was given to the Transfer Condition during the contract initialization</p> Name Type Description [0] address the NFT contract address used by default in the transfer condition"},{"location":"generated/solidity-api/#hashvalues_22","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockCondition) public view returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#hashvalues_23","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockCondition, address _nftContractAddress, bool _transfer) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _nftContractAddress address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_23","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"generated/solidity-api/#encodeparams_2","title":"encodeParams","text":"<pre><code>function encodeParams(bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _nftContractAddress, bool _transfer) external pure returns (bytes)\n</code></pre> <p>Encodes/serialize all the parameters received</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the NFT contract to use _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] bytes the encoded parameters"},{"location":"generated/solidity-api/#fulfillproxy_3","title":"fulfillProxy","text":"<pre><code>function fulfillProxy(address _account, bytes32 _agreementId, bytes _params) external payable\n</code></pre> <p>fulfill the transfer NFT condition by a proxy</p> <p>Fulfill method transfer a certain amount of NFTs</p> Name Type Description _account address NFT Holder _agreementId bytes32 agreement identifier _params bytes encoded parameters"},{"location":"generated/solidity-api/#fulfill_24","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _nftContractAddress, bool _transfer) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#fulfillinternal_2","title":"fulfillInternal","text":"<pre><code>function fulfillInternal(address _account, bytes32 _agreementId, bytes32 _did, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _nftContractAddress, bool _transfer) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"generated/solidity-api/#fulfillfordelegate_2","title":"fulfillForDelegate","text":"<pre><code>function fulfillForDelegate(bytes32 _agreementId, bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, bool _transfer) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address in the DIDRegistry contract.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#fulfillfordelegate_3","title":"fulfillForDelegate","text":"<pre><code>function fulfillForDelegate(bytes32 _agreementId, bytes32 _did, address _nftHolder, address _nftReceiver, uint256 _nftAmount, bytes32 _lockPaymentCondition, address _nftContractAddress, bool _transfer) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer NFT condition</p> <p>Fulfill method transfer a certain amount of NFTs        to the _nftReceiver address in the DIDRegistry contract.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the address of the ERC-721 NFT contract _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#signcondition","title":"SignCondition","text":"<p>Implementation of the Sign Condition</p>"},{"location":"generated/solidity-api/#condition_type_13","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#initialize_18","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"generated/solidity-api/#hashvalues_24","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _message, address _publicKey) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _message bytes32 the message to be signed _publicKey address the public key of the signing address Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_25","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _message, address _publicKey, bytes _signature) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill validate the signed message and fulfill the condition</p> Name Type Description _agreementId bytes32 SEA agreement identifier _message bytes32 the message to be signed _publicKey address the public key of the signing address _signature bytes signature of the signed message using the public key Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#thresholdcondition","title":"ThresholdCondition","text":"<p>_Implementation of the Threshold Condition</p> <pre><code> Threshold condition acts as a filter for a set of input condition(s) in which sends \n a signal whether to complete the flow execution or abort it. This type of conditions \n works as intermediary conditions where they wire SEA conditions in order to support  \n more complex scenarios._\n</code></pre>"},{"location":"generated/solidity-api/#condition_type_14","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#initialize_19","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"generated/solidity-api/#hashvalues_25","title":"hashValues","text":"<pre><code>function hashValues(bytes32[] inputConditions, uint256 threshold) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_26","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32[] _inputConditions, uint256 threshold) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill threshold condition</p> <p>the fulfill method check whether input conditions are       fulfilled or not.</p> Name Type Description _agreementId bytes32 agreement identifier _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#canfulfill","title":"canFulfill","text":"<pre><code>function canFulfill(bytes32[] _inputConditions, uint256 threshold) private view returns (bool _fulfill)\n</code></pre> <p>canFulfill check if condition can be fulfilled</p> Name Type Description _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description _fulfill bool true if can fulfill"},{"location":"generated/solidity-api/#transferdidownershipcondition","title":"TransferDIDOwnershipCondition","text":"<p>Implementation of condition allowing to transfer the ownership      between the original owner and a receiver</p>"},{"location":"generated/solidity-api/#condition_type_15","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#didregistry_6","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#fulfilled_9","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, address _receiver, bytes32 _conditionId)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_20","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress, address _didRegistryAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address"},{"location":"generated/solidity-api/#hashvalues_26","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _receiver) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_27","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _receiver) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill the transfer DID ownership condition</p> <p>only DID owner or DID provider can call this       method. Fulfill method transfer full ownership permissions        to to _receiver address.        When true then fulfill the condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#whitelistingcondition","title":"WhitelistingCondition","text":"<p>Implementation of the Whitelisting Condition</p>"},{"location":"generated/solidity-api/#condition_type_16","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#initialize_21","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> <p>this function is called only once during the contract       initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"generated/solidity-api/#hashvalues_27","title":"hashValues","text":"<pre><code>function hashValues(address _listAddress, bytes32 _item) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _listAddress address list contract address _item bytes32 item in the list Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_28","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, address _listAddress, bytes32 _item) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill check whether address is whitelisted in order to fulfill the condition. This method will be  called by any one in this whitelist.</p> Name Type Description _agreementId bytes32 SEA agreement identifier _listAddress address list contract address _item bytes32 item in the list Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#aaveborrowcondition","title":"AaveBorrowCondition","text":"<p>Implementation of the Aave Borrow Credit Condition</p>"},{"location":"generated/solidity-api/#aavecreditvault_1","title":"aaveCreditVault","text":"<pre><code>contract AaveCreditVault aaveCreditVault\n</code></pre>"},{"location":"generated/solidity-api/#condition_type_17","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#fulfilled_10","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, bytes32 _conditionId)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_22","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"generated/solidity-api/#hashvalues_28","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _vaultAddress, address _assetToBorrow, uint256 _amount, uint256 _interestRateMode) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToBorrow address the address of the asset to borrow (i.e DAI) _amount uint256 the amount of the ERC-20 the assets to borrow (i.e 50 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_29","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _vaultAddress, address _assetToBorrow, uint256 _amount, uint256 _interestRateMode) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>It allows the borrower to borrow the asset deposited by the lender</p> Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToBorrow address the address of the asset to borrow (i.e DAI) _amount uint256 the amount of the ERC-20 the assets to borrow (i.e 50 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)"},{"location":"generated/solidity-api/#aavecollateraldepositcondition","title":"AaveCollateralDepositCondition","text":"<p>Implementation of the Aave Collateral Deposit Condition This condition allows a Lender to deposit the collateral that  into account the royalties to be paid to the original creators in a secondary market.</p>"},{"location":"generated/solidity-api/#aavecreditvault_2","title":"aaveCreditVault","text":"<pre><code>contract AaveCreditVault aaveCreditVault\n</code></pre>"},{"location":"generated/solidity-api/#condition_type_18","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#fulfilled_11","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, bytes32 _conditionId)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_23","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"generated/solidity-api/#hashvalues_29","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _vaultAddress, address _collateralAsset, uint256 _collateralAmount, address _delegatedAsset, uint256 _delegatedAmount, uint256 _interestRateMode) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the ERC-20 that will be used as collateral (i.e WETH) _collateralAmount uint256 the amount of the ERC-20 that will be used as collateral (i.e 10 WETH) _delegatedAsset address the address of the ERC-20 that will be delegated to the borrower (i.e DAI) _delegatedAmount uint256 the amount of the ERC-20 that will be delegated to the borrower (i.e 500 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_30","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _vaultAddress, address _collateralAsset, uint256 _collateralAmount, address _delegatedAsset, uint256 _delegatedAmount, uint256 _interestRateMode) external payable returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>It fulfills the condition if the collateral can be deposited into the vault</p> Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the ERC-20 that will be used as collateral (i.e WETH) _collateralAmount uint256 the amount of the ERC-20 that will be used as collateral (i.e 10 WETH) _delegatedAsset address the address of the ERC-20 that will be delegated to the borrower (i.e DAI) _delegatedAmount uint256 the amount of the ERC-20 that will be delegated to the borrower (i.e 500 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)"},{"location":"generated/solidity-api/#aavecollateralwithdrawcondition","title":"AaveCollateralWithdrawCondition","text":"<p>Implementation of the Collateral Withdraw Condition This condition allows to credit delegator withdraw the collateral and fees after the agreement expiration</p>"},{"location":"generated/solidity-api/#aavecreditvault_3","title":"aaveCreditVault","text":"<pre><code>contract AaveCreditVault aaveCreditVault\n</code></pre>"},{"location":"generated/solidity-api/#condition_type_19","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#fulfilled_12","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, bytes32 _conditionId)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_24","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"generated/solidity-api/#hashvalues_30","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _vaultAddress, address _collateralAsset) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the asset used as collateral (i.e DAI) Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_31","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _vaultAddress, address _collateralAsset) external payable returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>It allows the borrower to repay the loan</p> Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the asset used as collateral (i.e DAI) Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)"},{"location":"generated/solidity-api/#aavecreditvault_4","title":"AaveCreditVault","text":""},{"location":"generated/solidity-api/#lendingpool","title":"lendingPool","text":"<pre><code>contract ILendingPool lendingPool\n</code></pre>"},{"location":"generated/solidity-api/#dataprovider","title":"dataProvider","text":"<pre><code>contract IProtocolDataProvider dataProvider\n</code></pre>"},{"location":"generated/solidity-api/#weth","title":"weth","text":"<pre><code>contract IWETHGateway weth\n</code></pre>"},{"location":"generated/solidity-api/#addressprovider","title":"addressProvider","text":"<pre><code>contract ILendingPoolAddressesProvider addressProvider\n</code></pre>"},{"location":"generated/solidity-api/#priceoracle","title":"priceOracle","text":"<pre><code>contract IPriceOracleGetter priceOracle\n</code></pre>"},{"location":"generated/solidity-api/#borrowedasset","title":"borrowedAsset","text":"<pre><code>address borrowedAsset\n</code></pre>"},{"location":"generated/solidity-api/#borrowedamount","title":"borrowedAmount","text":"<pre><code>uint256 borrowedAmount\n</code></pre>"},{"location":"generated/solidity-api/#nvmfee","title":"nvmFee","text":"<pre><code>uint256 nvmFee\n</code></pre>"},{"location":"generated/solidity-api/#agreementfee","title":"agreementFee","text":"<pre><code>uint256 agreementFee\n</code></pre>"},{"location":"generated/solidity-api/#fee_base","title":"FEE_BASE","text":"<pre><code>uint256 FEE_BASE\n</code></pre>"},{"location":"generated/solidity-api/#treasuryaddress","title":"treasuryAddress","text":"<pre><code>address treasuryAddress\n</code></pre>"},{"location":"generated/solidity-api/#borrower","title":"borrower","text":"<pre><code>address borrower\n</code></pre>"},{"location":"generated/solidity-api/#lender","title":"lender","text":"<pre><code>address lender\n</code></pre>"},{"location":"generated/solidity-api/#repayconditionid","title":"repayConditionId","text":"<pre><code>bytes32 repayConditionId\n</code></pre>"},{"location":"generated/solidity-api/#nftid","title":"nftId","text":"<pre><code>uint256 nftId\n</code></pre>"},{"location":"generated/solidity-api/#nftaddress","title":"nftAddress","text":"<pre><code>address nftAddress\n</code></pre>"},{"location":"generated/solidity-api/#borrower_role","title":"BORROWER_ROLE","text":"<pre><code>bytes32 BORROWER_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#lender_role","title":"LENDER_ROLE","text":"<pre><code>bytes32 LENDER_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#condition_role","title":"CONDITION_ROLE","text":"<pre><code>bytes32 CONDITION_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#initialize_25","title":"initialize","text":"<pre><code>function initialize(address _lendingPool, address _dataProvider, address _weth, uint256 _nvmFee, uint256 _agreementFee, address _treasuryAddress, address _borrower, address _lender, address[] _conditions) public\n</code></pre> <p>Vault constructor, creates a unique vault for each agreement</p> Name Type Description _lendingPool address Aave lending pool address _dataProvider address Aave data provider address _weth address WETH address _nvmFee uint256 Nevermined fee that will apply to this agreeement _agreementFee uint256 Agreement fee that lender will receive on agreement maturity _treasuryAddress address Address of nevermined contract to store fees _borrower address _lender address _conditions address[]"},{"location":"generated/solidity-api/#islender","title":"isLender","text":"<pre><code>function isLender(address _address) public view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#isborrower","title":"isBorrower","text":"<pre><code>function isBorrower(address _address) public view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#deposit","title":"deposit","text":"<pre><code>function deposit(address _collateralAsset, uint256 _amount) public payable\n</code></pre> <p>Deposit function. Receives the funds from the delegator and deposits the funds in the Aave contracts</p> Name Type Description _collateralAsset address collateral asset that will be deposit on Aave _amount uint256 Amount of collateral to deposit"},{"location":"generated/solidity-api/#approveborrower","title":"approveBorrower","text":"<pre><code>function approveBorrower(address _borrower, uint256 _amount, address _asset, uint256 _interestRateMode) public\n</code></pre> <p>Appproves delegatee to borrow funds from Aave on behalf of delegator</p> Name Type Description _borrower address delegatee that will borrow the funds _amount uint256 Amount of funds to delegate _asset address Asset to delegate the borrow _interestRateMode uint256 interest rate type stable 1, variable 2"},{"location":"generated/solidity-api/#delegatedamount","title":"delegatedAmount","text":"<pre><code>function delegatedAmount(address _borrower, address _asset, uint256 _interestRateMode) public view returns (uint256)\n</code></pre> <p>Return the actual delegated amount for the borrower in the specific asset</p> Name Type Description _borrower address The borrower of the funds (i.e. delgatee) _asset address The asset they are allowed to borrow _interestRateMode uint256 interest rate type stable 1, variable 2"},{"location":"generated/solidity-api/#borrow","title":"borrow","text":"<pre><code>function borrow(address _assetToBorrow, uint256 _amount, address _delgatee, uint256 _interestRateMode) public\n</code></pre> <p>Borrower can call this function to borrow the delegated funds</p> Name Type Description _assetToBorrow address The asset they are allowed to borrow _amount uint256 Amount to borrow _delgatee address Address where the funds will be transfered _interestRateMode uint256 interest rate type stable 1, variable 2"},{"location":"generated/solidity-api/#repay","title":"repay","text":"<pre><code>function repay(address _asset, uint256 _interestRateMode, bytes32 _repayConditionId) public\n</code></pre> <p>Repay an uncollaterised loan</p> Name Type Description _asset address The asset to be repaid _interestRateMode uint256 interest rate type stable 1, variable 2 _repayConditionId bytes32 identifier of the condition id working as lock for other vault methods"},{"location":"generated/solidity-api/#setrepayconditionid","title":"setRepayConditionId","text":"<pre><code>function setRepayConditionId(bytes32 _repayConditionId) public\n</code></pre>"},{"location":"generated/solidity-api/#getborrowedamount","title":"getBorrowedAmount","text":"<pre><code>function getBorrowedAmount() public view returns (uint256)\n</code></pre> <p>Returns the borrowed amount from the delegatee on this agreement</p>"},{"location":"generated/solidity-api/#getassetprice","title":"getAssetPrice","text":"<pre><code>function getAssetPrice(address _asset) public view returns (uint256)\n</code></pre> <p>Returns the priceof the asset in the Aave oracles</p> Name Type Description _asset address The asset to get the actual price"},{"location":"generated/solidity-api/#getcreditassetdebt","title":"getCreditAssetDebt","text":"<pre><code>function getCreditAssetDebt() public view returns (uint256)\n</code></pre> <p>Returns the total debt of the credit in the Aave protocol expressed in token units</p>"},{"location":"generated/solidity-api/#getactualcreditdebt","title":"getActualCreditDebt","text":"<pre><code>function getActualCreditDebt() public view returns (uint256)\n</code></pre> <p>Returns the total debt of the credit in the Aave protocol expressed in ETH units</p>"},{"location":"generated/solidity-api/#gettotalactualdebt","title":"getTotalActualDebt","text":"<pre><code>function getTotalActualDebt() public view returns (uint256)\n</code></pre> <p>Returns the total actual debt of the agreement credit + fees in token units</p>"},{"location":"generated/solidity-api/#withdrawcollateral","title":"withdrawCollateral","text":"<pre><code>function withdrawCollateral(address _asset, address _delegator) public\n</code></pre> <p>Withdraw all of a collateral as the underlying asset, if no outstanding loans delegated</p> Name Type Description _asset address The underlying asset to withdraw _delegator address Delegator address that deposited the collateral"},{"location":"generated/solidity-api/#transfernft","title":"transferNFT","text":"<pre><code>function transferNFT(uint256 _tokenId, address _receiver) public\n</code></pre> <p>Transfer a NFT (ERC-721) locked into the vault to a receiver address</p> Name Type Description _tokenId uint256 the token id _receiver address the receiver adddress"},{"location":"generated/solidity-api/#_transfererc20","title":"_transferERC20","text":"<pre><code>function _transferERC20(address _collateralAsset, uint256 _amount) internal\n</code></pre> <p>Transfers the ERC20 token deposited to the Aave contracts</p> Name Type Description _collateralAsset address collateral asset that will be deposit on Aave _amount uint256 Amount of collateral to deposit"},{"location":"generated/solidity-api/#onerc721received_1","title":"onERC721Received","text":"<pre><code>function onERC721Received(address, address, uint256 _tokenId, bytes) public virtual returns (bytes4)\n</code></pre> <p>Handle the receipt of an NFT</p> <p>_The ERC721 smart contract calls this function on the recipient after a {IERC721-safeTransferFrom}. This function MUST return the function selector, otherwise the caller will revert the transaction. </p> <p>Note: the ERC721 contract address is always the message sender. (param not used): operator The address which called <code>safeTransferFrom</code> function (param not used): from The address which previously owned the token_</p> Name Type Description address address _tokenId uint256 The NFT identifier which is being transferred (param not used): data Additional data with no specified format bytes Name Type Description [0] bytes4 bytes4 <code>bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))</code>"},{"location":"generated/solidity-api/#aaverepaycondition","title":"AaveRepayCondition","text":"<p>Implementation of the Aave Repay Condition This condition allows to a borrower to repay a credit as part of a credit template</p>"},{"location":"generated/solidity-api/#aavecreditvault_5","title":"aaveCreditVault","text":"<pre><code>contract AaveCreditVault aaveCreditVault\n</code></pre>"},{"location":"generated/solidity-api/#condition_type_20","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#fulfilled_13","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, bytes32 _did, bytes32 _conditionId)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_26","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the contract with the following parameters</p> <p>this function is called only once during the contract initialization.</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"generated/solidity-api/#hashvalues_31","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, address _vaultAddress, address _assetToRepay, uint256 _amountToRepay, uint256 _interestRateMode) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToRepay address the address of the asset to repay (i.e DAI) _amountToRepay uint256 Amount to repay _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_32","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, address _vaultAddress, address _assetToRepay, uint256 _amountToRepay, uint256 _interestRateMode) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>It allows the borrower to repay the loan</p> Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToRepay address the address of the asset to repay (i.e DAI) _amountToRepay uint256 Amount to repay _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)"},{"location":"generated/solidity-api/#escrowpaymentcondition","title":"EscrowPaymentCondition","text":"<p>_Implementation of the Escrow Payment Condition</p> <pre><code> The Escrow payment is reward condition in which only \n can release reward if lock and release conditions\n are fulfilled._\n</code></pre>"},{"location":"generated/solidity-api/#condition_type_21","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#used_payment_id","title":"USED_PAYMENT_ID","text":"<pre><code>bytes32 USED_PAYMENT_ID\n</code></pre>"},{"location":"generated/solidity-api/#fulfilled_14","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, address _tokenAddress, address[] _receivers, bytes32 _conditionId, uint256[] _amounts)\n</code></pre>"},{"location":"generated/solidity-api/#received","title":"Received","text":"<pre><code>event Received(address _from, uint256 _value)\n</code></pre>"},{"location":"generated/solidity-api/#receive","title":"receive","text":"<pre><code>receive() external payable\n</code></pre>"},{"location":"generated/solidity-api/#initialize_27","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"generated/solidity-api/#hashvaluesmulti","title":"hashValuesMulti","text":"<pre><code>function hashValuesMulti(bytes32 _did, uint256[] _amounts, address[] _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#encodeparams_3","title":"encodeParams","text":"<pre><code>function encodeParams(bytes32 _did, uint256[] _amounts, address[] _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) public pure returns (bytes)\n</code></pre>"},{"location":"generated/solidity-api/#hashvalues_32","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, uint256[] _amounts, address[] _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32 _releaseCondition) public pure returns (bytes32)\n</code></pre>"},{"location":"generated/solidity-api/#hashvalueslockpayment","title":"hashValuesLockPayment","text":"<pre><code>function hashValuesLockPayment(bytes32 _did, address _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) public pure returns (bytes32)\n</code></pre> <p>hashValuesLockPayment generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment.         If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfillmulti","title":"fulfillMulti","text":"<pre><code>function fulfillMulti(bytes32 _agreementId, bytes32 _did, uint256[] _amounts, address[] _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) public returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill escrow reward condition</p> <p>fulfill method checks whether the lock and       release conditions are fulfilled in order to       release/refund the reward to receiver/sender       respectively.</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#args","title":"Args","text":"<pre><code>struct Args {\n  bytes32 _agreementId;\n  bytes32 _did;\n  uint256[] _amounts;\n  address[] _receivers;\n  address _returnAddress;\n  address _lockPaymentAddress;\n  address _tokenAddress;\n  bytes32 _lockCondition;\n  bytes32[] _releaseConditions;\n}\n</code></pre>"},{"location":"generated/solidity-api/#fulfillkludge","title":"fulfillKludge","text":"<pre><code>function fulfillKludge(struct EscrowPaymentCondition.Args a) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"generated/solidity-api/#fulfill_33","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, uint256[] _amounts, address[] _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32 _releaseCondition) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"generated/solidity-api/#_transferandfulfillerc20","title":"_transferAndFulfillERC20","text":"<pre><code>function _transferAndFulfillERC20(bytes32 _id, address _tokenAddress, address[] _receivers, uint256[] _amounts) private returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>_transferAndFulfill transfer ERC20 tokens and        fulfill the condition</p> Name Type Description _id bytes32 condition identifier _tokenAddress address the ERC20 contract address to use during the payment _receivers address[] receiver's address _amounts uint256[] token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#_transferandfulfilleth","title":"_transferAndFulfillETH","text":"<pre><code>function _transferAndFulfillETH(bytes32 _id, address[] _receivers, uint256[] _amounts) private returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>_transferAndFulfill transfer ETH and        fulfill the condition</p> Name Type Description _id bytes32 condition identifier _receivers address[] receiver's address _amounts uint256[] token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#inftescrow","title":"INFTEscrow","text":"<p>Common interface for ERC-721 and ERC-1155</p>"},{"location":"generated/solidity-api/#fulfilled_15","title":"Fulfilled","text":"<pre><code>event Fulfilled(bytes32 _agreementId, address _tokenAddress, bytes32 _did, address _receivers, bytes32 _conditionId, uint256 _amounts)\n</code></pre>"},{"location":"generated/solidity-api/#nft721escrowpaymentcondition","title":"NFT721EscrowPaymentCondition","text":"<p>_Implementation of the Escrow Payment Condition</p> <pre><code> The Escrow payment is reward condition in which only \n can release reward if lock and release conditions\n are fulfilled._\n</code></pre>"},{"location":"generated/solidity-api/#condition_type_22","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#received_1","title":"Received","text":"<pre><code>event Received(address _from, uint256 _value)\n</code></pre>"},{"location":"generated/solidity-api/#receive_1","title":"receive","text":"<pre><code>receive() external payable\n</code></pre>"},{"location":"generated/solidity-api/#initialize_28","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"generated/solidity-api/#hashvalues_33","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, uint256 _amounts, address _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 asset decentralized identifier _amounts uint256 token amounts to be locked/released _receivers address receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#hashvalueslockpayment_1","title":"hashValuesLockPayment","text":"<pre><code>function hashValuesLockPayment(bytes32 _did, address _lockAddress, address _nftContractAddress, uint256 _amount, address _receiver) public pure returns (bytes32)\n</code></pre> <p>hashValuesLockPayment generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the asset decentralized identifier _lockAddress address the contract address where the reward is locked _nftContractAddress address the ERC20 contract address to use during the lock payment.         If the address is 0x0 means we won't use a ERC20 but ETH for payment _amount uint256 token amounts to be locked/released _receiver address receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_34","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, uint256 _amount, address _receiver, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill escrow reward condition</p> <p>fulfill method checks whether the lock and       release conditions are fulfilled in order to       release/refund the reward to receiver/sender       respectively.</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amount uint256 token amounts to be locked/released _receiver address receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#args_1","title":"Args","text":"<pre><code>struct Args {\n  bytes32 _agreementId;\n  bytes32 _did;\n  uint256 _amount;\n  address _receiver;\n  address _returnAddress;\n  address _lockPaymentAddress;\n  address _tokenAddress;\n  bytes32 _lockCondition;\n  bytes32[] _releaseConditions;\n}\n</code></pre>"},{"location":"generated/solidity-api/#fulfillkludge_1","title":"fulfillKludge","text":"<pre><code>function fulfillKludge(struct NFT721EscrowPaymentCondition.Args a) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"generated/solidity-api/#_transferandfulfillnft","title":"_transferAndFulfillNFT","text":"<pre><code>function _transferAndFulfillNFT(bytes32 _agreementId, bytes32 _id, bytes32 _did, address _tokenAddress, address _receiver, uint256 _amount) private returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>_transferAndFulfill transfer ERC20 tokens and        fulfill the condition</p> Name Type Description _agreementId bytes32 _id bytes32 condition identifier _did bytes32 _tokenAddress address the ERC20 contract address to use during the payment _receiver address receiver's address _amount uint256 token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#onerc721received_2","title":"onERC721Received","text":"<pre><code>function onERC721Received(address, address, uint256, bytes) public virtual returns (bytes4)\n</code></pre>"},{"location":"generated/solidity-api/#nftescrowpaymentcondition","title":"NFTEscrowPaymentCondition","text":"<p>_Implementation of the Escrow Payment Condition</p> <pre><code> The Escrow payment is reward condition in which only \n can release reward if lock and release conditions\n are fulfilled._\n</code></pre>"},{"location":"generated/solidity-api/#condition_type_23","title":"CONDITION_TYPE","text":"<pre><code>bytes32 CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#lock_condition_type","title":"LOCK_CONDITION_TYPE","text":"<pre><code>bytes32 LOCK_CONDITION_TYPE\n</code></pre>"},{"location":"generated/solidity-api/#received_2","title":"Received","text":"<pre><code>event Received(address _from, uint256 _value)\n</code></pre>"},{"location":"generated/solidity-api/#receive_2","title":"receive","text":"<pre><code>receive() external payable\n</code></pre>"},{"location":"generated/solidity-api/#initialize_29","title":"initialize","text":"<pre><code>function initialize(address _owner, address _conditionStoreManagerAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters</p> Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address"},{"location":"generated/solidity-api/#hashvalues_34","title":"hashValues","text":"<pre><code>function hashValues(bytes32 _did, uint256 _amounts, address _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) public pure returns (bytes32)\n</code></pre> <p>hashValues generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 asset decentralized identifier _amounts uint256 token amounts to be locked/released _receivers address receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#hashvalueslockpayment_2","title":"hashValuesLockPayment","text":"<pre><code>function hashValuesLockPayment(bytes32 _did, address _lockAddress, address _nftContractAddress, uint256 _amount, address _receiver) public pure returns (bytes32)\n</code></pre> <p>hashValuesLockPayment generates the hash of condition inputs         with the following parameters</p> Name Type Description _did bytes32 the asset decentralized identifier _lockAddress address the contract address where the reward is locked _nftContractAddress address the ERC20 contract address to use during the lock payment.         If the address is 0x0 means we won't use a ERC20 but ETH for payment _amount uint256 token amounts to be locked/released _receiver address receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values"},{"location":"generated/solidity-api/#fulfill_35","title":"fulfill","text":"<pre><code>function fulfill(bytes32 _agreementId, bytes32 _did, uint256 _amount, address _receiver, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) external returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>fulfill escrow reward condition</p> <p>fulfill method checks whether the lock and       release conditions are fulfilled in order to       release/refund the reward to receiver/sender       respectively.</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amount uint256 token amounts to be locked/released _receiver address receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#args_2","title":"Args","text":"<pre><code>struct Args {\n  bytes32 _agreementId;\n  bytes32 _did;\n  uint256 _amount;\n  address _receiver;\n  address _returnAddress;\n  address _lockPaymentAddress;\n  address _tokenAddress;\n  bytes32 _lockCondition;\n  bytes32[] _releaseConditions;\n}\n</code></pre>"},{"location":"generated/solidity-api/#fulfillkludge_2","title":"fulfillKludge","text":"<pre><code>function fulfillKludge(struct NFTEscrowPaymentCondition.Args a) internal returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre>"},{"location":"generated/solidity-api/#_transferandfulfillnft_1","title":"_transferAndFulfillNFT","text":"<pre><code>function _transferAndFulfillNFT(bytes32 _agreementId, bytes32 _id, bytes32 _did, address _tokenAddress, address _receiver, uint256 _amount) private returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>_transferAndFulfill transfer ERC20 tokens and        fulfill the condition</p> Name Type Description _agreementId bytes32 _id bytes32 condition identifier _did bytes32 _tokenAddress address the ERC20 contract address to use during the payment _receiver address receiver's address _amount uint256 token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)"},{"location":"generated/solidity-api/#erc1155_accepted_1","title":"ERC1155_ACCEPTED","text":"<pre><code>bytes4 ERC1155_ACCEPTED\n</code></pre>"},{"location":"generated/solidity-api/#erc1155_batch_accepted_1","title":"ERC1155_BATCH_ACCEPTED","text":"<pre><code>bytes4 ERC1155_BATCH_ACCEPTED\n</code></pre>"},{"location":"generated/solidity-api/#onerc1155received_1","title":"onERC1155Received","text":"<pre><code>function onERC1155Received(address, address, uint256, uint256, bytes) external pure returns (bytes4)\n</code></pre>"},{"location":"generated/solidity-api/#onerc1155batchreceived_1","title":"onERC1155BatchReceived","text":"<pre><code>function onERC1155BatchReceived(address, address, uint256[], uint256[], bytes) external pure returns (bytes4)\n</code></pre>"},{"location":"generated/solidity-api/#supportsinterface_1","title":"supportsInterface","text":"<pre><code>function supportsInterface(bytes4 interfaceId) external pure returns (bool)\n</code></pre> <p>_Returns true if this contract implements the interface defined by <code>interfaceId</code>. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created.</p> <p>This function call must use less than 30 000 gas._</p>"},{"location":"generated/solidity-api/#reward","title":"Reward","text":"<p>_Implementation of the Reward.</p> <pre><code> Generic reward condition_\n</code></pre>"},{"location":"generated/solidity-api/#invmconfig","title":"INVMConfig","text":""},{"location":"generated/solidity-api/#governor_role","title":"GOVERNOR_ROLE","text":"<pre><code>bytes32 GOVERNOR_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#neverminedconfigchange","title":"NeverminedConfigChange","text":"<pre><code>event NeverminedConfigChange(address _whoChanged, bytes32 _parameter)\n</code></pre> <p>Event that is emitted when a parameter is changed</p> Name Type Description _whoChanged address the address of the governor changing the parameter _parameter bytes32 the hash of the name of the parameter changed"},{"location":"generated/solidity-api/#initialize_30","title":"initialize","text":"<pre><code>function initialize(address _owner, address _governor) external virtual\n</code></pre> <p>Used to initialize the contract during delegator constructor</p> Name Type Description _owner address The owner of the contract _governor address The address to be granted with the <code>GOVERNOR_ROLE</code>"},{"location":"generated/solidity-api/#setmarketplacefees","title":"setMarketplaceFees","text":"<pre><code>function setMarketplaceFees(uint256 _marketplaceFee, address _feeReceiver) external virtual\n</code></pre> <p>The governor can update the Nevermined Marketplace fees</p> Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee"},{"location":"generated/solidity-api/#isgovernor","title":"isGovernor","text":"<pre><code>function isGovernor(address _address) external view virtual returns (bool)\n</code></pre> <p>Indicates if an address is a having the GOVERNOR role</p> Name Type Description _address address The address to validate Name Type Description [0] bool true if is a governor"},{"location":"generated/solidity-api/#getmarketplacefee","title":"getMarketplaceFee","text":"<pre><code>function getMarketplaceFee() external view virtual returns (uint256)\n</code></pre> <p>Returns the marketplace fee</p> Name Type Description [0] uint256 the marketplace fee"},{"location":"generated/solidity-api/#getfeereceiver","title":"getFeeReceiver","text":"<pre><code>function getFeeReceiver() external view virtual returns (address)\n</code></pre> <p>Returns the receiver address of the marketplace fee</p> Name Type Description [0] address the receiver address"},{"location":"generated/solidity-api/#neverminedconfig","title":"NeverminedConfig","text":""},{"location":"generated/solidity-api/#marketplacefee","title":"marketplaceFee","text":"<pre><code>uint256 marketplaceFee\n</code></pre>"},{"location":"generated/solidity-api/#feereceiver","title":"feeReceiver","text":"<pre><code>address feeReceiver\n</code></pre>"},{"location":"generated/solidity-api/#initialize_31","title":"initialize","text":"<pre><code>function initialize(address _owner, address _governor) public\n</code></pre> <p>Used to initialize the contract during delegator constructor</p> Name Type Description _owner address The owner of the contract _governor address The address to be granted with the <code>GOVERNOR_ROLE</code>"},{"location":"generated/solidity-api/#setmarketplacefees_1","title":"setMarketplaceFees","text":"<pre><code>function setMarketplaceFees(uint256 _marketplaceFee, address _feeReceiver) external virtual\n</code></pre> <p>The governor can update the Nevermined Marketplace fees</p> Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee"},{"location":"generated/solidity-api/#setgovernor","title":"setGovernor","text":"<pre><code>function setGovernor(address _address) external\n</code></pre>"},{"location":"generated/solidity-api/#isgovernor_1","title":"isGovernor","text":"<pre><code>function isGovernor(address _address) external view returns (bool)\n</code></pre> <p>Indicates if an address is a having the GOVERNOR role</p> Name Type Description _address address The address to validate Name Type Description [0] bool true if is a governor"},{"location":"generated/solidity-api/#getmarketplacefee_1","title":"getMarketplaceFee","text":"<pre><code>function getMarketplaceFee() external view returns (uint256)\n</code></pre> <p>Returns the marketplace fee</p> Name Type Description [0] uint256 the marketplace fee"},{"location":"generated/solidity-api/#getfeereceiver_1","title":"getFeeReceiver","text":"<pre><code>function getFeeReceiver() external view returns (address)\n</code></pre> <p>Returns the receiver address of the marketplace fee</p> Name Type Description [0] address the receiver address"},{"location":"generated/solidity-api/#onlygovernor","title":"onlyGovernor","text":"<pre><code>modifier onlyGovernor(address _address)\n</code></pre>"},{"location":"generated/solidity-api/#ierc20","title":"IERC20","text":""},{"location":"generated/solidity-api/#totalsupply","title":"totalSupply","text":"<pre><code>function totalSupply() external view returns (uint256)\n</code></pre> <p>Returns the amount of tokens in existence.</p>"},{"location":"generated/solidity-api/#balanceof","title":"balanceOf","text":"<pre><code>function balanceOf(address account) external view returns (uint256)\n</code></pre> <p>Returns the amount of tokens owned by <code>account</code>.</p>"},{"location":"generated/solidity-api/#transfer","title":"transfer","text":"<pre><code>function transfer(address recipient, uint256 amount) external returns (bool)\n</code></pre> <p>_Moves <code>amount</code> tokens from the caller's account to <code>recipient</code>.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>Emits a {Transfer} event._</p>"},{"location":"generated/solidity-api/#allowance","title":"allowance","text":"<pre><code>function allowance(address owner, address spender) external view returns (uint256)\n</code></pre> <p>_Returns the remaining number of tokens that <code>spender</code> will be allowed to spend on behalf of <code>owner</code> through {transferFrom}. This is zero by default.</p> <p>This value changes when {approve} or {transferFrom} are called._</p>"},{"location":"generated/solidity-api/#approve","title":"approve","text":"<pre><code>function approve(address spender, uint256 amount) external returns (bool)\n</code></pre> <p>_Sets <code>amount</code> as the allowance of <code>spender</code> over the caller's tokens.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</p> <p>Emits an {Approval} event._</p>"},{"location":"generated/solidity-api/#transferfrom","title":"transferFrom","text":"<pre><code>function transferFrom(address sender, address recipient, uint256 amount) external returns (bool)\n</code></pre> <p>_Moves <code>amount</code> tokens from <code>sender</code> to <code>recipient</code> using the allowance mechanism. <code>amount</code> is then deducted from the caller's allowance.</p> <p>Returns a boolean value indicating whether the operation succeeded.</p> <p>Emits a {Transfer} event._</p>"},{"location":"generated/solidity-api/#transfer_1","title":"Transfer","text":"<pre><code>event Transfer(address from, address to, uint256 value)\n</code></pre> <p>_Emitted when <code>value</code> tokens are moved from one account (<code>from</code>) to another (<code>to</code>).</p> <p>Note that <code>value</code> may be zero._</p>"},{"location":"generated/solidity-api/#approval","title":"Approval","text":"<pre><code>event Approval(address owner, address spender, uint256 value)\n</code></pre> <p>Emitted when the allowance of a <code>spender</code> for an <code>owner</code> is set by a call to {approve}. <code>value</code> is the new allowance.</p>"},{"location":"generated/solidity-api/#ipriceoraclegetter","title":"IPriceOracleGetter","text":"<p>Interface for the Aave price oracle.</p>"},{"location":"generated/solidity-api/#getassetprice_1","title":"getAssetPrice","text":"<pre><code>function getAssetPrice(address asset) external view returns (uint256)\n</code></pre> <p>returns the asset price in ETH</p> Name Type Description asset address the address of the asset Name Type Description [0] uint256 the ETH price of the asset"},{"location":"generated/solidity-api/#iprotocoldataprovider","title":"IProtocolDataProvider","text":""},{"location":"generated/solidity-api/#tokendata","title":"TokenData","text":"<pre><code>struct TokenData {\n  string symbol;\n  address tokenAddress;\n}\n</code></pre>"},{"location":"generated/solidity-api/#addresses_provider","title":"ADDRESSES_PROVIDER","text":"<pre><code>function ADDRESSES_PROVIDER() external view returns (contract ILendingPoolAddressesProvider)\n</code></pre>"},{"location":"generated/solidity-api/#getallreservestokens","title":"getAllReservesTokens","text":"<pre><code>function getAllReservesTokens() external view returns (struct IProtocolDataProvider.TokenData[])\n</code></pre>"},{"location":"generated/solidity-api/#getallatokens","title":"getAllATokens","text":"<pre><code>function getAllATokens() external view returns (struct IProtocolDataProvider.TokenData[])\n</code></pre>"},{"location":"generated/solidity-api/#getreserveconfigurationdata","title":"getReserveConfigurationData","text":"<pre><code>function getReserveConfigurationData(address asset) external view returns (uint256 decimals, uint256 ltv, uint256 liquidationThreshold, uint256 liquidationBonus, uint256 reserveFactor, bool usageAsCollateralEnabled, bool borrowingEnabled, bool stableBorrowRateEnabled, bool isActive, bool isFrozen)\n</code></pre>"},{"location":"generated/solidity-api/#getreservedata","title":"getReserveData","text":"<pre><code>function getReserveData(address asset) external view returns (uint256 availableLiquidity, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)\n</code></pre>"},{"location":"generated/solidity-api/#getuserreservedata","title":"getUserReserveData","text":"<pre><code>function getUserReserveData(address asset, address user) external view returns (uint256 currentATokenBalance, uint256 currentStableDebt, uint256 currentVariableDebt, uint256 principalStableDebt, uint256 scaledVariableDebt, uint256 stableBorrowRate, uint256 liquidityRate, uint40 stableRateLastUpdated, bool usageAsCollateralEnabled)\n</code></pre>"},{"location":"generated/solidity-api/#getreservetokensaddresses","title":"getReserveTokensAddresses","text":"<pre><code>function getReserveTokensAddresses(address asset) external view returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress)\n</code></pre>"},{"location":"generated/solidity-api/#ilendingpooladdressesprovider","title":"ILendingPoolAddressesProvider","text":""},{"location":"generated/solidity-api/#marketidset","title":"MarketIdSet","text":"<pre><code>event MarketIdSet(string newMarketId)\n</code></pre>"},{"location":"generated/solidity-api/#lendingpoolupdated","title":"LendingPoolUpdated","text":"<pre><code>event LendingPoolUpdated(address newAddress)\n</code></pre>"},{"location":"generated/solidity-api/#configurationadminupdated","title":"ConfigurationAdminUpdated","text":"<pre><code>event ConfigurationAdminUpdated(address newAddress)\n</code></pre>"},{"location":"generated/solidity-api/#emergencyadminupdated","title":"EmergencyAdminUpdated","text":"<pre><code>event EmergencyAdminUpdated(address newAddress)\n</code></pre>"},{"location":"generated/solidity-api/#lendingpoolconfiguratorupdated","title":"LendingPoolConfiguratorUpdated","text":"<pre><code>event LendingPoolConfiguratorUpdated(address newAddress)\n</code></pre>"},{"location":"generated/solidity-api/#lendingpoolcollateralmanagerupdated","title":"LendingPoolCollateralManagerUpdated","text":"<pre><code>event LendingPoolCollateralManagerUpdated(address newAddress)\n</code></pre>"},{"location":"generated/solidity-api/#priceoracleupdated","title":"PriceOracleUpdated","text":"<pre><code>event PriceOracleUpdated(address newAddress)\n</code></pre>"},{"location":"generated/solidity-api/#lendingrateoracleupdated","title":"LendingRateOracleUpdated","text":"<pre><code>event LendingRateOracleUpdated(address newAddress)\n</code></pre>"},{"location":"generated/solidity-api/#proxycreated","title":"ProxyCreated","text":"<pre><code>event ProxyCreated(bytes32 id, address newAddress)\n</code></pre>"},{"location":"generated/solidity-api/#addressset","title":"AddressSet","text":"<pre><code>event AddressSet(bytes32 id, address newAddress, bool hasProxy)\n</code></pre>"},{"location":"generated/solidity-api/#getmarketid","title":"getMarketId","text":"<pre><code>function getMarketId() external view returns (string)\n</code></pre>"},{"location":"generated/solidity-api/#setmarketid","title":"setMarketId","text":"<pre><code>function setMarketId(string marketId) external\n</code></pre>"},{"location":"generated/solidity-api/#setaddress","title":"setAddress","text":"<pre><code>function setAddress(bytes32 id, address newAddress) external\n</code></pre>"},{"location":"generated/solidity-api/#setaddressasproxy","title":"setAddressAsProxy","text":"<pre><code>function setAddressAsProxy(bytes32 id, address impl) external\n</code></pre>"},{"location":"generated/solidity-api/#getaddress","title":"getAddress","text":"<pre><code>function getAddress(bytes32 id) external view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#getlendingpool","title":"getLendingPool","text":"<pre><code>function getLendingPool() external view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#setlendingpoolimpl","title":"setLendingPoolImpl","text":"<pre><code>function setLendingPoolImpl(address pool) external\n</code></pre>"},{"location":"generated/solidity-api/#getlendingpoolconfigurator","title":"getLendingPoolConfigurator","text":"<pre><code>function getLendingPoolConfigurator() external view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#setlendingpoolconfiguratorimpl","title":"setLendingPoolConfiguratorImpl","text":"<pre><code>function setLendingPoolConfiguratorImpl(address configurator) external\n</code></pre>"},{"location":"generated/solidity-api/#getlendingpoolcollateralmanager","title":"getLendingPoolCollateralManager","text":"<pre><code>function getLendingPoolCollateralManager() external view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#setlendingpoolcollateralmanager","title":"setLendingPoolCollateralManager","text":"<pre><code>function setLendingPoolCollateralManager(address manager) external\n</code></pre>"},{"location":"generated/solidity-api/#getpooladmin","title":"getPoolAdmin","text":"<pre><code>function getPoolAdmin() external view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#setpooladmin","title":"setPoolAdmin","text":"<pre><code>function setPoolAdmin(address admin) external\n</code></pre>"},{"location":"generated/solidity-api/#getemergencyadmin","title":"getEmergencyAdmin","text":"<pre><code>function getEmergencyAdmin() external view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#setemergencyadmin","title":"setEmergencyAdmin","text":"<pre><code>function setEmergencyAdmin(address admin) external\n</code></pre>"},{"location":"generated/solidity-api/#getpriceoracle","title":"getPriceOracle","text":"<pre><code>function getPriceOracle() external view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#setpriceoracle","title":"setPriceOracle","text":"<pre><code>function setPriceOracle(address priceOracle) external\n</code></pre>"},{"location":"generated/solidity-api/#getlendingrateoracle","title":"getLendingRateOracle","text":"<pre><code>function getLendingRateOracle() external view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#setlendingrateoracle","title":"setLendingRateOracle","text":"<pre><code>function setLendingRateOracle(address lendingRateOracle) external\n</code></pre>"},{"location":"generated/solidity-api/#ilendingpool","title":"ILendingPool","text":""},{"location":"generated/solidity-api/#deposit_1","title":"Deposit","text":"<pre><code>event Deposit(address reserve, address user, address onBehalfOf, uint256 amount, uint16 referral)\n</code></pre> <p>Emitted on deposit()</p> Name Type Description reserve address The address of the underlying asset of the reserve user address The address initiating the deposit onBehalfOf address The beneficiary of the deposit, receiving the aTokens amount uint256 The amount deposited referral uint16 The referral code used"},{"location":"generated/solidity-api/#withdraw","title":"Withdraw","text":"<pre><code>event Withdraw(address reserve, address user, address to, uint256 amount)\n</code></pre> <p>Emitted on withdraw()</p> Name Type Description reserve address The address of the underlyng asset being withdrawn user address The address initiating the withdrawal, owner of aTokens to address Address that will receive the underlying amount uint256 The amount to be withdrawn"},{"location":"generated/solidity-api/#borrow_1","title":"Borrow","text":"<pre><code>event Borrow(address reserve, address user, address onBehalfOf, uint256 amount, uint256 borrowRateMode, uint256 borrowRate, uint16 referral)\n</code></pre> <p>Emitted on borrow() and flashLoan() when debt needs to be opened</p> Name Type Description reserve address The address of the underlying asset being borrowed user address The address of the user initiating the borrow(), receiving the funds on borrow() or just initiator of the transaction on flashLoan() onBehalfOf address The address that will be getting the debt amount uint256 The amount borrowed out borrowRateMode uint256 The rate mode: 1 for Stable, 2 for Variable borrowRate uint256 The numeric rate at which the user has borrowed referral uint16 The referral code used"},{"location":"generated/solidity-api/#repay_1","title":"Repay","text":"<pre><code>event Repay(address reserve, address user, address repayer, uint256 amount)\n</code></pre> <p>Emitted on repay()</p> Name Type Description reserve address The address of the underlying asset of the reserve user address The beneficiary of the repayment, getting his debt reduced repayer address The address of the user initiating the repay(), providing the funds amount uint256 The amount repaid"},{"location":"generated/solidity-api/#swap","title":"Swap","text":"<pre><code>event Swap(address reserve, address user, uint256 rateMode)\n</code></pre> <p>Emitted on swapBorrowRateMode()</p> Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user swapping his rate mode rateMode uint256 The rate mode that the user wants to swap to"},{"location":"generated/solidity-api/#reserveusedascollateralenabled","title":"ReserveUsedAsCollateralEnabled","text":"<pre><code>event ReserveUsedAsCollateralEnabled(address reserve, address user)\n</code></pre> <p>Emitted on setUserUseReserveAsCollateral()</p> Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user enabling the usage as collateral"},{"location":"generated/solidity-api/#reserveusedascollateraldisabled","title":"ReserveUsedAsCollateralDisabled","text":"<pre><code>event ReserveUsedAsCollateralDisabled(address reserve, address user)\n</code></pre> <p>Emitted on setUserUseReserveAsCollateral()</p> Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user enabling the usage as collateral"},{"location":"generated/solidity-api/#rebalancestableborrowrate","title":"RebalanceStableBorrowRate","text":"<pre><code>event RebalanceStableBorrowRate(address reserve, address user)\n</code></pre> <p>Emitted on rebalanceStableBorrowRate()</p> Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user for which the rebalance has been executed"},{"location":"generated/solidity-api/#flashloan","title":"FlashLoan","text":"<pre><code>event FlashLoan(address target, address initiator, address asset, uint256 amount, uint256 premium, uint16 referralCode)\n</code></pre> <p>Emitted on flashLoan()</p> Name Type Description target address The address of the flash loan receiver contract initiator address The address initiating the flash loan asset address The address of the asset being flash borrowed amount uint256 The amount flash borrowed premium uint256 The fee flash borrowed referralCode uint16 The referral code used"},{"location":"generated/solidity-api/#paused","title":"Paused","text":"<pre><code>event Paused()\n</code></pre> <p>Emitted when the pause is triggered.</p>"},{"location":"generated/solidity-api/#unpaused","title":"Unpaused","text":"<pre><code>event Unpaused()\n</code></pre> <p>Emitted when the pause is lifted.</p>"},{"location":"generated/solidity-api/#liquidationcall","title":"LiquidationCall","text":"<pre><code>event LiquidationCall(address collateralAsset, address debtAsset, address user, uint256 debtToCover, uint256 liquidatedCollateralAmount, address liquidator, bool receiveAToken)\n</code></pre> <p>Emitted when a borrower is liquidated. This event is emitted by the LendingPool via LendingPoolCollateral manager using a DELEGATECALL This allows to have the events in the generated ABI for LendingPool.</p> Name Type Description collateralAsset address The address of the underlying asset used as collateral, to receive as result of the liquidation debtAsset address The address of the underlying borrowed asset to be repaid with the liquidation user address The address of the borrower getting liquidated debtToCover uint256 The debt amount of borrowed <code>asset</code> the liquidator wants to cover liquidatedCollateralAmount uint256 The amount of collateral received by the liiquidator liquidator address The address of the liquidator receiveAToken bool <code>true</code> if the liquidators wants to receive the collateral aTokens, <code>false</code> if he wants to receive the underlying collateral asset directly"},{"location":"generated/solidity-api/#reservedataupdated","title":"ReserveDataUpdated","text":"<pre><code>event ReserveDataUpdated(address reserve, uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex)\n</code></pre> <p>Emitted when the state of a reserve is updated. NOTE: This event is actually declared in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal, the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it gets added to the LendingPool ABI</p> Name Type Description reserve address The address of the underlying asset of the reserve liquidityRate uint256 The new liquidity rate stableBorrowRate uint256 The new stable borrow rate variableBorrowRate uint256 The new variable borrow rate liquidityIndex uint256 The new liquidity index variableBorrowIndex uint256 The new variable borrow index"},{"location":"generated/solidity-api/#deposit_2","title":"deposit","text":"<pre><code>function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external\n</code></pre> <p>Deposits an <code>amount</code> of underlying asset into the reserve, receiving in return overlying aTokens. - E.g. User deposits 100 USDC and gets in return 100 aUSDC</p> Name Type Description asset address The address of the underlying asset to deposit amount uint256 The amount to be deposited onBehalfOf address The address that will receive the aTokens, same as msg.sender if the user   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens   is a different wallet referralCode uint16 Code used to register the integrator originating the operation, for potential rewards.   0 if the action is executed directly by the user, without any middle-man"},{"location":"generated/solidity-api/#withdraw_1","title":"withdraw","text":"<pre><code>function withdraw(address asset, uint256 amount, address to) external returns (uint256)\n</code></pre> <p>Withdraws an <code>amount</code> of underlying asset from the reserve, burning the equivalent aTokens owned E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC</p> Name Type Description asset address The address of the underlying asset to withdraw amount uint256 The underlying amount to be withdrawn   - Send the value type(uint256).max in order to withdraw the whole aToken balance to address Address that will receive the underlying, same as msg.sender if the user   wants to receive it on his own wallet, or a different address if the beneficiary is a   different wallet Name Type Description [0] uint256 The final amount withdrawn"},{"location":"generated/solidity-api/#borrow_2","title":"borrow","text":"<pre><code>function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf) external\n</code></pre> <p>Allows users to borrow a specific <code>amount</code> of the reserve underlying asset, provided that the borrower already deposited enough collateral, or he was given enough allowance by a credit delegator on the corresponding debt token (StableDebtToken or VariableDebtToken) - E.g. User borrows 100 USDC passing as <code>onBehalfOf</code> his own address, receiving the 100 USDC in his wallet   and 100 stable/variable debt tokens, depending on the <code>interestRateMode</code></p> Name Type Description asset address The address of the underlying asset to borrow amount uint256 The amount to be borrowed interestRateMode uint256 The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable referralCode uint16 Code used to register the integrator originating the operation, for potential rewards.   0 if the action is executed directly by the user, without any middle-man onBehalfOf address Address of the user who will receive the debt. Should be the address of the borrower itself calling the function if he wants to borrow against his own collateral, or the address of the credit delegator if he has been given credit delegation allowance"},{"location":"generated/solidity-api/#repay_2","title":"repay","text":"<pre><code>function repay(address asset, uint256 amount, uint256 rateMode, address onBehalfOf) external returns (uint256)\n</code></pre> <p>Repays a borrowed <code>amount</code> on a specific reserve, burning the equivalent debt tokens owned - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the <code>onBehalfOf</code> address</p> Name Type Description asset address The address of the borrowed underlying asset previously borrowed amount uint256 The amount to repay - Send the value type(uint256).max in order to repay the whole debt for <code>asset</code> on the specific <code>debtMode</code> rateMode uint256 The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable onBehalfOf address Address of the user who will get his debt reduced/removed. Should be the address of the user calling the function if he wants to reduce/remove his own debt, or the address of any other other borrower whose debt should be removed Name Type Description [0] uint256 The final amount repaid"},{"location":"generated/solidity-api/#swapborrowratemode","title":"swapBorrowRateMode","text":"<pre><code>function swapBorrowRateMode(address asset, uint256 rateMode) external\n</code></pre> <p>Allows a borrower to swap his debt between stable and variable mode, or viceversa</p> Name Type Description asset address The address of the underlying asset borrowed rateMode uint256 The rate mode that the user wants to swap to"},{"location":"generated/solidity-api/#rebalancestableborrowrate_1","title":"rebalanceStableBorrowRate","text":"<pre><code>function rebalanceStableBorrowRate(address asset, address user) external\n</code></pre> <p>Rebalances the stable interest rate of a user to the current stable rate defined on the reserve. - Users can be rebalanced if the following conditions are satisfied:     1. Usage ratio is above 95%     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been        borrowed at a stable rate and depositors are not earning enough</p> Name Type Description asset address The address of the underlying asset borrowed user address The address of the user to be rebalanced"},{"location":"generated/solidity-api/#setuserusereserveascollateral","title":"setUserUseReserveAsCollateral","text":"<pre><code>function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external\n</code></pre> <p>Allows depositors to enable/disable a specific deposited asset as collateral</p> Name Type Description asset address The address of the underlying asset deposited useAsCollateral bool <code>true</code> if the user wants to use the deposit as collateral, <code>false</code> otherwise"},{"location":"generated/solidity-api/#liquidationcall_1","title":"liquidationCall","text":"<pre><code>function liquidationCall(address collateralAsset, address debtAsset, address user, uint256 debtToCover, bool receiveAToken) external\n</code></pre> <p>Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1 - The caller (liquidator) covers <code>debtToCover</code> amount of debt of the user getting liquidated, and receives   a proportionally amount of the <code>collateralAsset</code> plus a bonus to cover market risk</p> Name Type Description collateralAsset address The address of the underlying asset used as collateral, to receive as result of the liquidation debtAsset address The address of the underlying borrowed asset to be repaid with the liquidation user address The address of the borrower getting liquidated debtToCover uint256 The debt amount of borrowed <code>asset</code> the liquidator wants to cover receiveAToken bool <code>true</code> if the liquidators wants to receive the collateral aTokens, <code>false</code> if he wants to receive the underlying collateral asset directly"},{"location":"generated/solidity-api/#flashloan_1","title":"flashLoan","text":"<pre><code>function flashLoan(address receiverAddress, address[] assets, uint256[] amounts, uint256[] modes, address onBehalfOf, bytes params, uint16 referralCode) external\n</code></pre> <p>Allows smartcontracts to access the liquidity of the pool within one transaction, as long as the amount taken plus a fee is returned. IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration. For further details please visit https://developers.aave.com</p> Name Type Description receiverAddress address The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface assets address[] The addresses of the assets being flash-borrowed amounts uint256[] The amounts amounts being flash-borrowed modes uint256[] Types of the debt to open if the flash loan is not returned:   0 -&gt; Don't open any debt, just revert if funds can't be transferred from the receiver   1 -&gt; Open debt at stable rate for the value of the amount flash-borrowed to the <code>onBehalfOf</code> address   2 -&gt; Open debt at variable rate for the value of the amount flash-borrowed to the <code>onBehalfOf</code> address onBehalfOf address The address  that will receive the debt in the case of using on <code>modes</code> 1 or 2 params bytes Variadic packed params to pass to the receiver as extra information referralCode uint16 Code used to register the integrator originating the operation, for potential rewards.   0 if the action is executed directly by the user, without any middle-man"},{"location":"generated/solidity-api/#getuseraccountdata","title":"getUserAccountData","text":"<pre><code>function getUserAccountData(address user) external view returns (uint256 totalCollateralETH, uint256 totalDebtETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor)\n</code></pre> <p>Returns the user account data across all the reserves</p> Name Type Description user address The address of the user Name Type Description totalCollateralETH uint256 the total collateral in ETH of the user totalDebtETH uint256 the total debt in ETH of the user availableBorrowsETH uint256 the borrowing power left of the user currentLiquidationThreshold uint256 the liquidation threshold of the user ltv uint256 the loan to value of the user healthFactor uint256 the current health factor of the user"},{"location":"generated/solidity-api/#initreserve","title":"initReserve","text":"<pre><code>function initReserve(address reserve, address aTokenAddress, address stableDebtAddress, address variableDebtAddress, address interestRateStrategyAddress) external\n</code></pre>"},{"location":"generated/solidity-api/#setreserveinterestratestrategyaddress","title":"setReserveInterestRateStrategyAddress","text":"<pre><code>function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external\n</code></pre>"},{"location":"generated/solidity-api/#setconfiguration","title":"setConfiguration","text":"<pre><code>function setConfiguration(address reserve, uint256 configuration) external\n</code></pre>"},{"location":"generated/solidity-api/#getconfiguration","title":"getConfiguration","text":"<pre><code>function getConfiguration(address asset) external view returns (struct DataTypes.ReserveConfigurationMap)\n</code></pre> <p>Returns the configuration of the reserve</p> Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] struct DataTypes.ReserveConfigurationMap The configuration of the reserve"},{"location":"generated/solidity-api/#getuserconfiguration","title":"getUserConfiguration","text":"<pre><code>function getUserConfiguration(address user) external view returns (struct DataTypes.UserConfigurationMap)\n</code></pre> <p>Returns the configuration of the user across all the reserves</p> Name Type Description user address The user address Name Type Description [0] struct DataTypes.UserConfigurationMap The configuration of the user"},{"location":"generated/solidity-api/#getreservenormalizedincome","title":"getReserveNormalizedIncome","text":"<pre><code>function getReserveNormalizedIncome(address asset) external view returns (uint256)\n</code></pre> <p>Returns the normalized income normalized income of the reserve</p> Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] uint256 The reserve's normalized income"},{"location":"generated/solidity-api/#getreservenormalizedvariabledebt","title":"getReserveNormalizedVariableDebt","text":"<pre><code>function getReserveNormalizedVariableDebt(address asset) external view returns (uint256)\n</code></pre> <p>Returns the normalized variable debt per unit of asset</p> Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] uint256 The reserve normalized variable debt"},{"location":"generated/solidity-api/#getreservedata_1","title":"getReserveData","text":"<pre><code>function getReserveData(address asset) external view returns (struct DataTypes.ReserveData)\n</code></pre> <p>Returns the state and configuration of the reserve</p> Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] struct DataTypes.ReserveData The state of the reserve"},{"location":"generated/solidity-api/#finalizetransfer","title":"finalizeTransfer","text":"<pre><code>function finalizeTransfer(address asset, address from, address to, uint256 amount, uint256 balanceFromAfter, uint256 balanceToBefore) external\n</code></pre>"},{"location":"generated/solidity-api/#getreserveslist","title":"getReservesList","text":"<pre><code>function getReservesList() external view returns (address[])\n</code></pre>"},{"location":"generated/solidity-api/#getaddressesprovider","title":"getAddressesProvider","text":"<pre><code>function getAddressesProvider() external view returns (contract ILendingPoolAddressesProvider)\n</code></pre>"},{"location":"generated/solidity-api/#setpause","title":"setPause","text":"<pre><code>function setPause(bool val) external\n</code></pre>"},{"location":"generated/solidity-api/#paused_1","title":"paused","text":"<pre><code>function paused() external view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#istabledebttoken","title":"IStableDebtToken","text":""},{"location":"generated/solidity-api/#mint_1","title":"Mint","text":"<pre><code>event Mint(address user, address onBehalfOf, uint256 amount, uint256 currentBalance, uint256 balanceIncrease, uint256 newRate, uint256 avgStableRate, uint256 newTotalSupply)\n</code></pre> <p>Emitted when new stable debt is minted</p> Name Type Description user address The address of the user who triggered the minting onBehalfOf address The recipient of stable debt tokens amount uint256 The amount minted currentBalance uint256 The current balance of the user balanceIncrease uint256 The increase in balance since the last action of the user newRate uint256 The rate of the debt after the minting avgStableRate uint256 The new average stable rate after the minting newTotalSupply uint256 The new total supply of the stable debt token after the action"},{"location":"generated/solidity-api/#burn","title":"Burn","text":"<pre><code>event Burn(address user, uint256 amount, uint256 currentBalance, uint256 balanceIncrease, uint256 avgStableRate, uint256 newTotalSupply)\n</code></pre> <p>Emitted when new stable debt is burned</p> Name Type Description user address The address of the user amount uint256 The amount being burned currentBalance uint256 The current balance of the user balanceIncrease uint256 The the increase in balance since the last action of the user avgStableRate uint256 The new average stable rate after the burning newTotalSupply uint256 The new total supply of the stable debt token after the action"},{"location":"generated/solidity-api/#approvedelegation","title":"approveDelegation","text":"<pre><code>function approveDelegation(address delegatee, uint256 amount) external\n</code></pre> <p>delegates borrowing power to a user on the specific debt token</p> Name Type Description delegatee address the address receiving the delegated borrowing power amount uint256 the maximum amount being delegated. Delegation will still respect the liquidation constraints (even if delegated, a delegatee cannot force a delegator HF to go below 1)"},{"location":"generated/solidity-api/#borrowallowance","title":"borrowAllowance","text":"<pre><code>function borrowAllowance(address fromUser, address toUser) external view returns (uint256)\n</code></pre> <p>returns the borrow allowance of the user</p> Name Type Description fromUser address The user to giving allowance toUser address The user to give allowance to Name Type Description [0] uint256 the current allowance of toUser"},{"location":"generated/solidity-api/#mint_2","title":"mint","text":"<pre><code>function mint(address user, address onBehalfOf, uint256 amount, uint256 rate) external returns (bool)\n</code></pre> <p>Mints debt token to the <code>onBehalfOf</code> address. - The resulting rate is the weighted average between the rate of the new debt and the rate of the previous debt</p> Name Type Description user address The address receiving the borrowed underlying, being the delegatee in case of credit delegate, or same as <code>onBehalfOf</code> otherwise onBehalfOf address The address receiving the debt tokens amount uint256 The amount of debt tokens to mint rate uint256 The rate of the debt being minted"},{"location":"generated/solidity-api/#burn_1","title":"burn","text":"<pre><code>function burn(address user, uint256 amount) external\n</code></pre> <p>Burns debt of <code>user</code> - The resulting rate is the weighted average between the rate of the new debt and the rate of the previous debt</p> Name Type Description user address The address of the user getting his debt burned amount uint256 The amount of debt tokens getting burned"},{"location":"generated/solidity-api/#getaveragestablerate","title":"getAverageStableRate","text":"<pre><code>function getAverageStableRate() external view returns (uint256)\n</code></pre> <p>Returns the average rate of all the stable rate loans.</p> Name Type Description [0] uint256 The average stable rate"},{"location":"generated/solidity-api/#getuserstablerate","title":"getUserStableRate","text":"<pre><code>function getUserStableRate(address user) external view returns (uint256)\n</code></pre> <p>Returns the stable rate of the user debt</p> Name Type Description [0] uint256 The stable rate of the user"},{"location":"generated/solidity-api/#getuserlastupdated","title":"getUserLastUpdated","text":"<pre><code>function getUserLastUpdated(address user) external view returns (uint40)\n</code></pre> <p>Returns the timestamp of the last update of the user</p> Name Type Description [0] uint40 The timestamp"},{"location":"generated/solidity-api/#getsupplydata","title":"getSupplyData","text":"<pre><code>function getSupplyData() external view returns (uint256, uint256, uint256, uint40)\n</code></pre> <p>Returns the principal, the total supply and the average stable rate</p>"},{"location":"generated/solidity-api/#gettotalsupplylastupdated","title":"getTotalSupplyLastUpdated","text":"<pre><code>function getTotalSupplyLastUpdated() external view returns (uint40)\n</code></pre> <p>Returns the timestamp of the last update of the total supply</p> Name Type Description [0] uint40 The timestamp"},{"location":"generated/solidity-api/#gettotalsupplyandavgrate","title":"getTotalSupplyAndAvgRate","text":"<pre><code>function getTotalSupplyAndAvgRate() external view returns (uint256, uint256)\n</code></pre> <p>Returns the total supply and the average stable rate</p>"},{"location":"generated/solidity-api/#principalbalanceof","title":"principalBalanceOf","text":"<pre><code>function principalBalanceOf(address user) external view returns (uint256)\n</code></pre> <p>Returns the principal debt balance of the user</p> Name Type Description [0] uint256 The debt balance of the user since the last burn/mint action"},{"location":"generated/solidity-api/#idynamicpricing","title":"IDynamicPricing","text":""},{"location":"generated/solidity-api/#dynamicpricingstate","title":"DynamicPricingState","text":"<pre><code>enum DynamicPricingState {\n  NotStarted,\n  Finished,\n  InProgress,\n  Aborted\n}\n</code></pre>"},{"location":"generated/solidity-api/#getpricingtype","title":"getPricingType","text":"<pre><code>function getPricingType() external view returns (bytes32)\n</code></pre>"},{"location":"generated/solidity-api/#getprice","title":"getPrice","text":"<pre><code>function getPrice(bytes32 did) external view returns (uint256)\n</code></pre>"},{"location":"generated/solidity-api/#gettokenaddress","title":"getTokenAddress","text":"<pre><code>function getTokenAddress(bytes32 did) external view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#getstatus","title":"getStatus","text":"<pre><code>function getStatus(bytes32 did) external view returns (enum IDynamicPricing.DynamicPricingState, uint256, address)\n</code></pre>"},{"location":"generated/solidity-api/#canbepurchased","title":"canBePurchased","text":"<pre><code>function canBePurchased(bytes32 did) external view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#withdraw_2","title":"withdraw","text":"<pre><code>function withdraw(bytes32 did, address withdrawAddress) external returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#ilist","title":"IList","text":""},{"location":"generated/solidity-api/#has_2","title":"has","text":"<pre><code>function has(bytes32 value) external view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#has_3","title":"has","text":"<pre><code>function has(bytes32 value, bytes32 id) external view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#iroyaltyscheme","title":"IRoyaltyScheme","text":""},{"location":"generated/solidity-api/#check","title":"check","text":"<pre><code>function check(bytes32 _did, uint256[] _amounts, address[] _receivers, address _tokenAddress) external view returns (bool)\n</code></pre> <p>check that royalties are correct</p> Name Type Description _did bytes32 compute royalties for this DID _amounts uint256[] amounts in payment _receivers address[] receivers of payments _tokenAddress address payment token. zero address means native token (ether)"},{"location":"generated/solidity-api/#isecretstore","title":"ISecretStore","text":""},{"location":"generated/solidity-api/#checkpermissions_2","title":"checkPermissions","text":"<pre><code>function checkPermissions(address user, bytes32 documentKeyId) external view returns (bool permissionGranted)\n</code></pre> <p>checkPermissions is called by Parity secret store</p>"},{"location":"generated/solidity-api/#isecretstorepermission","title":"ISecretStorePermission","text":""},{"location":"generated/solidity-api/#grantpermission_2","title":"grantPermission","text":"<pre><code>function grantPermission(address user, bytes32 documentKeyId) external\n</code></pre> <p>grantPermission is called only by documentKeyId Owner or provider</p>"},{"location":"generated/solidity-api/#renouncepermission_1","title":"renouncePermission","text":"<pre><code>function renouncePermission(address user, bytes32 documentKeyId) external\n</code></pre> <p>renouncePermission is called only by documentKeyId Owner or provider</p>"},{"location":"generated/solidity-api/#iwethgateway","title":"IWETHGateway","text":""},{"location":"generated/solidity-api/#depositeth","title":"depositETH","text":"<pre><code>function depositETH(address lendingPool, address onBehalfOf, uint16 referralCode) external payable\n</code></pre>"},{"location":"generated/solidity-api/#withdraweth","title":"withdrawETH","text":"<pre><code>function withdrawETH(address lendingPool, uint256 amount, address to) external\n</code></pre>"},{"location":"generated/solidity-api/#repayeth","title":"repayETH","text":"<pre><code>function repayETH(address lendingPool, uint256 amount, uint256 rateMode, address onBehalfOf) external payable\n</code></pre>"},{"location":"generated/solidity-api/#borroweth","title":"borrowETH","text":"<pre><code>function borrowETH(address lendingPool, uint256 amount, uint256 interesRateMode, uint16 referralCode) external\n</code></pre>"},{"location":"generated/solidity-api/#datatypes","title":"DataTypes","text":""},{"location":"generated/solidity-api/#reservedata","title":"ReserveData","text":"<pre><code>struct ReserveData {\n  struct DataTypes.ReserveConfigurationMap configuration;\n  uint128 liquidityIndex;\n  uint128 variableBorrowIndex;\n  uint128 currentLiquidityRate;\n  uint128 currentVariableBorrowRate;\n  uint128 currentStableBorrowRate;\n  uint40 lastUpdateTimestamp;\n  address aTokenAddress;\n  address stableDebtTokenAddress;\n  address variableDebtTokenAddress;\n  address interestRateStrategyAddress;\n  uint8 id;\n}\n</code></pre>"},{"location":"generated/solidity-api/#reserveconfigurationmap","title":"ReserveConfigurationMap","text":"<pre><code>struct ReserveConfigurationMap {\n  uint256 data;\n}\n</code></pre>"},{"location":"generated/solidity-api/#userconfigurationmap","title":"UserConfigurationMap","text":"<pre><code>struct UserConfigurationMap {\n  uint256 data;\n}\n</code></pre>"},{"location":"generated/solidity-api/#interestratemode","title":"InterestRateMode","text":"<pre><code>enum InterestRateMode {\n  NONE,\n  STABLE,\n  VARIABLE\n}\n</code></pre>"},{"location":"generated/solidity-api/#safemath","title":"SafeMath","text":""},{"location":"generated/solidity-api/#add_2","title":"add","text":"<pre><code>function add(uint256 a, uint256 b) internal pure returns (uint256)\n</code></pre> <p>_Returns the addition of two unsigned integers, reverting on overflow.</p> <p>Counterpart to Solidity's <code>+</code> operator.</p> <p>Requirements: - Addition cannot overflow._</p>"},{"location":"generated/solidity-api/#sub","title":"sub","text":"<pre><code>function sub(uint256 a, uint256 b) internal pure returns (uint256)\n</code></pre> <p>_Returns the subtraction of two unsigned integers, reverting on overflow (when the result is negative).</p> <p>Counterpart to Solidity's <code>-</code> operator.</p> <p>Requirements: - Subtraction cannot overflow._</p>"},{"location":"generated/solidity-api/#sub_1","title":"sub","text":"<pre><code>function sub(uint256 a, uint256 b, string errorMessage) internal pure returns (uint256)\n</code></pre> <p>_Returns the subtraction of two unsigned integers, reverting with custom message on overflow (when the result is negative).</p> <p>Counterpart to Solidity's <code>-</code> operator.</p> <p>Requirements: - Subtraction cannot overflow._</p>"},{"location":"generated/solidity-api/#mul","title":"mul","text":"<pre><code>function mul(uint256 a, uint256 b) internal pure returns (uint256)\n</code></pre> <p>_Returns the multiplication of two unsigned integers, reverting on overflow.</p> <p>Counterpart to Solidity's <code>*</code> operator.</p> <p>Requirements: - Multiplication cannot overflow._</p>"},{"location":"generated/solidity-api/#div","title":"div","text":"<pre><code>function div(uint256 a, uint256 b) internal pure returns (uint256)\n</code></pre> <p>_Returns the integer division of two unsigned integers. Reverts on division by zero. The result is rounded towards zero.</p> <p>Counterpart to Solidity's <code>/</code> operator. Note: this function uses a <code>revert</code> opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas).</p> <p>Requirements: - The divisor cannot be zero._</p>"},{"location":"generated/solidity-api/#div_1","title":"div","text":"<pre><code>function div(uint256 a, uint256 b, string errorMessage) internal pure returns (uint256)\n</code></pre> <p>_Returns the integer division of two unsigned integers. Reverts with custom message on division by zero. The result is rounded towards zero.</p> <p>Counterpart to Solidity's <code>/</code> operator. Note: this function uses a <code>revert</code> opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas).</p> <p>Requirements: - The divisor cannot be zero._</p>"},{"location":"generated/solidity-api/#mod","title":"mod","text":"<pre><code>function mod(uint256 a, uint256 b) internal pure returns (uint256)\n</code></pre> <p>_Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), Reverts when dividing by zero.</p> <p>Counterpart to Solidity's <code>%</code> operator. This function uses a <code>revert</code> opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas).</p> <p>Requirements: - The divisor cannot be zero._</p>"},{"location":"generated/solidity-api/#mod_1","title":"mod","text":"<pre><code>function mod(uint256 a, uint256 b, string errorMessage) internal pure returns (uint256)\n</code></pre> <p>_Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), Reverts with custom message when dividing by zero.</p> <p>Counterpart to Solidity's <code>%</code> operator. This function uses a <code>revert</code> opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas).</p> <p>Requirements: - The divisor cannot be zero._</p>"},{"location":"generated/solidity-api/#address","title":"Address","text":""},{"location":"generated/solidity-api/#iscontract_1","title":"isContract","text":"<pre><code>function isContract(address account) internal view returns (bool)\n</code></pre> <p>_Returns true if <code>account</code> is a contract.</p>"},{"location":"generated/solidity-api/#important","title":"[IMPORTANT]","text":"<p>It is unsafe to assume that an address for which this function returns false is an externally-owned account (EOA) and not a contract.</p> <p>Among others, <code>isContract</code> will return false for the following types of addresses:</p> <ul> <li>an externally-owned account</li> <li>a contract in construction</li> <li>an address where a contract will be created</li> <li>an address where a contract lived, but was destroyed ====_</li> </ul>"},{"location":"generated/solidity-api/#sendvalue","title":"sendValue","text":"<pre><code>function sendValue(address payable recipient, uint256 amount) internal\n</code></pre> <p>_Replacement for Solidity's <code>transfer</code>: sends <code>amount</code> wei to <code>recipient</code>, forwarding all available gas and reverting on errors.</p> <p>https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost of certain opcodes, possibly making contracts go over the 2300 gas limit imposed by <code>transfer</code>, making them unable to receive funds via <code>transfer</code>. {sendValue} removes this limitation.</p> <p>https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].</p> <p>IMPORTANT: because control is transferred to <code>recipient</code>, care must be taken to not create reentrancy vulnerabilities. Consider using {ReentrancyGuard} or the https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern]._</p>"},{"location":"generated/solidity-api/#safeerc20","title":"SafeERC20","text":"<p>Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a <code>using SafeERC20 for IERC20;</code> statement to your contract, which allows you to call the safe operations as <code>token.safeTransfer(...)</code>, etc.</p>"},{"location":"generated/solidity-api/#safetransfer","title":"safeTransfer","text":"<pre><code>function safeTransfer(contract IERC20 token, address to, uint256 value) internal\n</code></pre>"},{"location":"generated/solidity-api/#safetransferfrom","title":"safeTransferFrom","text":"<pre><code>function safeTransferFrom(contract IERC20 token, address from, address to, uint256 value) internal\n</code></pre>"},{"location":"generated/solidity-api/#safeapprove","title":"safeApprove","text":"<pre><code>function safeApprove(contract IERC20 token, address spender, uint256 value) internal\n</code></pre>"},{"location":"generated/solidity-api/#calloptionalreturn","title":"callOptionalReturn","text":"<pre><code>function callOptionalReturn(contract IERC20 token, bytes data) private\n</code></pre>"},{"location":"generated/solidity-api/#clonefactory","title":"CloneFactory","text":""},{"location":"generated/solidity-api/#createclone","title":"createClone","text":"<pre><code>function createClone(address target) internal returns (address result)\n</code></pre>"},{"location":"generated/solidity-api/#isclone","title":"isClone","text":"<pre><code>function isClone(address target, address query) internal view returns (bool result)\n</code></pre>"},{"location":"generated/solidity-api/#epochlibrary","title":"EpochLibrary","text":"<p>Implementation of Epoch Library.      For an arbitrary Epoch, this library manages the life      cycle of an Epoch. Usually this library is used for       handling the time window between conditions in an agreement.</p>"},{"location":"generated/solidity-api/#epoch","title":"Epoch","text":"<pre><code>struct Epoch {\n  uint256 timeLock;\n  uint256 timeOut;\n  uint256 blockNumber;\n}\n</code></pre>"},{"location":"generated/solidity-api/#epochlist_1","title":"EpochList","text":"<pre><code>struct EpochList {\n  mapping(bytes32 &amp;#x3D;&amp;gt; struct EpochLibrary.Epoch) epochs;\n  bytes32[] epochIds;\n}\n</code></pre>"},{"location":"generated/solidity-api/#create_2","title":"create","text":"<pre><code>function create(struct EpochLibrary.EpochList _self, bytes32 _id, uint256 _timeLock, uint256 _timeOut) internal\n</code></pre> <p>create creates new Epoch</p> Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 _timeLock uint256 value in block count (can not fulfill before) _timeOut uint256 value in block count (can not fulfill after)"},{"location":"generated/solidity-api/#istimedout","title":"isTimedOut","text":"<pre><code>function isTimedOut(struct EpochLibrary.EpochList _self, bytes32 _id) external view returns (bool)\n</code></pre> <p>isTimedOut means you cannot fulfill after</p> Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 Name Type Description [0] bool true if the current block number is gt timeOut"},{"location":"generated/solidity-api/#istimelocked","title":"isTimeLocked","text":"<pre><code>function isTimeLocked(struct EpochLibrary.EpochList _self, bytes32 _id) external view returns (bool)\n</code></pre> <p>isTimeLocked means you cannot fulfill before</p> Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 Name Type Description [0] bool true if the current block number is gt timeLock"},{"location":"generated/solidity-api/#getepochtimeout","title":"getEpochTimeOut","text":"<pre><code>function getEpochTimeOut(struct EpochLibrary.Epoch _self) public view returns (uint256)\n</code></pre> <p>getEpochTimeOut</p> Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer"},{"location":"generated/solidity-api/#getepochtimelock","title":"getEpochTimeLock","text":"<pre><code>function getEpochTimeLock(struct EpochLibrary.Epoch _self) public view returns (uint256)\n</code></pre> <p>getEpochTimeLock</p> Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer"},{"location":"generated/solidity-api/#hashlistlibrary","title":"HashListLibrary","text":"<p>Implementation of the basic functionality of list of hash values. This library allows other contracts to build and maintain lists and also preserves the privacy of the data by accepting only hashed  content (bytes32 based data type)</p>"},{"location":"generated/solidity-api/#list","title":"List","text":"<pre><code>struct List {\n  address _owner;\n  bytes32[] values;\n  mapping(bytes32 &amp;#x3D;&amp;gt; uint256) indices;\n}\n</code></pre>"},{"location":"generated/solidity-api/#onlylistowner","title":"onlyListOwner","text":"<pre><code>modifier onlyListOwner(struct HashListLibrary.List _self)\n</code></pre>"},{"location":"generated/solidity-api/#add_3","title":"add","text":"<pre><code>function add(struct HashListLibrary.List _self, bytes32 value) public returns (bool)\n</code></pre> <p>add index an element then add it to a list</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is a bytes32 value Name Type Description [0] bool true if value is added successfully"},{"location":"generated/solidity-api/#add_4","title":"add","text":"<pre><code>function add(struct HashListLibrary.List _self, bytes32[] values) public returns (bool)\n</code></pre> <p>put an array of elements without indexing      this meant to save gas in case of large arrays</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage values bytes32[] is an array of elements value Name Type Description [0] bool true if values are added successfully"},{"location":"generated/solidity-api/#update_1","title":"update","text":"<pre><code>function update(struct HashListLibrary.List _self, bytes32 oldValue, bytes32 newValue) public returns (bool)\n</code></pre> <p>update the value with a new value and maintain indices</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage oldValue bytes32 is an element value in a list newValue bytes32 new value Name Type Description [0] bool true if value is updated successfully"},{"location":"generated/solidity-api/#remove_1","title":"remove","text":"<pre><code>function remove(struct HashListLibrary.List _self, bytes32 value) public returns (bool)\n</code></pre> <p>remove value from a list, updates indices, and list size</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is an element value in a list Name Type Description [0] bool true if value is removed successfully"},{"location":"generated/solidity-api/#get_1","title":"get","text":"<pre><code>function get(struct HashListLibrary.List _self, uint256 __index) public view returns (bytes32)\n</code></pre> <p>has value by index</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage __index uint256 is where is value is stored in the list Name Type Description [0] bytes32 the value if exists"},{"location":"generated/solidity-api/#index_1","title":"index","text":"<pre><code>function index(struct HashListLibrary.List _self, uint256 from, uint256 to) public returns (bool)\n</code></pre> <p>index is used to map each element value to its index on the list</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Name Type Description [0] bool true if the sub list is indexed"},{"location":"generated/solidity-api/#setowner","title":"setOwner","text":"<pre><code>function setOwner(struct HashListLibrary.List _self, address _owner) public\n</code></pre> <p>setOwner set list owner param _owner owner address</p>"},{"location":"generated/solidity-api/#indexof_1","title":"indexOf","text":"<pre><code>function indexOf(struct HashListLibrary.List _self, bytes32 value) public view returns (uint256)\n</code></pre> <p>indexOf gets the index of a value in a list</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Name Type Description [0] uint256 value index in list"},{"location":"generated/solidity-api/#isindexed_1","title":"isIndexed","text":"<pre><code>function isIndexed(struct HashListLibrary.List _self) public view returns (bool)\n</code></pre> <p>isIndexed checks if the list is indexed</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] bool true if the list is indexed"},{"location":"generated/solidity-api/#all_1","title":"all","text":"<pre><code>function all(struct HashListLibrary.List _self) public view returns (bytes32[])\n</code></pre> <p>all returns all list elements</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] bytes32[] all list elements"},{"location":"generated/solidity-api/#has_4","title":"has","text":"<pre><code>function has(struct HashListLibrary.List _self, bytes32 value) public view returns (bool)\n</code></pre> <p>size returns the list size</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Name Type Description [0] bool true if the value exists"},{"location":"generated/solidity-api/#size_1","title":"size","text":"<pre><code>function size(struct HashListLibrary.List _self) public view returns (uint256)\n</code></pre> <p>size gets the list size</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] uint256 total length of the list"},{"location":"generated/solidity-api/#ownedby_1","title":"ownedBy","text":"<pre><code>function ownedBy(struct HashListLibrary.List _self) public view returns (address)\n</code></pre> <p>ownedBy gets the list owner</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] address list owner"},{"location":"generated/solidity-api/#_index","title":"_index","text":"<pre><code>function _index(struct HashListLibrary.List _self, uint256 from, uint256 to) private returns (bool)\n</code></pre> <p>__index assign index to the list elements_</p> Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 is the starting index id to uint256 is the ending index id"},{"location":"generated/solidity-api/#abstractauction","title":"AbstractAuction","text":""},{"location":"generated/solidity-api/#auction_manager_role","title":"AUCTION_MANAGER_ROLE","text":"<pre><code>bytes32 AUCTION_MANAGER_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#nvm_agreement_role","title":"NVM_AGREEMENT_ROLE","text":"<pre><code>bytes32 NVM_AGREEMENT_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#auction","title":"Auction","text":"<pre><code>struct Auction {\n  bytes32 did;\n  enum IDynamicPricing.DynamicPricingState state;\n  address creator;\n  uint256 blockNumberCreated;\n  uint256 floor;\n  uint256 starts;\n  uint256 ends;\n  uint256 price;\n  address tokenAddress;\n  address whoCanClaim;\n  string hash;\n}\n</code></pre>"},{"location":"generated/solidity-api/#auctions","title":"auctions","text":"<pre><code>mapping(bytes32 =&gt; struct AbstractAuction.Auction) auctions\n</code></pre>"},{"location":"generated/solidity-api/#auctionbids","title":"auctionBids","text":"<pre><code>mapping(bytes32 =&gt; mapping(address =&gt; uint256)) auctionBids\n</code></pre>"},{"location":"generated/solidity-api/#auctioncreated","title":"AuctionCreated","text":"<pre><code>event AuctionCreated(bytes32 auctionId, bytes32 did, address creator, uint256 blockNumberCreated, uint256 floor, uint256 starts, uint256 ends, address tokenAddress)\n</code></pre>"},{"location":"generated/solidity-api/#auctionchangedstate","title":"AuctionChangedState","text":"<pre><code>event AuctionChangedState(bytes32 auctionId, address who, enum IDynamicPricing.DynamicPricingState previousState, enum IDynamicPricing.DynamicPricingState newState)\n</code></pre>"},{"location":"generated/solidity-api/#auctionbidreceived","title":"AuctionBidReceived","text":"<pre><code>event AuctionBidReceived(bytes32 auctionId, address bidder, address tokenAddress, uint256 amount)\n</code></pre>"},{"location":"generated/solidity-api/#auctionwithdrawal","title":"AuctionWithdrawal","text":"<pre><code>event AuctionWithdrawal(bytes32 auctionId, address receiver, address tokenAddress, uint256 amount)\n</code></pre>"},{"location":"generated/solidity-api/#receive_3","title":"receive","text":"<pre><code>receive() external payable\n</code></pre>"},{"location":"generated/solidity-api/#abortauction","title":"abortAuction","text":"<pre><code>function abortAuction(bytes32 _auctionId) external virtual\n</code></pre>"},{"location":"generated/solidity-api/#withdraw_3","title":"withdraw","text":"<pre><code>function withdraw(bytes32 _auctionId, address _withdrawAddress) external virtual returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#getpricingtype_1","title":"getPricingType","text":"<pre><code>function getPricingType() external pure virtual returns (bytes32)\n</code></pre>"},{"location":"generated/solidity-api/#getprice_1","title":"getPrice","text":"<pre><code>function getPrice(bytes32 _auctionId) external view returns (uint256)\n</code></pre>"},{"location":"generated/solidity-api/#gettokenaddress_1","title":"getTokenAddress","text":"<pre><code>function getTokenAddress(bytes32 _auctionId) external view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#getstatus_1","title":"getStatus","text":"<pre><code>function getStatus(bytes32 _auctionId) external view returns (enum IDynamicPricing.DynamicPricingState state, uint256 price, address whoCanClaim)\n</code></pre>"},{"location":"generated/solidity-api/#canbepurchased_1","title":"canBePurchased","text":"<pre><code>function canBePurchased(bytes32 _auctionId) external view virtual returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#addnvmagreementrole","title":"addNVMAgreementRole","text":"<pre><code>function addNVMAgreementRole(address account) public\n</code></pre>"},{"location":"generated/solidity-api/#onlycreator","title":"onlyCreator","text":"<pre><code>modifier onlyCreator(bytes32 _auctionId)\n</code></pre>"},{"location":"generated/solidity-api/#onlycreatororadmin","title":"onlyCreatorOrAdmin","text":"<pre><code>modifier onlyCreatorOrAdmin(bytes32 _auctionId)\n</code></pre>"},{"location":"generated/solidity-api/#onlynotcreator","title":"onlyNotCreator","text":"<pre><code>modifier onlyNotCreator(bytes32 _auctionId)\n</code></pre>"},{"location":"generated/solidity-api/#onlyafterstart","title":"onlyAfterStart","text":"<pre><code>modifier onlyAfterStart(bytes32 _auctionId)\n</code></pre>"},{"location":"generated/solidity-api/#onlybeforestarts","title":"onlyBeforeStarts","text":"<pre><code>modifier onlyBeforeStarts(bytes32 _auctionId)\n</code></pre>"},{"location":"generated/solidity-api/#onlybeforeend","title":"onlyBeforeEnd","text":"<pre><code>modifier onlyBeforeEnd(bytes32 _auctionId)\n</code></pre>"},{"location":"generated/solidity-api/#onlynotabortedorfinished","title":"onlyNotAbortedOrFinished","text":"<pre><code>modifier onlyNotAbortedOrFinished(bytes32 _auctionId)\n</code></pre>"},{"location":"generated/solidity-api/#onlyabortedorfinished","title":"onlyAbortedOrFinished","text":"<pre><code>modifier onlyAbortedOrFinished(bytes32 _auctionId)\n</code></pre>"},{"location":"generated/solidity-api/#onlynotaborted","title":"onlyNotAborted","text":"<pre><code>modifier onlyNotAborted(bytes32 _auctionId)\n</code></pre>"},{"location":"generated/solidity-api/#onlyfinishedoraborted","title":"onlyFinishedOrAborted","text":"<pre><code>modifier onlyFinishedOrAborted(bytes32 _auctionId)\n</code></pre>"},{"location":"generated/solidity-api/#dutchauction","title":"DutchAuction","text":""},{"location":"generated/solidity-api/#initialize_32","title":"initialize","text":"<pre><code>function initialize(address _owner) external\n</code></pre> <p>initialize init the contract with the following parameters</p> Name Type Description _owner address contract's owner account address"},{"location":"generated/solidity-api/#create_3","title":"create","text":"<pre><code>function create(bytes32 _auctionId, bytes32 _did, uint256 _startPrice, uint256 _starts, uint256 _ends, address _tokenAddress, string _hash) external virtual\n</code></pre> <p>It creates a new Auction given some setup parameters</p> Name Type Description _auctionId bytes32 unique auction identifier _did bytes32 reference to the asset part of the auction _startPrice uint256 start price (and max) for the auction _starts uint256 block number when the auction starts _ends uint256 block number of when the auction ends _tokenAddress address token address to use for the auction. If address(0) means native token _hash string ipfs hash referring to the auction metadata"},{"location":"generated/solidity-api/#placenativetokenbid","title":"placeNativeTokenBid","text":"<pre><code>function placeNativeTokenBid(bytes32 _auctionId) external payable virtual\n</code></pre>"},{"location":"generated/solidity-api/#placeerc20bid","title":"placeERC20Bid","text":"<pre><code>function placeERC20Bid(bytes32 _auctionId, uint256 _bidAmount) external virtual\n</code></pre>"},{"location":"generated/solidity-api/#withdraw_4","title":"withdraw","text":"<pre><code>function withdraw(bytes32 _auctionId, address _withdrawAddress) external virtual returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#getpricingtype_2","title":"getPricingType","text":"<pre><code>function getPricingType() external pure returns (bytes32)\n</code></pre>"},{"location":"generated/solidity-api/#englishauction","title":"EnglishAuction","text":""},{"location":"generated/solidity-api/#initialize_33","title":"initialize","text":"<pre><code>function initialize(address _owner) external\n</code></pre> <p>initialize init the contract with the following parameters</p> Name Type Description _owner address contract's owner account address"},{"location":"generated/solidity-api/#create_4","title":"create","text":"<pre><code>function create(bytes32 _auctionId, bytes32 _did, uint256 _floor, uint256 _starts, uint256 _ends, address _tokenAddress, string _hash) external virtual\n</code></pre> <p>It creates a new Auction given some setup parameters</p> Name Type Description _auctionId bytes32 unique auction identifier _did bytes32 reference to the asset part of the auction _floor uint256 floor price _starts uint256 block number when the auction starts _ends uint256 block number of when the auction ends _tokenAddress address token address to use for the auction. If address(0) means native token _hash string ipfs hash referring to the auction metadata"},{"location":"generated/solidity-api/#placenativetokenbid_1","title":"placeNativeTokenBid","text":"<pre><code>function placeNativeTokenBid(bytes32 _auctionId) external payable virtual\n</code></pre>"},{"location":"generated/solidity-api/#placeerc20bid_1","title":"placeERC20Bid","text":"<pre><code>function placeERC20Bid(bytes32 _auctionId, uint256 _bidAmount) external virtual\n</code></pre>"},{"location":"generated/solidity-api/#getpricingtype_3","title":"getPricingType","text":"<pre><code>function getPricingType() external pure returns (bytes32)\n</code></pre>"},{"location":"generated/solidity-api/#didfactory","title":"DIDFactory","text":"<p>Implementation of the DID Registry.</p>"},{"location":"generated/solidity-api/#didregisterlist","title":"didRegisterList","text":"<pre><code>struct DIDRegistryLibrary.DIDRegisterList didRegisterList\n</code></pre> <p>state storage for the DID registry</p>"},{"location":"generated/solidity-api/#didpermissions","title":"didPermissions","text":"<pre><code>mapping(bytes32 =&gt; mapping(address =&gt; bool)) didPermissions\n</code></pre>"},{"location":"generated/solidity-api/#manager","title":"manager","text":"<pre><code>address manager\n</code></pre>"},{"location":"generated/solidity-api/#onlydidowner","title":"onlyDIDOwner","text":"<pre><code>modifier onlyDIDOwner(bytes32 _did)\n</code></pre>"},{"location":"generated/solidity-api/#onlymanager","title":"onlyManager","text":"<pre><code>modifier onlyManager()\n</code></pre>"},{"location":"generated/solidity-api/#onlyownerproviderordelegated","title":"onlyOwnerProviderOrDelegated","text":"<pre><code>modifier onlyOwnerProviderOrDelegated(bytes32 _did)\n</code></pre>"},{"location":"generated/solidity-api/#onlyvalidattributes","title":"onlyValidAttributes","text":"<pre><code>modifier onlyValidAttributes(string _attributes)\n</code></pre>"},{"location":"generated/solidity-api/#nftisinitialized","title":"nftIsInitialized","text":"<pre><code>modifier nftIsInitialized(bytes32 _did)\n</code></pre>"},{"location":"generated/solidity-api/#nft721isinitialized","title":"nft721IsInitialized","text":"<pre><code>modifier nft721IsInitialized(bytes32 _did)\n</code></pre>"},{"location":"generated/solidity-api/#didattributeregistered","title":"DIDAttributeRegistered","text":"<pre><code>event DIDAttributeRegistered(bytes32 _did, address _owner, bytes32 _checksum, string _value, address _lastUpdatedBy, uint256 _blockNumberUpdated)\n</code></pre> <p>DID Events</p>"},{"location":"generated/solidity-api/#didproviderremoved","title":"DIDProviderRemoved","text":"<pre><code>event DIDProviderRemoved(bytes32 _did, address _provider, bool state)\n</code></pre>"},{"location":"generated/solidity-api/#didprovideradded","title":"DIDProviderAdded","text":"<pre><code>event DIDProviderAdded(bytes32 _did, address _provider)\n</code></pre>"},{"location":"generated/solidity-api/#didownershiptransferred","title":"DIDOwnershipTransferred","text":"<pre><code>event DIDOwnershipTransferred(bytes32 _did, address _previousOwner, address _newOwner)\n</code></pre>"},{"location":"generated/solidity-api/#didpermissiongranted","title":"DIDPermissionGranted","text":"<pre><code>event DIDPermissionGranted(bytes32 _did, address _owner, address _grantee)\n</code></pre>"},{"location":"generated/solidity-api/#didpermissionrevoked","title":"DIDPermissionRevoked","text":"<pre><code>event DIDPermissionRevoked(bytes32 _did, address _owner, address _grantee)\n</code></pre>"},{"location":"generated/solidity-api/#didprovenancedelegateremoved","title":"DIDProvenanceDelegateRemoved","text":"<pre><code>event DIDProvenanceDelegateRemoved(bytes32 _did, address _delegate, bool state)\n</code></pre>"},{"location":"generated/solidity-api/#didprovenancedelegateadded","title":"DIDProvenanceDelegateAdded","text":"<pre><code>event DIDProvenanceDelegateAdded(bytes32 _did, address _delegate)\n</code></pre>"},{"location":"generated/solidity-api/#setmanager","title":"setManager","text":"<pre><code>function setManager(address _addr) external\n</code></pre> <p>Sets the manager role. Should be the TransferCondition contract address</p>"},{"location":"generated/solidity-api/#registerattribute","title":"registerAttribute","text":"<pre><code>function registerAttribute(bytes32 _didSeed, bytes32 _checksum, address[] _providers, string _url) public virtual\n</code></pre> <p>Register DID attributes.</p> <p>The first attribute of a DID registered sets the DID owner.      Subsequent updates record _checksum and update info.</p> Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] _url string refers to the attribute value, limited to 2048 bytes."},{"location":"generated/solidity-api/#registerdid","title":"registerDID","text":"<pre><code>function registerDID(bytes32 _didSeed, bytes32 _checksum, address[] _providers, string _url, bytes32 _activityId, string _attributes) public virtual\n</code></pre> <p>Register DID attributes.</p> <p>The first attribute of a DID registered sets the DID owner.      Subsequent updates record _checksum and update info.</p> Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID).           The final DID will be calculated with the creator address using the <code>hashDID</code> function _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _activityId bytes32 refers to activity _attributes string refers to the provenance attributes"},{"location":"generated/solidity-api/#hashdid","title":"hashDID","text":"<pre><code>function hashDID(bytes32 _didSeed, address _creator) public pure returns (bytes32)\n</code></pre> <p>It generates a DID using as seed a bytes32 and the address of the DID creator</p> Name Type Description _didSeed bytes32 refers to DID Seed used as base to generate the final DID _creator address address of the creator of the DID Name Type Description [0] bytes32 the new DID created"},{"location":"generated/solidity-api/#areroyaltiesvalid","title":"areRoyaltiesValid","text":"<pre><code>function areRoyaltiesValid(bytes32 _did, uint256[] _amounts, address[] _receivers, address _tokenAddress) public view returns (bool)\n</code></pre> <p>areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly</p> Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards _tokenAddress address Name Type Description [0] bool true if the rewards distribution respect the original creator royalties"},{"location":"generated/solidity-api/#wasgeneratedby","title":"wasGeneratedBy","text":"<pre><code>function wasGeneratedBy(bytes32 _provId, bytes32 _did, address _agentId, bytes32 _activityId, string _attributes) internal returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#used","title":"used","text":"<pre><code>function used(bytes32 _provId, bytes32 _did, address _agentId, bytes32 _activityId, bytes _signatureUsing, string _attributes) public returns (bool success)\n</code></pre>"},{"location":"generated/solidity-api/#wasderivedfrom","title":"wasDerivedFrom","text":"<pre><code>function wasDerivedFrom(bytes32 _provId, bytes32 _newEntityDid, bytes32 _usedEntityDid, address _agentId, bytes32 _activityId, string _attributes) public returns (bool success)\n</code></pre>"},{"location":"generated/solidity-api/#wasassociatedwith","title":"wasAssociatedWith","text":"<pre><code>function wasAssociatedWith(bytes32 _provId, bytes32 _did, address _agentId, bytes32 _activityId, string _attributes) public returns (bool success)\n</code></pre>"},{"location":"generated/solidity-api/#actedonbehalf","title":"actedOnBehalf","text":"<pre><code>function actedOnBehalf(bytes32 _provId, bytes32 _did, address _delegateAgentId, address _responsibleAgentId, bytes32 _activityId, bytes _signatureDelegate, string _attributes) public returns (bool success)\n</code></pre> <p>Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId &amp; _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId)</p> Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered"},{"location":"generated/solidity-api/#adddidprovider","title":"addDIDProvider","text":"<pre><code>function addDIDProvider(bytes32 _did, address _provider) external\n</code></pre> <p>addDIDProvider add new DID provider.</p> <p>it adds new DID provider to the providers list. A provider      is any entity that can serve the registered asset</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address."},{"location":"generated/solidity-api/#removedidprovider","title":"removeDIDProvider","text":"<pre><code>function removeDIDProvider(bytes32 _did, address _provider) external\n</code></pre> <p>removeDIDProvider delete an existing DID provider.</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address."},{"location":"generated/solidity-api/#adddidprovenancedelegate","title":"addDIDProvenanceDelegate","text":"<pre><code>function addDIDProvenanceDelegate(bytes32 _did, address _delegate) public\n</code></pre> <p>addDIDProvenanceDelegate add new DID provenance delegate.</p> <p>it adds new DID provenance delegate to the delegates list.  A delegate is any entity that interact with the provenance entries of one DID</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegates's address."},{"location":"generated/solidity-api/#removedidprovenancedelegate","title":"removeDIDProvenanceDelegate","text":"<pre><code>function removeDIDProvenanceDelegate(bytes32 _did, address _delegate) external\n</code></pre> <p>removeDIDProvenanceDelegate delete an existing DID delegate.</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address."},{"location":"generated/solidity-api/#transferdidownership","title":"transferDIDOwnership","text":"<pre><code>function transferDIDOwnership(bytes32 _did, address _newOwner) external\n</code></pre> <p>transferDIDOwnership transfer DID ownership</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address"},{"location":"generated/solidity-api/#transferdidownershipmanaged","title":"transferDIDOwnershipManaged","text":"<pre><code>function transferDIDOwnershipManaged(address _sender, bytes32 _did, address _newOwner) external\n</code></pre> <p>transferDIDOwnershipManaged transfer DID ownership</p> Name Type Description _sender address _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address"},{"location":"generated/solidity-api/#_transferdidownership","title":"_transferDIDOwnership","text":"<pre><code>function _transferDIDOwnership(address _sender, bytes32 _did, address _newOwner) internal\n</code></pre>"},{"location":"generated/solidity-api/#grantpermission_3","title":"grantPermission","text":"<pre><code>function grantPermission(bytes32 _did, address _grantee) external\n</code></pre> <p>grantPermission grants access permission to grantee</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address"},{"location":"generated/solidity-api/#revokepermission","title":"revokePermission","text":"<pre><code>function revokePermission(bytes32 _did, address _grantee) external\n</code></pre> <p>revokePermission revokes access permission from grantee</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address"},{"location":"generated/solidity-api/#getpermission","title":"getPermission","text":"<pre><code>function getPermission(bytes32 _did, address _grantee) external view returns (bool)\n</code></pre> <p>getPermission gets access permission of a grantee</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Name Type Description [0] bool true if grantee has access permission to a DID"},{"location":"generated/solidity-api/#isdidprovider","title":"isDIDProvider","text":"<pre><code>function isDIDProvider(bytes32 _did, address _provider) public view returns (bool)\n</code></pre> <p>isDIDProvider check whether a given DID provider exists</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address."},{"location":"generated/solidity-api/#isdidproviderorowner","title":"isDIDProviderOrOwner","text":"<pre><code>function isDIDProviderOrOwner(bytes32 _did, address _provider) public view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#getdidregister","title":"getDIDRegister","text":"<pre><code>function getDIDRegister(bytes32 _did) public view returns (address owner, bytes32 lastChecksum, string url, address lastUpdatedBy, uint256 blockNumberUpdated, address[] providers, uint256 nftSupply, uint256 mintCap, uint256 royalties)\n</code></pre> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description owner address the did owner lastChecksum bytes32 last checksum url string URL to the DID metadata lastUpdatedBy address who was the last updating the DID blockNumberUpdated uint256 In which block was the DID updated providers address[] the list of providers nftSupply uint256 the supply of nfts mintCap uint256 the maximum number of nfts that can be minted royalties uint256 the royalties amount"},{"location":"generated/solidity-api/#getdidsupply","title":"getDIDSupply","text":"<pre><code>function getDIDSupply(bytes32 _did) public view returns (uint256 nftSupply, uint256 mintCap)\n</code></pre>"},{"location":"generated/solidity-api/#getblocknumberupdated","title":"getBlockNumberUpdated","text":"<pre><code>function getBlockNumberUpdated(bytes32 _did) public view returns (uint256 blockNumberUpdated)\n</code></pre> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description blockNumberUpdated uint256 last modified (update) block number of a DID."},{"location":"generated/solidity-api/#getdidowner","title":"getDIDOwner","text":"<pre><code>function getDIDOwner(bytes32 _did) public view returns (address didOwner)\n</code></pre> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description didOwner address the address of the DID owner."},{"location":"generated/solidity-api/#getdidroyaltyrecipient","title":"getDIDRoyaltyRecipient","text":"<pre><code>function getDIDRoyaltyRecipient(bytes32 _did) public view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#getdidroyaltyscheme","title":"getDIDRoyaltyScheme","text":"<pre><code>function getDIDRoyaltyScheme(bytes32 _did) public view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#getdidcreator","title":"getDIDCreator","text":"<pre><code>function getDIDCreator(bytes32 _did) public view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#_grantpermission","title":"_grantPermission","text":"<pre><code>function _grantPermission(bytes32 _did, address _grantee) internal\n</code></pre> <p>__grantPermission grants access permission to grantee_</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address"},{"location":"generated/solidity-api/#_revokepermission","title":"_revokePermission","text":"<pre><code>function _revokePermission(bytes32 _did, address _grantee) internal\n</code></pre> <p>__revokePermission revokes access permission from grantee_</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address"},{"location":"generated/solidity-api/#_getpermission","title":"_getPermission","text":"<pre><code>function _getPermission(bytes32 _did, address _grantee) internal view returns (bool)\n</code></pre> <p>__getPermission gets access permission of a grantee_</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Name Type Description [0] bool true if grantee has access permission to a DID"},{"location":"generated/solidity-api/#getprovenanceentry","title":"getProvenanceEntry","text":"<pre><code>function getProvenanceEntry(bytes32 _provId) public view returns (bytes32 did, bytes32 relatedDid, address agentId, bytes32 activityId, address agentInvolvedId, uint8 method, address createdBy, uint256 blockNumberUpdated, bytes signature)\n</code></pre> <p>Fetch the complete provenance entry attributes</p> Name Type Description _provId bytes32 refers to the provenance identifier Name Type Description did bytes32 to what DID refers this entry relatedDid bytes32 DID related with the entry agentId address the agent identifier activityId bytes32 referring to the id of the activity agentInvolvedId address agent involved with the action method uint8 the w3c provenance method createdBy address who is creating this entry blockNumberUpdated uint256 in which block was updated signature bytes digital signature"},{"location":"generated/solidity-api/#isdidowner","title":"isDIDOwner","text":"<pre><code>function isDIDOwner(address _address, bytes32 _did) public view returns (bool)\n</code></pre> <p>isDIDOwner check whether a given address is owner for a DID</p> Name Type Description _address address user address. _did bytes32 refers to decentralized identifier (a bytes32 length ID)."},{"location":"generated/solidity-api/#isownerproviderordelegate","title":"isOwnerProviderOrDelegate","text":"<pre><code>function isOwnerProviderOrDelegate(bytes32 _did) public view returns (bool)\n</code></pre> <p>isOwnerProviderOrDelegate check whether msg.sender is owner, provider or delegate for a DID given</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description [0] bool boolean true if yes"},{"location":"generated/solidity-api/#isprovenancedelegate","title":"isProvenanceDelegate","text":"<pre><code>function isProvenanceDelegate(bytes32 _did, address _delegate) public view returns (bool)\n</code></pre> <p>isProvenanceDelegate check whether a given DID delegate exists</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address. Name Type Description [0] bool boolean true if yes"},{"location":"generated/solidity-api/#getprovenanceowner","title":"getProvenanceOwner","text":"<pre><code>function getProvenanceOwner(bytes32 _did) public view returns (address provenanceOwner)\n</code></pre> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description provenanceOwner address the address of the Provenance owner."},{"location":"generated/solidity-api/#didregistry_7","title":"DIDRegistry","text":"<p>Implementation of a Mintable DID Registry.</p>"},{"location":"generated/solidity-api/#erc1155_3","title":"erc1155","text":"<pre><code>contract NFTUpgradeable erc1155\n</code></pre>"},{"location":"generated/solidity-api/#erc721_1","title":"erc721","text":"<pre><code>contract NFT721Upgradeable erc721\n</code></pre>"},{"location":"generated/solidity-api/#royaltiescheckers","title":"royaltiesCheckers","text":"<pre><code>mapping(address =&gt; bool) royaltiesCheckers\n</code></pre>"},{"location":"generated/solidity-api/#initialize_34","title":"initialize","text":"<pre><code>function initialize(address _owner, address _erc1155, address _erc721) public\n</code></pre> <p>DIDRegistry Initializer      Initialize Ownable. Only on contract creation.</p> Name Type Description _owner address refers to the owner of the contract. _erc1155 address _erc721 address"},{"location":"generated/solidity-api/#registerroyaltieschecker","title":"registerRoyaltiesChecker","text":"<pre><code>function registerRoyaltiesChecker(address _addr) public\n</code></pre>"},{"location":"generated/solidity-api/#didroyaltiesadded","title":"DIDRoyaltiesAdded","text":"<pre><code>event DIDRoyaltiesAdded(bytes32 did, address addr)\n</code></pre>"},{"location":"generated/solidity-api/#didroyaltyrecipientchanged","title":"DIDRoyaltyRecipientChanged","text":"<pre><code>event DIDRoyaltyRecipientChanged(bytes32 did, address addr)\n</code></pre>"},{"location":"generated/solidity-api/#setdidroyalties","title":"setDIDRoyalties","text":"<pre><code>function setDIDRoyalties(bytes32 _did, address _royalties) public\n</code></pre>"},{"location":"generated/solidity-api/#setdidroyaltyrecipient","title":"setDIDRoyaltyRecipient","text":"<pre><code>function setDIDRoyaltyRecipient(bytes32 _did, address _recipient) public\n</code></pre>"},{"location":"generated/solidity-api/#registermintabledid","title":"registerMintableDID","text":"<pre><code>function registerMintableDID(bytes32 _didSeed, bytes32 _checksum, address[] _providers, string _url, uint256 _cap, uint8 _royalties, bool _mint, bytes32 _activityId, string _nftMetadata) public\n</code></pre> <p>Register a Mintable DID using NFTs based in the ERC-1155 standard.</p> <p>The first attribute of a DID registered sets the DID owner.      Subsequent updates record _checksum and update info.</p> Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if true it mints the ERC-1155 NFTs attached to the asset _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata"},{"location":"generated/solidity-api/#registermintabledid721","title":"registerMintableDID721","text":"<pre><code>function registerMintableDID721(bytes32 _didSeed, bytes32 _checksum, address[] _providers, string _url, uint8 _royalties, bool _mint, bytes32 _activityId, string _nftMetadata) public\n</code></pre> <p>Register a Mintable DID using NFTs based in the ERC-721 standard.</p> <p>The first attribute of a DID registered sets the DID owner.      Subsequent updates record _checksum and update info.</p> Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if true it mints the ERC-1155 NFTs attached to the asset _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata"},{"location":"generated/solidity-api/#registermintabledid_1","title":"registerMintableDID","text":"<pre><code>function registerMintableDID(bytes32 _didSeed, bytes32 _checksum, address[] _providers, string _url, uint256 _cap, uint8 _royalties, bytes32 _activityId, string _nftMetadata) public\n</code></pre> <p>Register a Mintable DID.</p> <p>The first attribute of a DID registered sets the DID owner.      Subsequent updates record _checksum and update info.</p> Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata"},{"location":"generated/solidity-api/#enableandmintdidnft","title":"enableAndMintDidNft","text":"<pre><code>function enableAndMintDidNft(bytes32 _did, uint256 _cap, uint8 _royalties, bool _mint, string _nftMetadata) public returns (bool success)\n</code></pre> <p>enableDidNft creates the initial setup of NFTs minting and royalties distribution for ERC-1155 NFTs. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the  valuation of NFTs of a DID already created.</p> <p>update the DID registry providers list by adding the mintCap and royalties configuration</p> Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if is true mint directly the amount capped tokens and lock in the _lockAddress _nftMetadata string refers to the url providing the NFT Metadata"},{"location":"generated/solidity-api/#enableandmintdidnft721","title":"enableAndMintDidNft721","text":"<pre><code>function enableAndMintDidNft721(bytes32 _did, uint8 _royalties, bool _mint, string _nftMetadata) public returns (bool success)\n</code></pre> <p>enableAndMintDidNft721 creates the initial setup of NFTs minting and royalties distribution for ERC-721 NFTs. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the  valuation of NFTs of a DID already created.</p> <p>update the DID registry providers list by adding the mintCap and royalties configuration</p> Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if is true mint directly the amount capped tokens and lock in the _lockAddress _nftMetadata string refers to the url providing the NFT Metadata"},{"location":"generated/solidity-api/#mint_3","title":"mint","text":"<pre><code>function mint(bytes32 _did, uint256 _amount, address _receiver) public\n</code></pre> <p>Mints a NFT associated to the DID</p> <p>Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both      Only the DID owner can mint NFTs associated to the DID</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to mint _receiver address the address that will receive the new nfts minted"},{"location":"generated/solidity-api/#mint_4","title":"mint","text":"<pre><code>function mint(bytes32 _did, uint256 _amount) public\n</code></pre>"},{"location":"generated/solidity-api/#mint721","title":"mint721","text":"<pre><code>function mint721(bytes32 _did, address _receiver) public\n</code></pre> <p>Mints a ERC-721 NFT associated to the DID</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _receiver address the address that will receive the new nfts minted"},{"location":"generated/solidity-api/#mint721_1","title":"mint721","text":"<pre><code>function mint721(bytes32 _did) public\n</code></pre>"},{"location":"generated/solidity-api/#burn_2","title":"burn","text":"<pre><code>function burn(bytes32 _did, uint256 _amount) public\n</code></pre> <p>Burns NFTs associated to the DID</p> <p>Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both      Only the DID owner can burn NFTs associated to the DID</p> Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to burn"},{"location":"generated/solidity-api/#burn721","title":"burn721","text":"<pre><code>function burn721(bytes32 _did) public\n</code></pre>"},{"location":"generated/solidity-api/#didregistrylibrary","title":"DIDRegistryLibrary","text":"<p>All function calls are currently implemented without side effects</p>"},{"location":"generated/solidity-api/#didregister","title":"DIDRegister","text":"<pre><code>struct DIDRegister {\n  address owner;\n  uint8 royalties;\n  bool nftInitialized;\n  bool nft721Initialized;\n  address creator;\n  bytes32 lastChecksum;\n  string url;\n  address lastUpdatedBy;\n  uint256 blockNumberUpdated;\n  address[] providers;\n  address[] delegates;\n  uint256 nftSupply;\n  uint256 mintCap;\n  address royaltyRecipient;\n  contract IRoyaltyScheme royaltyScheme;\n}\n</code></pre>"},{"location":"generated/solidity-api/#didregisterlist_1","title":"DIDRegisterList","text":"<pre><code>struct DIDRegisterList {\n  mapping(bytes32 &amp;#x3D;&amp;gt; struct DIDRegistryLibrary.DIDRegister) didRegisters;\n  bytes32[] didRegisterIds;\n}\n</code></pre>"},{"location":"generated/solidity-api/#update_2","title":"update","text":"<pre><code>function update(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, bytes32 _checksum, string _url) external\n</code></pre> <p>update the DID store</p> <p>access modifiers and storage pointer should be implemented in DIDRegistry</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url string includes the url resolving to the DID Document (DDO)"},{"location":"generated/solidity-api/#initializenftconfig","title":"initializeNftConfig","text":"<pre><code>function initializeNftConfig(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, uint256 _cap, uint8 _royalties) internal\n</code></pre> <p>initializeNftConfig creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the  valuation of NFTs of a DID already created.</p> <p>update the DID registry providers list by adding the mintCap and royalties configuration</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market        The royalties in secondary market for the creator should be between 0% &gt;= x &lt; 100%"},{"location":"generated/solidity-api/#initializenft721config","title":"initializeNft721Config","text":"<pre><code>function initializeNft721Config(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, uint8 _royalties) internal\n</code></pre>"},{"location":"generated/solidity-api/#areroyaltiesvalid_1","title":"areRoyaltiesValid","text":"<pre><code>function areRoyaltiesValid(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, uint256[] _amounts, address[] _receivers, address _tokenAddress) internal view returns (bool)\n</code></pre> <p>areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards _tokenAddress address Name Type Description [0] bool true if the rewards distribution respect the original creator royalties"},{"location":"generated/solidity-api/#addprovider","title":"addProvider","text":"<pre><code>function addProvider(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address provider) internal\n</code></pre> <p>addProvider add provider to DID registry</p> <p>update the DID registry providers list by adding a new provider</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address"},{"location":"generated/solidity-api/#removeprovider","title":"removeProvider","text":"<pre><code>function removeProvider(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address _provider) internal returns (bool)\n</code></pre> <p>removeProvider remove provider from DID registry</p> <p>update the DID registry providers list by removing an existing provider</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address"},{"location":"generated/solidity-api/#updatedidowner","title":"updateDIDOwner","text":"<pre><code>function updateDIDOwner(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address _newOwner) internal\n</code></pre> <p>updateDIDOwner transfer DID ownership to a new owner</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _newOwner address the new DID owner address"},{"location":"generated/solidity-api/#isprovider","title":"isProvider","text":"<pre><code>function isProvider(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address _provider) public view returns (bool)\n</code></pre> <p>isProvider check whether DID provider exists</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address Name Type Description [0] bool true if the provider already exists"},{"location":"generated/solidity-api/#getproviderindex","title":"getProviderIndex","text":"<pre><code>function getProviderIndex(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address provider) private view returns (int256)\n</code></pre> <p>getProviderIndex get the index of a provider</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address Name Type Description [0] int256 the index if the provider exists otherwise return -1"},{"location":"generated/solidity-api/#adddelegate","title":"addDelegate","text":"<pre><code>function addDelegate(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address delegate) internal\n</code></pre> <p>addDelegate add delegate to DID registry</p> <p>update the DID registry delegates list by adding a new delegate</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address"},{"location":"generated/solidity-api/#removedelegate","title":"removeDelegate","text":"<pre><code>function removeDelegate(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address _delegate) internal returns (bool)\n</code></pre> <p>removeDelegate remove delegate from DID registry</p> <p>update the DID registry delegates list by removing an existing delegate</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address"},{"location":"generated/solidity-api/#isdelegate","title":"isDelegate","text":"<pre><code>function isDelegate(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address _delegate) public view returns (bool)\n</code></pre> <p>isDelegate check whether DID delegate exists</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address Name Type Description [0] bool true if the delegate already exists"},{"location":"generated/solidity-api/#getdelegateindex","title":"getDelegateIndex","text":"<pre><code>function getDelegateIndex(struct DIDRegistryLibrary.DIDRegisterList _self, bytes32 _did, address delegate) private view returns (int256)\n</code></pre> <p>getDelegateIndex get the index of a delegate</p> Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address Name Type Description [0] int256 the index if the delegate exists otherwise return -1"},{"location":"generated/solidity-api/#provenanceregistry","title":"ProvenanceRegistry","text":"<p>All function calls are currently implemented without side effects</p>"},{"location":"generated/solidity-api/#__provenanceregistry_init","title":"__ProvenanceRegistry_init","text":"<pre><code>function __ProvenanceRegistry_init() internal\n</code></pre>"},{"location":"generated/solidity-api/#__provenanceregistry_init_unchained","title":"__ProvenanceRegistry_init_unchained","text":"<pre><code>function __ProvenanceRegistry_init_unchained() internal\n</code></pre>"},{"location":"generated/solidity-api/#provenance","title":"Provenance","text":"<pre><code>struct Provenance {\n  bytes32 did;\n  bytes32 relatedDid;\n  address agentId;\n  bytes32 activityId;\n  address agentInvolvedId;\n  uint8 method;\n  address createdBy;\n  uint256 blockNumberUpdated;\n  bytes signature;\n}\n</code></pre>"},{"location":"generated/solidity-api/#provenanceregistrylist","title":"ProvenanceRegistryList","text":"<pre><code>struct ProvenanceRegistryList {\n  mapping(bytes32 &amp;#x3D;&amp;gt; struct ProvenanceRegistry.Provenance) list;\n}\n</code></pre>"},{"location":"generated/solidity-api/#provenanceregistry_1","title":"provenanceRegistry","text":"<pre><code>struct ProvenanceRegistry.ProvenanceRegistryList provenanceRegistry\n</code></pre>"},{"location":"generated/solidity-api/#provenancemethod","title":"ProvenanceMethod","text":"<pre><code>enum ProvenanceMethod {\n  ENTITY,\n  ACTIVITY,\n  WAS_GENERATED_BY,\n  USED,\n  WAS_INFORMED_BY,\n  WAS_STARTED_BY,\n  WAS_ENDED_BY,\n  WAS_INVALIDATED_BY,\n  WAS_DERIVED_FROM,\n  AGENT,\n  WAS_ATTRIBUTED_TO,\n  WAS_ASSOCIATED_WITH,\n  ACTED_ON_BEHALF\n}\n</code></pre>"},{"location":"generated/solidity-api/#provenanceattributeregistered","title":"ProvenanceAttributeRegistered","text":"<pre><code>event ProvenanceAttributeRegistered(bytes32 provId, bytes32 _did, address _agentId, bytes32 _activityId, bytes32 _relatedDid, address _agentInvolvedId, enum ProvenanceRegistry.ProvenanceMethod _method, string _attributes, uint256 _blockNumberUpdated)\n</code></pre> <p>Provenance Events</p>"},{"location":"generated/solidity-api/#wasgeneratedby_1","title":"WasGeneratedBy","text":"<pre><code>event WasGeneratedBy(bytes32 _did, address _agentId, bytes32 _activityId, bytes32 provId, string _attributes, uint256 _blockNumberUpdated)\n</code></pre>"},{"location":"generated/solidity-api/#used_1","title":"Used","text":"<pre><code>event Used(bytes32 _did, address _agentId, bytes32 _activityId, bytes32 provId, string _attributes, uint256 _blockNumberUpdated)\n</code></pre>"},{"location":"generated/solidity-api/#wasderivedfrom_1","title":"WasDerivedFrom","text":"<pre><code>event WasDerivedFrom(bytes32 _newEntityDid, bytes32 _usedEntityDid, address _agentId, bytes32 _activityId, bytes32 provId, string _attributes, uint256 _blockNumberUpdated)\n</code></pre>"},{"location":"generated/solidity-api/#wasassociatedwith_1","title":"WasAssociatedWith","text":"<pre><code>event WasAssociatedWith(bytes32 _entityDid, address _agentId, bytes32 _activityId, bytes32 provId, string _attributes, uint256 _blockNumberUpdated)\n</code></pre>"},{"location":"generated/solidity-api/#actedonbehalf_1","title":"ActedOnBehalf","text":"<pre><code>event ActedOnBehalf(bytes32 _entityDid, address _delegateAgentId, address _responsibleAgentId, bytes32 _activityId, bytes32 provId, string _attributes, uint256 _blockNumberUpdated)\n</code></pre>"},{"location":"generated/solidity-api/#createprovenanceentry","title":"createProvenanceEntry","text":"<pre><code>function createProvenanceEntry(bytes32 _provId, bytes32 _did, bytes32 _relatedDid, address _agentId, bytes32 _activityId, address _agentInvolvedId, enum ProvenanceRegistry.ProvenanceMethod _method, address _createdBy, bytes _signatureDelegate, string _attributes) internal returns (bool)\n</code></pre> <p>create an event in the Provenance store</p> <p>access modifiers and storage pointer should be implemented in ProvenanceRegistry</p> Name Type Description _provId bytes32 refers to provenance event identifier _did bytes32 refers to decentralized identifier (a byte32 length ID) _relatedDid bytes32 refers to decentralized identifier (a byte32 length ID) of a related entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _agentInvolvedId address refers to address of the agent involved with the provenance record _method enum ProvenanceRegistry.ProvenanceMethod refers to the W3C Provenance method _createdBy address refers to address of the agent triggering the activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string"},{"location":"generated/solidity-api/#_wasgeneratedby","title":"_wasGeneratedBy","text":"<pre><code>function _wasGeneratedBy(bytes32 _provId, bytes32 _did, address _agentId, bytes32 _activityId, string _attributes) internal virtual returns (bool)\n</code></pre> <p>Implements the W3C PROV Generation action</p> Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description [0] bool the number of the new provenance size"},{"location":"generated/solidity-api/#_used","title":"_used","text":"<pre><code>function _used(bytes32 _provId, bytes32 _did, address _agentId, bytes32 _activityId, bytes _signatureUsing, string _attributes) internal virtual returns (bool success)\n</code></pre> <p>Implements the W3C PROV Usage action</p> Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _signatureUsing bytes refers to the digital signature provided by the agent using the _did _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered"},{"location":"generated/solidity-api/#_wasderivedfrom","title":"_wasDerivedFrom","text":"<pre><code>function _wasDerivedFrom(bytes32 _provId, bytes32 _newEntityDid, bytes32 _usedEntityDid, address _agentId, bytes32 _activityId, string _attributes) internal virtual returns (bool success)\n</code></pre> <p>Implements the W3C PROV Derivation action</p> Name Type Description _provId bytes32 unique identifier referring to the provenance entry _newEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _usedEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity used to derive the new did _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered"},{"location":"generated/solidity-api/#_wasassociatedwith","title":"_wasAssociatedWith","text":"<pre><code>function _wasAssociatedWith(bytes32 _provId, bytes32 _did, address _agentId, bytes32 _activityId, string _attributes) internal virtual returns (bool success)\n</code></pre> <p>Implements the W3C PROV Association action</p> Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered"},{"location":"generated/solidity-api/#_actedonbehalf","title":"_actedOnBehalf","text":"<pre><code>function _actedOnBehalf(bytes32 _provId, bytes32 _did, address _delegateAgentId, address _responsibleAgentId, bytes32 _activityId, bytes _signatureDelegate, string _attributes) internal virtual returns (bool success)\n</code></pre> <p>Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId &amp; _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId)</p> Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered"},{"location":"generated/solidity-api/#curveroyalties","title":"CurveRoyalties","text":""},{"location":"generated/solidity-api/#registry","title":"registry","text":"<pre><code>contract DIDRegistry registry\n</code></pre>"},{"location":"generated/solidity-api/#denominator","title":"DENOMINATOR","text":"<pre><code>uint256 DENOMINATOR\n</code></pre>"},{"location":"generated/solidity-api/#royalties","title":"royalties","text":"<pre><code>mapping(bytes32 =&gt; uint256) royalties\n</code></pre>"},{"location":"generated/solidity-api/#initialize_35","title":"initialize","text":"<pre><code>function initialize(address _registry) public\n</code></pre>"},{"location":"generated/solidity-api/#royaltycurve","title":"royaltyCurve","text":"<pre><code>function royaltyCurve(uint256 num, uint256 max, uint256 rate) public pure virtual returns (uint256)\n</code></pre>"},{"location":"generated/solidity-api/#setroyalty","title":"setRoyalty","text":"<pre><code>function setRoyalty(bytes32 _did, uint256 _royalty) public\n</code></pre> <p>Set royalties for a DID</p> <p>Can only be called by creator of the DID</p> Name Type Description _did bytes32 DID for which the royalties are set _royalty uint256 Royalty, the actual royalty will be _royalty / 10000 percent"},{"location":"generated/solidity-api/#check_1","title":"check","text":"<pre><code>function check(bytes32 _did, uint256[] _amounts, address[] _receivers, address _token) external view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#rewardsdistributor","title":"RewardsDistributor","text":""},{"location":"generated/solidity-api/#used_2","title":"used","text":"<pre><code>mapping(bytes32 =&gt; bool) used\n</code></pre>"},{"location":"generated/solidity-api/#receivers","title":"receivers","text":"<pre><code>mapping(bytes32 =&gt; address[]) receivers\n</code></pre>"},{"location":"generated/solidity-api/#registry_1","title":"registry","text":"<pre><code>contract DIDRegistry registry\n</code></pre>"},{"location":"generated/solidity-api/#conditionstoremanager_3","title":"conditionStoreManager","text":"<pre><code>contract ConditionStoreManager conditionStoreManager\n</code></pre>"},{"location":"generated/solidity-api/#escrow","title":"escrow","text":"<pre><code>address escrow\n</code></pre>"},{"location":"generated/solidity-api/#initialize_36","title":"initialize","text":"<pre><code>function initialize(address _registry, address _conditionStoreManager, address _escrow) public\n</code></pre>"},{"location":"generated/solidity-api/#setreceivers","title":"setReceivers","text":"<pre><code>function setReceivers(bytes32 _did, address[] _addr) public\n</code></pre> <p>set receivers for did</p> Name Type Description _did bytes32 DID _addr address[] list of receivers"},{"location":"generated/solidity-api/#claimreward","title":"claimReward","text":"<pre><code>function claimReward(bytes32 _agreementId, bytes32 _did, uint256[] _amounts, address[] _receivers, address _returnAddress, address _lockPaymentAddress, address _tokenAddress, bytes32 _lockCondition, bytes32[] _releaseConditions) public\n</code></pre> <p>distribute rewards associated with an escrow condition</p> <p>as paramemeters, it just gets the same parameters as fulfill for escrow condition</p> Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier"},{"location":"generated/solidity-api/#standardroyalties","title":"StandardRoyalties","text":""},{"location":"generated/solidity-api/#registry_2","title":"registry","text":"<pre><code>contract DIDRegistry registry\n</code></pre>"},{"location":"generated/solidity-api/#denominator_1","title":"DENOMINATOR","text":"<pre><code>uint256 DENOMINATOR\n</code></pre>"},{"location":"generated/solidity-api/#royalties_1","title":"royalties","text":"<pre><code>mapping(bytes32 =&gt; uint256) royalties\n</code></pre>"},{"location":"generated/solidity-api/#initialize_37","title":"initialize","text":"<pre><code>function initialize(address _registry) public\n</code></pre>"},{"location":"generated/solidity-api/#setroyalty_1","title":"setRoyalty","text":"<pre><code>function setRoyalty(bytes32 _did, uint256 _royalty) public\n</code></pre> <p>Set royalties for a DID</p> <p>Can only be called by creator of the DID</p> Name Type Description _did bytes32 DID for which the royalties are set _royalty uint256 Royalty, the actual royalty will be _royalty / 10000 percent"},{"location":"generated/solidity-api/#check_2","title":"check","text":"<pre><code>function check(bytes32 _did, uint256[] _amounts, address[] _receivers, address) external view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#aavecredittemplate","title":"AaveCreditTemplate","text":"<p>Implementation of the Aaven Credit Agreement Template  0. Initialize the agreement  1. LockNFT - Delegatee locks the NFT  2. AaveCollateralDeposit - Delegator deposits the collateral into Aave. And approves the delegation flow  3. AaveBorrowCondition - The Delegatee claim the credit amount from Aave  4. AaveRepayCondition. Options:      4.a Fulfilled state - The Delegatee pay back the loan (including fee) into Aave and gets back the NFT      4.b Aborted state - The Delegatee doesn't pay the loan in time so the Delegator gets the NFT. The Delegator pays the loan to Aave  5. TransferNFT. Options:      5.a if AaveRepayCondition was fulfilled, it will allow transfer back to the Delegatee or Borrower      5.b if AaveRepayCondition was aborted, it will allow transfer the NFT to the Delegator or Lender</p>"},{"location":"generated/solidity-api/#didregistry_8","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#nftlockcondition_1","title":"nftLockCondition","text":"<pre><code>contract INFTLock nftLockCondition\n</code></pre>"},{"location":"generated/solidity-api/#depositcondition","title":"depositCondition","text":"<pre><code>contract AaveCollateralDepositCondition depositCondition\n</code></pre>"},{"location":"generated/solidity-api/#borrowcondition","title":"borrowCondition","text":"<pre><code>contract AaveBorrowCondition borrowCondition\n</code></pre>"},{"location":"generated/solidity-api/#repaycondition","title":"repayCondition","text":"<pre><code>contract AaveRepayCondition repayCondition\n</code></pre>"},{"location":"generated/solidity-api/#transfercondition","title":"transferCondition","text":"<pre><code>contract DistributeNFTCollateralCondition transferCondition\n</code></pre>"},{"location":"generated/solidity-api/#withdrawcondition","title":"withdrawCondition","text":"<pre><code>contract AaveCollateralWithdrawCondition withdrawCondition\n</code></pre>"},{"location":"generated/solidity-api/#vaultaddress","title":"vaultAddress","text":"<pre><code>mapping(bytes32 =&gt; address) vaultAddress\n</code></pre>"},{"location":"generated/solidity-api/#nvmfee_1","title":"nvmFee","text":"<pre><code>uint256 nvmFee\n</code></pre>"},{"location":"generated/solidity-api/#vaultlibrary","title":"vaultLibrary","text":"<pre><code>address vaultLibrary\n</code></pre>"},{"location":"generated/solidity-api/#vaultcreated","title":"VaultCreated","text":"<pre><code>event VaultCreated(address _vaultAddress, address _creator, address _lender, address _borrower)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_38","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _nftLockConditionAddress, address _depositConditionAddress, address _borrowConditionAddress, address _repayConditionAddress, address _withdrawCollateralAddress, address _transferConditionAddress, address _vaultLibrary) external\n</code></pre> <p>initialize init the  contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and       set push the required condition types including       access , lock payment and escrow payment conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftLockConditionAddress address NFT Lock Condition contract address _depositConditionAddress address Aave collateral deposit Condition address _borrowConditionAddress address Aave borrow deposit Condition address _repayConditionAddress address Aave repay credit Condition address _withdrawCollateralAddress address _transferConditionAddress address NFT Transfer Condition address _vaultLibrary address"},{"location":"generated/solidity-api/#createvaultagreement","title":"createVaultAgreement","text":"<pre><code>function createVaultAgreement(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address _vaultAddress) public\n</code></pre>"},{"location":"generated/solidity-api/#createagreement_1","title":"createAgreement","text":"<pre><code>function createAgreement(bytes32 _id, address _lendingPool, address _dataProvider, address _weth, uint256 _agreementFee, address _treasuryAddress, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address _lender) public\n</code></pre>"},{"location":"generated/solidity-api/#deployvault","title":"deployVault","text":"<pre><code>function deployVault(address _lendingPool, address _dataProvider, address _weth, uint256 _agreementFee, address _treasuryAddress, address _borrower, address _lender) public returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#getvaultforagreement","title":"getVaultForAgreement","text":"<pre><code>function getVaultForAgreement(bytes32 _agreementId) public view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#updatenvmfee","title":"updateNVMFee","text":"<pre><code>function updateNVMFee(uint256 _newFee) public\n</code></pre> <p>Updates the nevermined fee for this type of agreement</p> Name Type Description _newFee uint256 New nevermined fee expressed in basis points"},{"location":"generated/solidity-api/#changecreditvaultlibrary","title":"changeCreditVaultLibrary","text":"<pre><code>function changeCreditVaultLibrary(address _vaultLibrary) public\n</code></pre>"},{"location":"generated/solidity-api/#accessprooftemplate","title":"AccessProofTemplate","text":"<p>Implementation of Access Agreement Template</p>"},{"location":"generated/solidity-api/#didregistry_9","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#accesscondition_1","title":"accessCondition","text":"<pre><code>contract AccessProofCondition accessCondition\n</code></pre>"},{"location":"generated/solidity-api/#lockcondition","title":"lockCondition","text":"<pre><code>contract LockPaymentCondition lockCondition\n</code></pre>"},{"location":"generated/solidity-api/#escrowreward","title":"escrowReward","text":"<pre><code>contract EscrowPaymentCondition escrowReward\n</code></pre>"},{"location":"generated/solidity-api/#initialize_39","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _didRegistryAddress, address _accessConditionAddress, address _lockConditionAddress, address payable _escrowConditionAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access , lock payment and escrow payment conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address"},{"location":"generated/solidity-api/#accesstemplate","title":"AccessTemplate","text":"<p>_Implementation of Access Agreement Template</p> <pre><code> Access template is use case specific template.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an on-chain SEA. The template is a composite of three basic\n conditions. Once the agreement is created, the consumer will lock an amount\n of tokens (as listed in the DID document - off-chain metadata) to the \n the lock reward contract which in turn will fire an event. ON the other hand \n the provider is listening to all the emitted events, the provider \n will catch the event and grant permissions to the consumer through \n secret store contract, the consumer now is able to download the data set\n by asking the off-chain component of secret store to decrypt the DID and \n encrypt it using the consumer's public key. Then the secret store will \n provide an on-chain proof that the consumer had access to the data set.\n Finally, the provider can call the escrow reward condition in order \n to release the payment. Every condition has a time window (time lock and \n time out). This implies that if the provider didn't grant the access to \n the consumer through secret store within this time window, the consumer \n can ask for refund._\n</code></pre>"},{"location":"generated/solidity-api/#didregistry_10","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#accesscondition_2","title":"accessCondition","text":"<pre><code>contract AccessCondition accessCondition\n</code></pre>"},{"location":"generated/solidity-api/#lockcondition_1","title":"lockCondition","text":"<pre><code>contract LockPaymentCondition lockCondition\n</code></pre>"},{"location":"generated/solidity-api/#escrowreward_1","title":"escrowReward","text":"<pre><code>contract EscrowPaymentCondition escrowReward\n</code></pre>"},{"location":"generated/solidity-api/#initialize_40","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _didRegistryAddress, address _accessConditionAddress, address _lockConditionAddress, address payable _escrowConditionAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access , lock payment and escrow payment conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address"},{"location":"generated/solidity-api/#agreementtemplate","title":"AgreementTemplate","text":"<p>_Implementation of Agreement Template</p> <pre><code> Agreement template is a reference template where it\n has the ability to create agreements from whitelisted \n template_\n</code></pre>"},{"location":"generated/solidity-api/#conditiontypes","title":"conditionTypes","text":"<pre><code>address[] conditionTypes\n</code></pre>"},{"location":"generated/solidity-api/#agreementstoremanager_4","title":"agreementStoreManager","text":"<pre><code>contract AgreementStoreManager agreementStoreManager\n</code></pre>"},{"location":"generated/solidity-api/#createagreement_2","title":"createAgreement","text":"<pre><code>function createAgreement(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts) public\n</code></pre> <p>createAgreement create new agreement</p> Name Type Description _id bytes32 agreement unique identifier _did bytes32 refers to decentralized identifier (a bytes32 length ID). _conditionIds bytes32[] list of condition identifiers _timeLocks uint256[] list of time locks, each time lock will be assigned to the           same condition that has the same index _timeOuts uint256[] list of time outs, each time out will be assigned to the           same condition that has the same index"},{"location":"generated/solidity-api/#createagreementandpay_1","title":"createAgreementAndPay","text":"<pre><code>function createAgreementAndPay(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, uint256 _idx, address payable _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) public payable\n</code></pre>"},{"location":"generated/solidity-api/#createagreementandfulfill_1","title":"createAgreementAndFulfill","text":"<pre><code>function createAgreementAndFulfill(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, uint256[] _indices, address[] _accounts, bytes[] _params) internal\n</code></pre>"},{"location":"generated/solidity-api/#getconditiontypes_1","title":"getConditionTypes","text":"<pre><code>function getConditionTypes() public view returns (address[])\n</code></pre> <p>getConditionTypes gets the conditions addresses list</p> <p>for the current template returns list of condition contracts       addresses</p> Name Type Description [0] address[] list of conditions contract addresses"},{"location":"generated/solidity-api/#baseescrowtemplate","title":"BaseEscrowTemplate","text":""},{"location":"generated/solidity-api/#agreementdata","title":"agreementData","text":"<pre><code>struct BaseEscrowTemplate.AgreementData agreementData\n</code></pre>"},{"location":"generated/solidity-api/#agreementcreated","title":"AgreementCreated","text":"<pre><code>event AgreementCreated(bytes32 _agreementId, bytes32 _did, address _accessConsumer, address _accessProvider, uint256[] _timeLocks, uint256[] _timeOuts, bytes32[] _conditionIdSeeds, bytes32[] _conditionIds, bytes32 _idSeed, address _creator)\n</code></pre>"},{"location":"generated/solidity-api/#agreementdatamodel","title":"AgreementDataModel","text":"<pre><code>struct AgreementDataModel {\n  address accessConsumer;\n  address accessProvider;\n  bytes32 did;\n}\n</code></pre>"},{"location":"generated/solidity-api/#agreementdata_1","title":"AgreementData","text":"<pre><code>struct AgreementData {\n  mapping(bytes32 &amp;#x3D;&amp;gt; struct BaseEscrowTemplate.AgreementDataModel) agreementDataItems;\n  bytes32[] agreementIds;\n}\n</code></pre>"},{"location":"generated/solidity-api/#createagreement_3","title":"createAgreement","text":"<pre><code>function createAgreement(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address _accessConsumer) public\n</code></pre> <p>createAgreement creates agreements through agreement template</p> <p>this function initializes the agreement by setting the DID,       conditions ID, timeouts, time locks and the consumer address.       The DID provider/owner is automatically detected by the DID       Registry</p> Name Type Description _id bytes32 SEA agreement unique identifier _did bytes32 Decentralized Identifier (DID) _conditionIds bytes32[] conditions ID associated with the condition types _timeLocks uint256[] the starting point of the time window ,time lock is        in block number not seconds _timeOuts uint256[] the ending point of the time window ,time lock is        in block number not seconds _accessConsumer address consumer address"},{"location":"generated/solidity-api/#createagreementandpayescrow","title":"createAgreementAndPayEscrow","text":"<pre><code>function createAgreementAndPayEscrow(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address _accessConsumer, uint256 _idx, address payable _rewardAddress, address _tokenAddress, uint256[] _amounts, address[] _receivers) public payable\n</code></pre>"},{"location":"generated/solidity-api/#createagreementandfulfill_2","title":"createAgreementAndFulfill","text":"<pre><code>function createAgreementAndFulfill(bytes32 _id, bytes32 _did, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address _accessConsumer, uint256[] _indices, address[] _accounts, bytes[] _params) internal\n</code></pre>"},{"location":"generated/solidity-api/#_makeids","title":"_makeIds","text":"<pre><code>function _makeIds(bytes32 _idSeed, bytes32[] _conditionIds) internal view returns (bytes32[])\n</code></pre>"},{"location":"generated/solidity-api/#_initagreement","title":"_initAgreement","text":"<pre><code>function _initAgreement(bytes32 _idSeed, bytes32 _did, uint256[] _timeLocks, uint256[] _timeOuts, address _accessConsumer, bytes32[] _conditionIds) internal\n</code></pre>"},{"location":"generated/solidity-api/#getagreementdata","title":"getAgreementData","text":"<pre><code>function getAgreementData(bytes32 _id) external view returns (address accessConsumer, address accessProvider)\n</code></pre> <p>getAgreementData return the agreement Data</p> Name Type Description _id bytes32 SEA agreement unique identifier Name Type Description accessConsumer address the agreement consumer accessProvider address the provider addresses"},{"location":"generated/solidity-api/#didsalestemplate","title":"DIDSalesTemplate","text":"<p>_Implementation of DID Sales Template</p> <pre><code> The DID Sales template supports an scenario where an Asset owner\n can sell that asset to a new Owner.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing an Asset owner to get transfer the asset ownership\n after some payment. \n The template is a composite of 3 basic conditions: \n - Lock Payment Condition\n - Transfer DID Condition\n - Escrow Reward Condition\n\n This scenario takes into account royalties for original creators in the secondary market.\n Once the agreement is created, the consumer after payment can request the ownership transfer of an asset\n from the current owner for a specific DID._\n</code></pre>"},{"location":"generated/solidity-api/#didregistry_11","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#lockpaymentcondition_1","title":"lockPaymentCondition","text":"<pre><code>contract LockPaymentCondition lockPaymentCondition\n</code></pre>"},{"location":"generated/solidity-api/#transfercondition_1","title":"transferCondition","text":"<pre><code>contract TransferDIDOwnershipCondition transferCondition\n</code></pre>"},{"location":"generated/solidity-api/#rewardcondition","title":"rewardCondition","text":"<pre><code>contract EscrowPaymentCondition rewardCondition\n</code></pre>"},{"location":"generated/solidity-api/#id","title":"id","text":"<pre><code>function id() public pure returns (uint256)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_41","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _lockConditionAddress, address _transferConditionAddress, address payable _escrowPaymentAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockConditionAddress address lock reward condition contract address _transferConditionAddress address transfer ownership condition contract address _escrowPaymentAddress address payable escrow reward condition contract address"},{"location":"generated/solidity-api/#dynamicaccesstemplate","title":"DynamicAccessTemplate","text":"<p>Implementation of Agreement Template This is a dynamic template that allows to setup flexible conditions depending  on the use case.</p>"},{"location":"generated/solidity-api/#didregistry_12","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#templateconfig","title":"templateConfig","text":"<pre><code>struct DynamicAccessTemplate.TemplateConditions templateConfig\n</code></pre>"},{"location":"generated/solidity-api/#templateconditions","title":"TemplateConditions","text":"<pre><code>struct TemplateConditions {\n  mapping(address &amp;#x3D;&amp;gt; contract Condition) templateConditions;\n}\n</code></pre>"},{"location":"generated/solidity-api/#initialize_42","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _didRegistryAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address"},{"location":"generated/solidity-api/#addtemplatecondition","title":"addTemplateCondition","text":"<pre><code>function addTemplateCondition(address _conditionAddress) external returns (uint256 length)\n</code></pre> <p>addTemplateCondition adds a new condition to the template</p> Name Type Description _conditionAddress address condition contract address Name Type Description length uint256 conditionTypes array size"},{"location":"generated/solidity-api/#removelasttemplatecondition","title":"removeLastTemplateCondition","text":"<pre><code>function removeLastTemplateCondition() external returns (address[])\n</code></pre> <p>removeLastTemplateCondition removes last condition added to the template</p> Name Type Description [0] address[] conditionTypes existing in the array"},{"location":"generated/solidity-api/#escrowcomputeexecutiontemplate","title":"EscrowComputeExecutionTemplate","text":"<p>_Implementation of a Compute Execution Agreement Template</p> <pre><code> EscrowComputeExecutionTemplate is use case specific template.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an on-chain SEA. The template is a composite of three basic\n conditions. Once the agreement is created, the consumer will lock an amount\n of tokens (as listed in the DID document - off-chain metadata) to the \n the lock reward contract which in turn will fire an event. ON the other hand \n the provider is listening to all the emitted events, the provider \n will catch the event and grant permissions to trigger a computation granting\n the execution via the ComputeExecutionCondition contract. \n The consumer now is able to trigger that computation\n by asking the off-chain gateway to start the execution of a compute workflow.\n Finally, the provider can call the escrow reward condition in order \n to release the payment. Every condition has a time window (time lock and \n time out). This implies that if the provider didn't grant the execution to \n the consumer within this time window, the consumer \n can ask for refund._\n</code></pre>"},{"location":"generated/solidity-api/#didregistry_13","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#computeexecutioncondition_1","title":"computeExecutionCondition","text":"<pre><code>contract ComputeExecutionCondition computeExecutionCondition\n</code></pre>"},{"location":"generated/solidity-api/#lockpaymentcondition_2","title":"lockPaymentCondition","text":"<pre><code>contract LockPaymentCondition lockPaymentCondition\n</code></pre>"},{"location":"generated/solidity-api/#escrowpayment","title":"escrowPayment","text":"<pre><code>contract EscrowPaymentCondition escrowPayment\n</code></pre>"},{"location":"generated/solidity-api/#initialize_43","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _didRegistryAddress, address _computeExecutionConditionAddress, address _lockPaymentConditionAddress, address payable _escrowPaymentAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        service executor condition, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _computeExecutionConditionAddress address service executor condition contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward contract address"},{"location":"generated/solidity-api/#name","title":"name","text":"<pre><code>function name() public pure returns (string)\n</code></pre>"},{"location":"generated/solidity-api/#nft721accessprooftemplate","title":"NFT721AccessProofTemplate","text":"<p>Implementation of NFT721 Access Proof Template</p>"},{"location":"generated/solidity-api/#nft721accessswaptemplate","title":"NFT721AccessSwapTemplate","text":""},{"location":"generated/solidity-api/#nft721accesstemplate","title":"NFT721AccessTemplate","text":"<p>Implementation of NFT Access Template</p>"},{"location":"generated/solidity-api/#nft721salestemplate","title":"NFT721SalesTemplate","text":"<p>Implementation of NFT Sales Template</p>"},{"location":"generated/solidity-api/#nft721saleswithaccesstemplate","title":"NFT721SalesWithAccessTemplate","text":""},{"location":"generated/solidity-api/#nftaccessprooftemplate","title":"NFTAccessProofTemplate","text":"<p>_Implementation of NFT Access Template</p> <pre><code> The NFT Access template is use case specific template.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing NFT holders to get access to Nevermined services. \n The template is a composite of 2 basic conditions: \n - NFT Holding Condition\n - Access Condition\n\n Once the agreement is created, the consumer can demonstrate is holding a NFT\n for a specific DID. If that's the case the Access condition can be fulfilled\n by the asset owner or provider and all the agreement is fulfilled.\n This can be used in scenarios where a data or services owner, can allow \n users to get access to exclusive services only when they demonstrate the \n are holding a specific number of NFTs of a DID.\n This is very useful in use cases like arts._\n</code></pre>"},{"location":"generated/solidity-api/#didregistry_14","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#nftholdercondition_1","title":"nftHolderCondition","text":"<pre><code>contract INFTHolder nftHolderCondition\n</code></pre>"},{"location":"generated/solidity-api/#accesscondition_3","title":"accessCondition","text":"<pre><code>contract AccessProofCondition accessCondition\n</code></pre>"},{"location":"generated/solidity-api/#initialize_44","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _nftHolderConditionAddress, address _accessConditionAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address"},{"location":"generated/solidity-api/#nftaccessswaptemplate","title":"NFTAccessSwapTemplate","text":"<p>_Implementation of NFT Sales Template</p> <pre><code> The NFT Sales template supports an scenario where a NFT owner\n can sell that asset to a new Owner.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing a NFT owner to transfer the asset ownership\n after some payment. \n The template is a composite of 3 basic conditions: \n - Lock Payment Condition\n - Transfer NFT Condition\n - Escrow Reward Condition\n\n This scenario takes into account royalties for original creators in the secondary market.\n Once the agreement is created, the consumer after payment can request the transfer of the NFT\n from the current owner for a specific DID._\n</code></pre>"},{"location":"generated/solidity-api/#didregistry_15","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#lockpaymentcondition_3","title":"lockPaymentCondition","text":"<pre><code>contract INFTLock lockPaymentCondition\n</code></pre>"},{"location":"generated/solidity-api/#rewardcondition_1","title":"rewardCondition","text":"<pre><code>contract INFTEscrow rewardCondition\n</code></pre>"},{"location":"generated/solidity-api/#accesscondition_4","title":"accessCondition","text":"<pre><code>contract AccessProofCondition accessCondition\n</code></pre>"},{"location":"generated/solidity-api/#id_1","title":"id","text":"<pre><code>function id() public pure returns (uint256)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_45","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _lockPaymentConditionAddress, address payable _escrowPaymentAddress, address _accessCondition) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward condition contract address _accessCondition address"},{"location":"generated/solidity-api/#nftaccesstemplate","title":"NFTAccessTemplate","text":"<p>_Implementation of NFT Access Template</p> <pre><code> The NFT Access template is use case specific template.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing NFT holders to get access to Nevermined services. \n The template is a composite of 2 basic conditions: \n - NFT Holding Condition\n - Access Condition\n\n Once the agreement is created, the consumer can demonstrate is holding a NFT\n for a specific DID. If that's the case the Access condition can be fulfilled\n by the asset owner or provider and all the agreement is fulfilled.\n This can be used in scenarios where a data or services owner, can allow \n users to get access to exclusive services only when they demonstrate the \n are holding a specific number of NFTs of a DID.\n This is very useful in use cases like arts._\n</code></pre>"},{"location":"generated/solidity-api/#didregistry_16","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#nftholdercondition_2","title":"nftHolderCondition","text":"<pre><code>contract INFTHolder nftHolderCondition\n</code></pre>"},{"location":"generated/solidity-api/#accesscondition_5","title":"accessCondition","text":"<pre><code>contract INFTAccess accessCondition\n</code></pre>"},{"location":"generated/solidity-api/#initialize_46","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _nftHolderConditionAddress, address _accessConditionAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address"},{"location":"generated/solidity-api/#nftsalestemplate","title":"NFTSalesTemplate","text":"<p>_Implementation of NFT Sales Template</p> <pre><code> The NFT Sales template supports an scenario where a NFT owner\n can sell that asset to a new Owner.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing a NFT owner to transfer the asset ownership\n after some payment. \n The template is a composite of 3 basic conditions: \n - Lock Payment Condition\n - Transfer NFT Condition\n - Escrow Reward Condition\n\n This scenario takes into account royalties for original creators in the secondary market.\n Once the agreement is created, the consumer after payment can request the transfer of the NFT\n from the current owner for a specific DID._\n</code></pre>"},{"location":"generated/solidity-api/#didregistry_17","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#lockpaymentcondition_4","title":"lockPaymentCondition","text":"<pre><code>contract LockPaymentCondition lockPaymentCondition\n</code></pre>"},{"location":"generated/solidity-api/#transfercondition_2","title":"transferCondition","text":"<pre><code>contract ITransferNFT transferCondition\n</code></pre>"},{"location":"generated/solidity-api/#rewardcondition_2","title":"rewardCondition","text":"<pre><code>contract EscrowPaymentCondition rewardCondition\n</code></pre>"},{"location":"generated/solidity-api/#id_2","title":"id","text":"<pre><code>function id() public pure returns (uint256)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_47","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _lockPaymentConditionAddress, address _transferConditionAddress, address payable _escrowPaymentAddress) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address"},{"location":"generated/solidity-api/#nftprice","title":"nftPrice","text":"<pre><code>mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; mapping(bytes32 =&gt; uint256)))) nftPrice\n</code></pre>"},{"location":"generated/solidity-api/#nftsale","title":"nftSale","text":"<pre><code>function nftSale(address nftAddress, bytes32 nftId, address token, uint256 amount) external\n</code></pre>"},{"location":"generated/solidity-api/#checkparamstransfer","title":"checkParamsTransfer","text":"<pre><code>function checkParamsTransfer(bytes[] _params, bytes32 lockPaymentConditionId, bytes32 _did) internal view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#checkparamsescrow","title":"checkParamsEscrow","text":"<pre><code>function checkParamsEscrow(bytes[] _params, bytes32 lockPaymentId, bytes32 transferId) internal pure\n</code></pre>"},{"location":"generated/solidity-api/#createagreementfulfill","title":"createAgreementFulfill","text":"<pre><code>function createAgreementFulfill(bytes32 _id, bytes32 _did, uint256[] _timeLocks, uint256[] _timeOuts, address _accessConsumer, bytes[] _params) external payable\n</code></pre>"},{"location":"generated/solidity-api/#nftsaleswithaccesstemplate","title":"NFTSalesWithAccessTemplate","text":"<p>_Implementation of NFT Sales Template</p> <pre><code> The NFT Sales template supports an scenario where a NFT owner\n can sell that asset to a new Owner.\n Anyone (consumer/provider/publisher) can use this template in order\n to setup an agreement allowing a NFT owner to transfer the asset ownership\n after some payment. \n The template is a composite of 3 basic conditions: \n - Lock Payment Condition\n - Transfer NFT Condition\n - Escrow Reward Condition\n\n This scenario takes into account royalties for original creators in the secondary market.\n Once the agreement is created, the consumer after payment can request the transfer of the NFT\n from the current owner for a specific DID._\n</code></pre>"},{"location":"generated/solidity-api/#didregistry_18","title":"didRegistry","text":"<pre><code>contract DIDRegistry didRegistry\n</code></pre>"},{"location":"generated/solidity-api/#lockpaymentcondition_5","title":"lockPaymentCondition","text":"<pre><code>contract LockPaymentCondition lockPaymentCondition\n</code></pre>"},{"location":"generated/solidity-api/#transfercondition_3","title":"transferCondition","text":"<pre><code>contract ITransferNFT transferCondition\n</code></pre>"},{"location":"generated/solidity-api/#rewardcondition_3","title":"rewardCondition","text":"<pre><code>contract EscrowPaymentCondition rewardCondition\n</code></pre>"},{"location":"generated/solidity-api/#accesscondition_6","title":"accessCondition","text":"<pre><code>contract AccessProofCondition accessCondition\n</code></pre>"},{"location":"generated/solidity-api/#initialize_48","title":"initialize","text":"<pre><code>function initialize(address _owner, address _agreementStoreManagerAddress, address _lockPaymentConditionAddress, address _transferConditionAddress, address payable _escrowPaymentAddress, address _accessCondition) external\n</code></pre> <p>initialize init the        contract with the following parameters.</p> <p>this function is called only once during the contract       initialization. It initializes the ownable feature, and        set push the required condition types including        access secret store, lock reward and escrow reward conditions.</p> Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address _accessCondition address"},{"location":"generated/solidity-api/#templatestorelibrary","title":"TemplateStoreLibrary","text":"<p>_Implementation of the Template Store Library.</p> <pre><code> Templates are blueprints for modular SEAs. When \n creating an Agreement, a templateId defines the condition \n and reward types that are instantiated in the ConditionStore._\n</code></pre>"},{"location":"generated/solidity-api/#templatestate","title":"TemplateState","text":"<pre><code>enum TemplateState {\n  Uninitialized,\n  Proposed,\n  Approved,\n  Revoked\n}\n</code></pre>"},{"location":"generated/solidity-api/#template_1","title":"Template","text":"<pre><code>struct Template {\n  enum TemplateStoreLibrary.TemplateState state;\n  address owner;\n  address lastUpdatedBy;\n  uint256 blockNumberUpdated;\n}\n</code></pre>"},{"location":"generated/solidity-api/#templatelist","title":"TemplateList","text":"<pre><code>struct TemplateList {\n  mapping(address &amp;#x3D;&amp;gt; struct TemplateStoreLibrary.Template) templates;\n  address[] templateIds;\n}\n</code></pre>"},{"location":"generated/solidity-api/#propose","title":"propose","text":"<pre><code>function propose(struct TemplateStoreLibrary.TemplateList _self, address _id) internal returns (uint256 size)\n</code></pre> <p>propose new template</p> Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address Name Type Description size uint256 which is the index of the proposed template"},{"location":"generated/solidity-api/#approve_1","title":"approve","text":"<pre><code>function approve(struct TemplateStoreLibrary.TemplateList _self, address _id) internal\n</code></pre> <p>approve new template</p> Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address"},{"location":"generated/solidity-api/#revoke","title":"revoke","text":"<pre><code>function revoke(struct TemplateStoreLibrary.TemplateList _self, address _id) internal\n</code></pre> <p>revoke new template</p> Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address approved template contract address"},{"location":"generated/solidity-api/#templatestoremanager_1","title":"TemplateStoreManager","text":"<p>Implementation of the Template Store Manager.      Templates are blueprints for modular SEAs. When creating an Agreement,       a templateId defines the condition and reward types that are instantiated       in the ConditionStore. This contract manages the life cycle       of the template ( Propose \u2192 Approve \u2192 Revoke ).</p>"},{"location":"generated/solidity-api/#templatelist_1","title":"templateList","text":"<pre><code>struct TemplateStoreLibrary.TemplateList templateList\n</code></pre>"},{"location":"generated/solidity-api/#onlyownerortemplateowner","title":"onlyOwnerOrTemplateOwner","text":"<pre><code>modifier onlyOwnerOrTemplateOwner(address _id)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_49","title":"initialize","text":"<pre><code>function initialize(address _owner) public\n</code></pre> <p>initialize TemplateStoreManager Initializer      Initializes Ownable. Only on contract creation.</p> Name Type Description _owner address refers to the owner of the contract"},{"location":"generated/solidity-api/#proposetemplate","title":"proposeTemplate","text":"<pre><code>function proposeTemplate(address _id) external returns (uint256 size)\n</code></pre> <p>proposeTemplate proposes a new template</p> Name Type Description _id address unique template identifier which is basically        the template contract address"},{"location":"generated/solidity-api/#approvetemplate","title":"approveTemplate","text":"<pre><code>function approveTemplate(address _id) external\n</code></pre> <p>approveTemplate approves a template</p> Name Type Description _id address unique template identifier which is basically        the template contract address. Only template store        manager owner (i.e OPNF) can approve this template."},{"location":"generated/solidity-api/#revoketemplate","title":"revokeTemplate","text":"<pre><code>function revokeTemplate(address _id) external\n</code></pre> <p>revokeTemplate revoke a template</p> Name Type Description _id address unique template identifier which is basically        the template contract address. Only template store        manager owner (i.e OPNF) or template owner        can revoke this template."},{"location":"generated/solidity-api/#gettemplate","title":"getTemplate","text":"<pre><code>function getTemplate(address _id) external view returns (enum TemplateStoreLibrary.TemplateState state, address owner, address lastUpdatedBy, uint256 blockNumberUpdated)\n</code></pre> <p>getTemplate get more information about a template</p> Name Type Description _id address unique template identifier which is basically        the template contract address. Name Type Description state enum TemplateStoreLibrary.TemplateState template status owner address template owner lastUpdatedBy address last updated by blockNumberUpdated uint256 last updated at."},{"location":"generated/solidity-api/#gettemplatelistsize","title":"getTemplateListSize","text":"<pre><code>function getTemplateListSize() external view virtual returns (uint256 size)\n</code></pre> <p>getTemplateListSize number of templates</p> Name Type Description size uint256 number of templates"},{"location":"generated/solidity-api/#istemplateapproved","title":"isTemplateApproved","text":"<pre><code>function isTemplateApproved(address _id) external view returns (bool)\n</code></pre> <p>isTemplateApproved check whether the template is approved</p> Name Type Description _id address unique template identifier which is basically        the template contract address. Name Type Description [0] bool true if the template is approved"},{"location":"generated/solidity-api/#agreementstoremanagerchangefunctionsignature","title":"AgreementStoreManagerChangeFunctionSignature","text":""},{"location":"generated/solidity-api/#createagreement_4","title":"createAgreement","text":"<pre><code>function createAgreement(bytes32 _id, bytes32 _did, address[] _conditionTypes, bytes32[] _conditionIds, uint256[] _timeLocks, uint256[] _timeOuts, address _creator, address _sender) public\n</code></pre>"},{"location":"generated/solidity-api/#agreementstoremanagerchangeinstorage","title":"AgreementStoreManagerChangeInStorage","text":""},{"location":"generated/solidity-api/#agreementcount","title":"agreementCount","text":"<pre><code>uint256 agreementCount\n</code></pre>"},{"location":"generated/solidity-api/#agreementstoremanagerchangeinstorageandlogic","title":"AgreementStoreManagerChangeInStorageAndLogic","text":""},{"location":"generated/solidity-api/#agreementstoremanagerextrafunctionality","title":"AgreementStoreManagerExtraFunctionality","text":""},{"location":"generated/solidity-api/#dummyfunction","title":"dummyFunction","text":"<pre><code>function dummyFunction() public pure returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#agreementstoremanagerwithbug","title":"AgreementStoreManagerWithBug","text":""},{"location":"generated/solidity-api/#getdidregistryaddress_1","title":"getDIDRegistryAddress","text":"<pre><code>function getDIDRegistryAddress() public pure returns (address)\n</code></pre> <p>getDIDRegistryAddress utility function  used by other contracts or any EOA.</p> Name Type Description [0] address the DIDRegistry address"},{"location":"generated/solidity-api/#conditionstorechangefunctionsignature","title":"ConditionStoreChangeFunctionSignature","text":""},{"location":"generated/solidity-api/#createcondition_2","title":"createCondition","text":"<pre><code>function createCondition(bytes32 _id, address _typeRef, address _sender) public\n</code></pre>"},{"location":"generated/solidity-api/#conditionstorechangeinstorage","title":"ConditionStoreChangeInStorage","text":""},{"location":"generated/solidity-api/#conditioncount","title":"conditionCount","text":"<pre><code>uint256 conditionCount\n</code></pre>"},{"location":"generated/solidity-api/#conditionstorechangeinstorageandlogic","title":"ConditionStoreChangeInStorageAndLogic","text":""},{"location":"generated/solidity-api/#conditionstoreextrafunctionality","title":"ConditionStoreExtraFunctionality","text":""},{"location":"generated/solidity-api/#dummyfunction_1","title":"dummyFunction","text":"<pre><code>function dummyFunction() public pure returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#conditionstorewithbug","title":"ConditionStoreWithBug","text":""},{"location":"generated/solidity-api/#getconditionstate_1","title":"getConditionState","text":"<pre><code>function getConditionState(bytes32 _id) public view returns (enum ConditionStoreLibrary.ConditionState)\n</code></pre> <p>getConditionState</p> Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state"},{"location":"generated/solidity-api/#didregistrychangefunctionsignature","title":"DIDRegistryChangeFunctionSignature","text":""},{"location":"generated/solidity-api/#registerattribute_1","title":"registerAttribute","text":"<pre><code>function registerAttribute(bytes32 _didSeed, address[] _providers, bytes32 _checksum, string _url) public\n</code></pre>"},{"location":"generated/solidity-api/#didregistrychangeinstorage","title":"DIDRegistryChangeInStorage","text":""},{"location":"generated/solidity-api/#timeofregister","title":"timeOfRegister","text":"<pre><code>mapping(bytes32 =&gt; uint256) timeOfRegister\n</code></pre>"},{"location":"generated/solidity-api/#didregistrychangeinstorageandlogic","title":"DIDRegistryChangeInStorageAndLogic","text":""},{"location":"generated/solidity-api/#didregistryextrafunctionality","title":"DIDRegistryExtraFunctionality","text":""},{"location":"generated/solidity-api/#getnumber","title":"getNumber","text":"<pre><code>function getNumber() public pure returns (uint256)\n</code></pre>"},{"location":"generated/solidity-api/#didregistrywithbug","title":"DIDRegistryWithBug","text":""},{"location":"generated/solidity-api/#registerattribute_2","title":"registerAttribute","text":"<pre><code>function registerAttribute(bytes32 _checksum, bytes32 _didSeed, address[] _providers, string _url) public\n</code></pre> <p>registerAttribute is called only by DID owner.</p> <p>this function registers DID attributes</p> Name Type Description _checksum bytes32 includes a one-way HASH calculated using the DDO content _didSeed bytes32 refers to decentralized identifier (a byte32 length ID) _providers address[] _url string refers to the attribute value"},{"location":"generated/solidity-api/#ipnft","title":"IPNFT","text":""},{"location":"generated/solidity-api/#tokenurichanged","title":"TokenURIChanged","text":"<pre><code>event TokenURIChanged(uint256 tokenId, string newURI)\n</code></pre>"},{"location":"generated/solidity-api/#initialize_50","title":"initialize","text":"<pre><code>function initialize(string _name, string _symbol) public\n</code></pre>"},{"location":"generated/solidity-api/#settokenuri","title":"setTokenURI","text":"<pre><code>function setTokenURI(uint256 tokenId, string _tokenURI) public\n</code></pre>"},{"location":"generated/solidity-api/#mint_5","title":"mint","text":"<pre><code>function mint(address to, uint256 _tokenId, string _tokenURI) public returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#mintwithouttokenuri","title":"mintWithoutTokenURI","text":"<pre><code>function mintWithoutTokenURI(address to, uint256 _tokenId) external\n</code></pre>"},{"location":"generated/solidity-api/#transfer_2","title":"transfer","text":"<pre><code>function transfer(address from, address to, uint256 _tokenId) public\n</code></pre>"},{"location":"generated/solidity-api/#neverminedconfigchangeinstorage","title":"NeverminedConfigChangeInStorage","text":""},{"location":"generated/solidity-api/#newvariable","title":"newVariable","text":"<pre><code>uint256 newVariable\n</code></pre>"},{"location":"generated/solidity-api/#neverminedconfigchangefunctionsignature","title":"NeverminedConfigChangeFunctionSignature","text":""},{"location":"generated/solidity-api/#setmarketplacefees_2","title":"setMarketplaceFees","text":"<pre><code>function setMarketplaceFees(uint256 _marketplaceFee, address _feeReceiver, uint256 _newParameter) external virtual\n</code></pre>"},{"location":"generated/solidity-api/#neverminedconfigchangeinstorageandlogic","title":"NeverminedConfigChangeInStorageAndLogic","text":""},{"location":"generated/solidity-api/#neverminedconfigwithbug","title":"NeverminedConfigWithBug","text":""},{"location":"generated/solidity-api/#setmarketplacefees_3","title":"setMarketplaceFees","text":"<pre><code>function setMarketplaceFees(uint256 _marketplaceFee, address _feeReceiver) external virtual\n</code></pre> <p>The governor can update the Nevermined Marketplace fees</p> Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee"},{"location":"generated/solidity-api/#templatestorechangefunctionsignature","title":"TemplateStoreChangeFunctionSignature","text":""},{"location":"generated/solidity-api/#proposetemplate_1","title":"proposeTemplate","text":"<pre><code>function proposeTemplate(address _id, address _sender) external returns (uint256 size)\n</code></pre>"},{"location":"generated/solidity-api/#templatestorechangeinstorage","title":"TemplateStoreChangeInStorage","text":""},{"location":"generated/solidity-api/#templatecount","title":"templateCount","text":"<pre><code>uint256 templateCount\n</code></pre>"},{"location":"generated/solidity-api/#templatestorechangeinstorageandlogic","title":"TemplateStoreChangeInStorageAndLogic","text":""},{"location":"generated/solidity-api/#templatestoreextrafunctionality","title":"TemplateStoreExtraFunctionality","text":""},{"location":"generated/solidity-api/#dummyfunction_2","title":"dummyFunction","text":"<pre><code>function dummyFunction() public pure returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#templatestorewithbug","title":"TemplateStoreWithBug","text":""},{"location":"generated/solidity-api/#gettemplatelistsize_1","title":"getTemplateListSize","text":"<pre><code>function getTemplateListSize() external view returns (uint256 size)\n</code></pre> <p>getTemplateListSize number of templates</p> Name Type Description size uint256 number of templates"},{"location":"generated/solidity-api/#testerc721","title":"TestERC721","text":""},{"location":"generated/solidity-api/#initialize_51","title":"initialize","text":"<pre><code>function initialize() public\n</code></pre>"},{"location":"generated/solidity-api/#mint_6","title":"mint","text":"<pre><code>function mint(uint256 id) public\n</code></pre>"},{"location":"generated/solidity-api/#didregistrylibraryproxy","title":"DIDRegistryLibraryProxy","text":""},{"location":"generated/solidity-api/#didregister_1","title":"didRegister","text":"<pre><code>struct DIDRegistryLibrary.DIDRegister didRegister\n</code></pre>"},{"location":"generated/solidity-api/#didregisterlist_2","title":"didRegisterList","text":"<pre><code>struct DIDRegistryLibrary.DIDRegisterList didRegisterList\n</code></pre>"},{"location":"generated/solidity-api/#areroyaltiesvalid_2","title":"areRoyaltiesValid","text":"<pre><code>function areRoyaltiesValid(bytes32 _did, uint256[] _amounts, address[] _receivers, address _tokenAddress) public view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#updatedidowner_1","title":"updateDIDOwner","text":"<pre><code>function updateDIDOwner(bytes32 _did, address _newOwner) public\n</code></pre>"},{"location":"generated/solidity-api/#update_3","title":"update","text":"<pre><code>function update(bytes32 _did, bytes32 _checksum, string _url) public\n</code></pre>"},{"location":"generated/solidity-api/#initializenftconfig_1","title":"initializeNftConfig","text":"<pre><code>function initializeNftConfig(bytes32 _did, uint256 _cap, uint8 _royalties) public\n</code></pre>"},{"location":"generated/solidity-api/#initializenft721config_1","title":"initializeNft721Config","text":"<pre><code>function initializeNft721Config(bytes32 _did, uint8 _royalties) public\n</code></pre>"},{"location":"generated/solidity-api/#getdidinfo","title":"getDIDInfo","text":"<pre><code>function getDIDInfo(bytes32 _did) public view returns (address owner, address creator, uint256 royalties)\n</code></pre>"},{"location":"generated/solidity-api/#epochlibraryproxy","title":"EpochLibraryProxy","text":""},{"location":"generated/solidity-api/#epoch_1","title":"epoch","text":"<pre><code>struct EpochLibrary.Epoch epoch\n</code></pre>"},{"location":"generated/solidity-api/#epochlist_2","title":"epochList","text":"<pre><code>struct EpochLibrary.EpochList epochList\n</code></pre>"},{"location":"generated/solidity-api/#create_5","title":"create","text":"<pre><code>function create(bytes32 _id, uint256 _timeLock, uint256 _timeOut) external\n</code></pre>"},{"location":"generated/solidity-api/#hashlistlibraryproxy","title":"HashListLibraryProxy","text":""},{"location":"generated/solidity-api/#testdata","title":"testData","text":"<pre><code>struct HashListLibrary.List testData\n</code></pre>"},{"location":"generated/solidity-api/#initialize_52","title":"initialize","text":"<pre><code>function initialize(address _owner) public\n</code></pre>"},{"location":"generated/solidity-api/#hash_1","title":"hash","text":"<pre><code>function hash(address _address) public pure returns (bytes32)\n</code></pre>"},{"location":"generated/solidity-api/#add_5","title":"add","text":"<pre><code>function add(bytes32[] values) external returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#add_6","title":"add","text":"<pre><code>function add(bytes32 value) external returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#update_4","title":"update","text":"<pre><code>function update(bytes32 oldValue, bytes32 newValue) external returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#index_2","title":"index","text":"<pre><code>function index(uint256 from, uint256 to) external returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#has_5","title":"has","text":"<pre><code>function has(bytes32 value) external view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#remove_2","title":"remove","text":"<pre><code>function remove(bytes32 value) external returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#get_2","title":"get","text":"<pre><code>function get(uint256 _index) external view returns (bytes32)\n</code></pre>"},{"location":"generated/solidity-api/#size_2","title":"size","text":"<pre><code>function size() external view returns (uint256)\n</code></pre>"},{"location":"generated/solidity-api/#all_2","title":"all","text":"<pre><code>function all() external view returns (bytes32[])\n</code></pre>"},{"location":"generated/solidity-api/#indexof_2","title":"indexOf","text":"<pre><code>function indexOf(bytes32 value) external view returns (uint256)\n</code></pre>"},{"location":"generated/solidity-api/#ownedby_2","title":"ownedBy","text":"<pre><code>function ownedBy() external view returns (address)\n</code></pre>"},{"location":"generated/solidity-api/#isindexed_2","title":"isIndexed","text":"<pre><code>function isIndexed() external view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#nftbase","title":"NFTBase","text":"<p>Implementation of the Royalties EIP-2981 base contract See https://eips.ethereum.org/EIPS/eip-2981</p>"},{"location":"generated/solidity-api/#_proxyapprovals","title":"_proxyApprovals","text":"<pre><code>mapping(address =&gt; bool) _proxyApprovals\n</code></pre>"},{"location":"generated/solidity-api/#minter_role","title":"MINTER_ROLE","text":"<pre><code>bytes32 MINTER_ROLE\n</code></pre>"},{"location":"generated/solidity-api/#royaltyinfo","title":"RoyaltyInfo","text":"<pre><code>struct RoyaltyInfo {\n  address receiver;\n  uint256 royaltyAmount;\n}\n</code></pre>"},{"location":"generated/solidity-api/#nftmetadata","title":"NFTMetadata","text":"<pre><code>struct NFTMetadata {\n  string nftURI;\n}\n</code></pre>"},{"location":"generated/solidity-api/#_royalties","title":"_royalties","text":"<pre><code>mapping(uint256 =&gt; struct NFTBase.RoyaltyInfo) _royalties\n</code></pre>"},{"location":"generated/solidity-api/#_metadata","title":"_metadata","text":"<pre><code>mapping(uint256 =&gt; struct NFTBase.NFTMetadata) _metadata\n</code></pre>"},{"location":"generated/solidity-api/#_expiration","title":"_expiration","text":"<pre><code>mapping(address =&gt; uint256) _expiration\n</code></pre>"},{"location":"generated/solidity-api/#proxyapproval","title":"ProxyApproval","text":"<pre><code>event ProxyApproval(address sender, address operator, bool approved)\n</code></pre> <p>Event for recording proxy approvals.</p>"},{"location":"generated/solidity-api/#setproxyapproval","title":"setProxyApproval","text":"<pre><code>function setProxyApproval(address operator, bool approved) public virtual\n</code></pre>"},{"location":"generated/solidity-api/#_setnftmetadata","title":"_setNFTMetadata","text":"<pre><code>function _setNFTMetadata(uint256 tokenId, string tokenURI) internal\n</code></pre>"},{"location":"generated/solidity-api/#_settokenroyalty","title":"_setTokenRoyalty","text":"<pre><code>function _setTokenRoyalty(uint256 tokenId, address receiver, uint256 royaltyAmount) internal\n</code></pre>"},{"location":"generated/solidity-api/#royaltyinfo_1","title":"royaltyInfo","text":"<pre><code>function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address receiver, uint256 royaltyAmount)\n</code></pre> <p>@inheritdoc IERC2981Upgradeable</p>"},{"location":"generated/solidity-api/#nftupgradeable","title":"NFTUpgradeable","text":"<p>Implementation of the basic standard multi-token. See https://eips.ethereum.org/EIPS/eip-1155</p>"},{"location":"generated/solidity-api/#initialize_53","title":"initialize","text":"<pre><code>function initialize(string uri_) public\n</code></pre> <p>See {_setURI}.</p>"},{"location":"generated/solidity-api/#isapprovedforall","title":"isApprovedForAll","text":"<pre><code>function isApprovedForAll(address account, address operator) public view virtual returns (bool)\n</code></pre> <p>See {IERC1155-isApprovedForAll}.</p>"},{"location":"generated/solidity-api/#mint_7","title":"mint","text":"<pre><code>function mint(address to, uint256 id, uint256 amount, bytes data) public\n</code></pre>"},{"location":"generated/solidity-api/#burn_3","title":"burn","text":"<pre><code>function burn(address to, uint256 id, uint256 amount) public\n</code></pre>"},{"location":"generated/solidity-api/#addminter","title":"addMinter","text":"<pre><code>function addMinter(address account) public\n</code></pre>"},{"location":"generated/solidity-api/#uri","title":"uri","text":"<pre><code>function uri(uint256 tokenId) public view returns (string)\n</code></pre>"},{"location":"generated/solidity-api/#setnftmetadata","title":"setNFTMetadata","text":"<pre><code>function setNFTMetadata(uint256 tokenId, string nftURI) public\n</code></pre> <p>Record some NFT Metadata</p> Name Type Description tokenId uint256 the id of the asset with the royalties associated nftURI string the URI (https, ipfs, etc) to the metadata describing the NFT"},{"location":"generated/solidity-api/#settokenroyalty","title":"setTokenRoyalty","text":"<pre><code>function setTokenRoyalty(uint256 tokenId, address receiver, uint256 royaltyAmount) public\n</code></pre> <p>Record the asset royalties</p> Name Type Description tokenId uint256 the id of the asset with the royalties associated receiver address the receiver of the royalties (the original creator) royaltyAmount uint256 percentage (no decimals, between 0 and 100)"},{"location":"generated/solidity-api/#supportsinterface_2","title":"supportsInterface","text":"<pre><code>function supportsInterface(bytes4 interfaceId) public view virtual returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#nft721subscriptionupgradeable","title":"NFT721SubscriptionUpgradeable","text":""},{"location":"generated/solidity-api/#mint_8","title":"mint","text":"<pre><code>function mint(address to, uint256 id, uint256 expirationBlock) public\n</code></pre> <p>_This mint function allows to define when the NFT expires.  The minter should calculate this block number depending on the network velocity</p> <p>TransferNFT721Condition needs to have the <code>MINTER_ROLE</code>_</p>"},{"location":"generated/solidity-api/#balanceof_1","title":"balanceOf","text":"<pre><code>function balanceOf(address owner) public view returns (uint256)\n</code></pre> <p>See {IERC721-balanceOf}.</p>"},{"location":"generated/solidity-api/#nft721upgradeable","title":"NFT721Upgradeable","text":"<p>Implementation of the basic standard multi-token.</p>"},{"location":"generated/solidity-api/#initialize_54","title":"initialize","text":"<pre><code>function initialize(string name, string symbol) public virtual\n</code></pre>"},{"location":"generated/solidity-api/#initialize_55","title":"initialize","text":"<pre><code>function initialize() public virtual\n</code></pre>"},{"location":"generated/solidity-api/#isapprovedforall_1","title":"isApprovedForAll","text":"<pre><code>function isApprovedForAll(address account, address operator) public view virtual returns (bool)\n</code></pre> <p>See {IERC1155-isApprovedForAll}.</p>"},{"location":"generated/solidity-api/#addminter_1","title":"addMinter","text":"<pre><code>function addMinter(address account) public\n</code></pre>"},{"location":"generated/solidity-api/#mint_9","title":"mint","text":"<pre><code>function mint(address to, uint256 id) public virtual\n</code></pre>"},{"location":"generated/solidity-api/#burn_4","title":"burn","text":"<pre><code>function burn(uint256 id) public\n</code></pre>"},{"location":"generated/solidity-api/#tokenuri","title":"tokenURI","text":"<pre><code>function tokenURI(uint256 tokenId) public view virtual returns (string)\n</code></pre> <p>See {IERC721Metadata-tokenURI}.</p>"},{"location":"generated/solidity-api/#setnftmetadata_1","title":"setNFTMetadata","text":"<pre><code>function setNFTMetadata(uint256 tokenId, string nftURI) public\n</code></pre> <p>Record some NFT Metadata</p> Name Type Description tokenId uint256 the id of the asset with the royalties associated nftURI string the URI (https, ipfs, etc) to the metadata describing the NFT"},{"location":"generated/solidity-api/#settokenroyalty_1","title":"setTokenRoyalty","text":"<pre><code>function setTokenRoyalty(uint256 tokenId, address receiver, uint256 royaltyAmount) public\n</code></pre> <p>Record the asset royalties</p> Name Type Description tokenId uint256 the id of the asset with the royalties associated receiver address the receiver of the royalties (the original creator) royaltyAmount uint256 percentage (no decimals, between 0 and 100)"},{"location":"generated/solidity-api/#supportsinterface_3","title":"supportsInterface","text":"<pre><code>function supportsInterface(bytes4 interfaceId) public view virtual returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#poapupgradeable","title":"POAPUpgradeable","text":""},{"location":"generated/solidity-api/#_tokenidcounter","title":"_tokenIdCounter","text":"<pre><code>struct CountersUpgradeable.Counter _tokenIdCounter\n</code></pre>"},{"location":"generated/solidity-api/#_tokenevent","title":"_tokenEvent","text":"<pre><code>mapping(uint256 =&gt; uint256) _tokenEvent\n</code></pre>"},{"location":"generated/solidity-api/#initialize_56","title":"initialize","text":"<pre><code>function initialize() public\n</code></pre>"},{"location":"generated/solidity-api/#initialize_57","title":"initialize","text":"<pre><code>function initialize(string name, string symbol) public virtual\n</code></pre>"},{"location":"generated/solidity-api/#mint_10","title":"mint","text":"<pre><code>function mint(address to, string uri, uint256 eventId) public\n</code></pre>"},{"location":"generated/solidity-api/#mint_11","title":"mint","text":"<pre><code>function mint(address to, uint256 id) public\n</code></pre>"},{"location":"generated/solidity-api/#tokenevent","title":"tokenEvent","text":"<pre><code>function tokenEvent(uint256 tokenId) public view returns (uint256)\n</code></pre>"},{"location":"generated/solidity-api/#_beforetokentransfer_1","title":"_beforeTokenTransfer","text":"<pre><code>function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal\n</code></pre>"},{"location":"generated/solidity-api/#_burn","title":"_burn","text":"<pre><code>function _burn(uint256 tokenId) internal\n</code></pre>"},{"location":"generated/solidity-api/#tokendetailsofowner","title":"tokenDetailsOfOwner","text":"<pre><code>function tokenDetailsOfOwner(address owner) public view returns (uint256[] tokenIds, uint256[] eventIds)\n</code></pre>"},{"location":"generated/solidity-api/#tokenuri_1","title":"tokenURI","text":"<pre><code>function tokenURI(uint256 tokenId) public view returns (string)\n</code></pre>"},{"location":"generated/solidity-api/#isapprovedforall_2","title":"isApprovedForAll","text":"<pre><code>function isApprovedForAll(address account, address operator) public view returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#supportsinterface_4","title":"supportsInterface","text":"<pre><code>function supportsInterface(bytes4 interfaceId) public view virtual returns (bool)\n</code></pre>"},{"location":"generated/solidity-api/#plonkverifier","title":"PlonkVerifier","text":""},{"location":"generated/solidity-api/#n","title":"n","text":"<pre><code>uint32 n\n</code></pre>"},{"location":"generated/solidity-api/#npublic","title":"nPublic","text":"<pre><code>uint16 nPublic\n</code></pre>"},{"location":"generated/solidity-api/#nlagrange","title":"nLagrange","text":"<pre><code>uint16 nLagrange\n</code></pre>"},{"location":"generated/solidity-api/#qmx","title":"Qmx","text":"<pre><code>uint256 Qmx\n</code></pre>"},{"location":"generated/solidity-api/#qmy","title":"Qmy","text":"<pre><code>uint256 Qmy\n</code></pre>"},{"location":"generated/solidity-api/#qlx","title":"Qlx","text":"<pre><code>uint256 Qlx\n</code></pre>"},{"location":"generated/solidity-api/#qly","title":"Qly","text":"<pre><code>uint256 Qly\n</code></pre>"},{"location":"generated/solidity-api/#qrx","title":"Qrx","text":"<pre><code>uint256 Qrx\n</code></pre>"},{"location":"generated/solidity-api/#qry","title":"Qry","text":"<pre><code>uint256 Qry\n</code></pre>"},{"location":"generated/solidity-api/#qox","title":"Qox","text":"<pre><code>uint256 Qox\n</code></pre>"},{"location":"generated/solidity-api/#qoy","title":"Qoy","text":"<pre><code>uint256 Qoy\n</code></pre>"},{"location":"generated/solidity-api/#qcx","title":"Qcx","text":"<pre><code>uint256 Qcx\n</code></pre>"},{"location":"generated/solidity-api/#qcy","title":"Qcy","text":"<pre><code>uint256 Qcy\n</code></pre>"},{"location":"generated/solidity-api/#s1x","title":"S1x","text":"<pre><code>uint256 S1x\n</code></pre>"},{"location":"generated/solidity-api/#s1y","title":"S1y","text":"<pre><code>uint256 S1y\n</code></pre>"},{"location":"generated/solidity-api/#s2x","title":"S2x","text":"<pre><code>uint256 S2x\n</code></pre>"},{"location":"generated/solidity-api/#s2y","title":"S2y","text":"<pre><code>uint256 S2y\n</code></pre>"},{"location":"generated/solidity-api/#s3x","title":"S3x","text":"<pre><code>uint256 S3x\n</code></pre>"},{"location":"generated/solidity-api/#s3y","title":"S3y","text":"<pre><code>uint256 S3y\n</code></pre>"},{"location":"generated/solidity-api/#k1","title":"k1","text":"<pre><code>uint256 k1\n</code></pre>"},{"location":"generated/solidity-api/#k2","title":"k2","text":"<pre><code>uint256 k2\n</code></pre>"},{"location":"generated/solidity-api/#x2x1","title":"X2x1","text":"<pre><code>uint256 X2x1\n</code></pre>"},{"location":"generated/solidity-api/#x2x2","title":"X2x2","text":"<pre><code>uint256 X2x2\n</code></pre>"},{"location":"generated/solidity-api/#x2y1","title":"X2y1","text":"<pre><code>uint256 X2y1\n</code></pre>"},{"location":"generated/solidity-api/#x2y2","title":"X2y2","text":"<pre><code>uint256 X2y2\n</code></pre>"},{"location":"generated/solidity-api/#q","title":"q","text":"<pre><code>uint256 q\n</code></pre>"},{"location":"generated/solidity-api/#qf","title":"qf","text":"<pre><code>uint256 qf\n</code></pre>"},{"location":"generated/solidity-api/#w1","title":"w1","text":"<pre><code>uint256 w1\n</code></pre>"},{"location":"generated/solidity-api/#g1x","title":"G1x","text":"<pre><code>uint256 G1x\n</code></pre>"},{"location":"generated/solidity-api/#g1y","title":"G1y","text":"<pre><code>uint256 G1y\n</code></pre>"},{"location":"generated/solidity-api/#g2x1","title":"G2x1","text":"<pre><code>uint256 G2x1\n</code></pre>"},{"location":"generated/solidity-api/#g2x2","title":"G2x2","text":"<pre><code>uint256 G2x2\n</code></pre>"},{"location":"generated/solidity-api/#g2y1","title":"G2y1","text":"<pre><code>uint256 G2y1\n</code></pre>"},{"location":"generated/solidity-api/#g2y2","title":"G2y2","text":"<pre><code>uint256 G2y2\n</code></pre>"},{"location":"generated/solidity-api/#pa","title":"pA","text":"<pre><code>uint16 pA\n</code></pre>"},{"location":"generated/solidity-api/#pb","title":"pB","text":"<pre><code>uint16 pB\n</code></pre>"},{"location":"generated/solidity-api/#pc","title":"pC","text":"<pre><code>uint16 pC\n</code></pre>"},{"location":"generated/solidity-api/#pz","title":"pZ","text":"<pre><code>uint16 pZ\n</code></pre>"},{"location":"generated/solidity-api/#pt1","title":"pT1","text":"<pre><code>uint16 pT1\n</code></pre>"},{"location":"generated/solidity-api/#pt2","title":"pT2","text":"<pre><code>uint16 pT2\n</code></pre>"},{"location":"generated/solidity-api/#pt3","title":"pT3","text":"<pre><code>uint16 pT3\n</code></pre>"},{"location":"generated/solidity-api/#pwxi","title":"pWxi","text":"<pre><code>uint16 pWxi\n</code></pre>"},{"location":"generated/solidity-api/#pwxiw","title":"pWxiw","text":"<pre><code>uint16 pWxiw\n</code></pre>"},{"location":"generated/solidity-api/#peval_a","title":"pEval_a","text":"<pre><code>uint16 pEval_a\n</code></pre>"},{"location":"generated/solidity-api/#peval_b","title":"pEval_b","text":"<pre><code>uint16 pEval_b\n</code></pre>"},{"location":"generated/solidity-api/#peval_c","title":"pEval_c","text":"<pre><code>uint16 pEval_c\n</code></pre>"},{"location":"generated/solidity-api/#peval_s1","title":"pEval_s1","text":"<pre><code>uint16 pEval_s1\n</code></pre>"},{"location":"generated/solidity-api/#peval_s2","title":"pEval_s2","text":"<pre><code>uint16 pEval_s2\n</code></pre>"},{"location":"generated/solidity-api/#peval_zw","title":"pEval_zw","text":"<pre><code>uint16 pEval_zw\n</code></pre>"},{"location":"generated/solidity-api/#peval_r","title":"pEval_r","text":"<pre><code>uint16 pEval_r\n</code></pre>"},{"location":"generated/solidity-api/#palpha","title":"pAlpha","text":"<pre><code>uint16 pAlpha\n</code></pre>"},{"location":"generated/solidity-api/#pbeta","title":"pBeta","text":"<pre><code>uint16 pBeta\n</code></pre>"},{"location":"generated/solidity-api/#pgamma","title":"pGamma","text":"<pre><code>uint16 pGamma\n</code></pre>"},{"location":"generated/solidity-api/#pxi","title":"pXi","text":"<pre><code>uint16 pXi\n</code></pre>"},{"location":"generated/solidity-api/#pxin","title":"pXin","text":"<pre><code>uint16 pXin\n</code></pre>"},{"location":"generated/solidity-api/#pbetaxi","title":"pBetaXi","text":"<pre><code>uint16 pBetaXi\n</code></pre>"},{"location":"generated/solidity-api/#pv1","title":"pV1","text":"<pre><code>uint16 pV1\n</code></pre>"},{"location":"generated/solidity-api/#pv2","title":"pV2","text":"<pre><code>uint16 pV2\n</code></pre>"},{"location":"generated/solidity-api/#pv3","title":"pV3","text":"<pre><code>uint16 pV3\n</code></pre>"},{"location":"generated/solidity-api/#pv4","title":"pV4","text":"<pre><code>uint16 pV4\n</code></pre>"},{"location":"generated/solidity-api/#pv5","title":"pV5","text":"<pre><code>uint16 pV5\n</code></pre>"},{"location":"generated/solidity-api/#pv6","title":"pV6","text":"<pre><code>uint16 pV6\n</code></pre>"},{"location":"generated/solidity-api/#pu","title":"pU","text":"<pre><code>uint16 pU\n</code></pre>"},{"location":"generated/solidity-api/#ppl","title":"pPl","text":"<pre><code>uint16 pPl\n</code></pre>"},{"location":"generated/solidity-api/#peval_t","title":"pEval_t","text":"<pre><code>uint16 pEval_t\n</code></pre>"},{"location":"generated/solidity-api/#pa1","title":"pA1","text":"<pre><code>uint16 pA1\n</code></pre>"},{"location":"generated/solidity-api/#pb1","title":"pB1","text":"<pre><code>uint16 pB1\n</code></pre>"},{"location":"generated/solidity-api/#pzh","title":"pZh","text":"<pre><code>uint16 pZh\n</code></pre>"},{"location":"generated/solidity-api/#pzhinv","title":"pZhInv","text":"<pre><code>uint16 pZhInv\n</code></pre>"},{"location":"generated/solidity-api/#peval_l1","title":"pEval_l1","text":"<pre><code>uint16 pEval_l1\n</code></pre>"},{"location":"generated/solidity-api/#peval_l2","title":"pEval_l2","text":"<pre><code>uint16 pEval_l2\n</code></pre>"},{"location":"generated/solidity-api/#peval_l3","title":"pEval_l3","text":"<pre><code>uint16 pEval_l3\n</code></pre>"},{"location":"generated/solidity-api/#peval_l4","title":"pEval_l4","text":"<pre><code>uint16 pEval_l4\n</code></pre>"},{"location":"generated/solidity-api/#peval_l5","title":"pEval_l5","text":"<pre><code>uint16 pEval_l5\n</code></pre>"},{"location":"generated/solidity-api/#peval_l6","title":"pEval_l6","text":"<pre><code>uint16 pEval_l6\n</code></pre>"},{"location":"generated/solidity-api/#peval_l7","title":"pEval_l7","text":"<pre><code>uint16 pEval_l7\n</code></pre>"},{"location":"generated/solidity-api/#lastmem","title":"lastMem","text":"<pre><code>uint16 lastMem\n</code></pre>"},{"location":"generated/solidity-api/#verifyproof_1","title":"verifyProof","text":"<pre><code>function verifyProof(bytes proof, uint256[] pubSignals) public view returns (bool)\n</code></pre>"}]}